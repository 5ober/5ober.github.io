<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blankの博客</title>
  
  <subtitle>Keep theme quick starter</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-25T18:35:54.807Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Blank</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WSL设置静态IP</title>
    <link href="http://example.com/2023/03/25/WSL%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/"/>
    <id>http://example.com/2023/03/25/WSL%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/</id>
    <published>2023-03-25T11:58:50.626Z</published>
    <updated>2023-03-25T18:35:54.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WSL设置静态IP"><a href="#WSL设置静态IP" class="headerlink" title="WSL设置静态IP"></a>WSL设置静态IP</h2><p>微软终于更新了 WSL2，允许用户自行指定用于 WSL2 的网卡，因此不再需要任何的脚本等等即可固定 WSL2 地址甚至支持 IPv6 和外部访问。</p><p>注意：此方法需要至少 Windows 11 22H2。</p><h5 id="首先需要从-Microsoft-Store-里面下载最新的-Windows-Subsystem-for-Linux。"><a href="#首先需要从-Microsoft-Store-里面下载最新的-Windows-Subsystem-for-Linux。" class="headerlink" title="首先需要从 Microsoft Store 里面下载最新的 Windows Subsystem for Linux。"></a>首先需要从 Microsoft Store 里面下载最新的 Windows Subsystem for Linux。</h5><p>用不了商店的可以前往这里自己下载 msixbundle 部署安装：<a class="link"   href="https://link.zhihu.com/?target=https://github.com/microsoft/WSL/releases" >https://github.com/microsoft/WSL/releases<i class="fas fa-external-link-alt"></i></a></p><p>装好之后可以运行 <code>wsl --version</code> 确认一下是不是 1.0 以上。</p><p>然后在用户目录 <code>%USERPROFILE%</code> 下面创建一个配置文件 <code>.wslconfig</code>，按照如下配置方法设置网络，例如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[wsl2]</span></span><br><span class="line"><span class="attr">networkingMode</span>=bridged <span class="comment"># 桥接模式</span></span><br><span class="line"><span class="attr">vmSwitch</span>=WSLBridge <span class="comment"># 你想使用的网卡</span></span><br><span class="line"><span class="attr">ipv6</span>=<span class="literal">true</span> <span class="comment"># 启用 IPv6[wsl2]</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown &amp;&amp; wsl</span><br></pre></td></tr></table></figure><p>重启 WSL2，搞定</p><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl --version</span><br><span class="line"><span class="comment"># 版本&gt;1.0即可</span></span><br></pre></td></tr></table></figure><p>如果出错，请<a class="link"   href="https://learn.microsoft.com/zh-cn/windows/wsl/install" >安装最新版本<i class="fas fa-external-link-alt"></i></a></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>.wslconfig<br>用于在 WSL 2 上运行的所有已安装分发版 <strong>全局</strong> 配置设置。</p><p>wsl.conf<br>为 WSL 1 或 WSL 2 上运行的 Linux 发行版配置 每个分发 版的设置。</p><p>这里详细配置介绍请移步 <a class="link"   href="https://learn.microsoft.com/zh-cn/windows/wsl/wsl-config" >高级设置配置<i class="fas fa-external-link-alt"></i></a></p><h2 id="配置WSL2使用外部网络"><a href="#配置WSL2使用外部网络" class="headerlink" title="配置WSL2使用外部网络"></a>配置WSL2使用外部网络</h2><p>使用Hyper-V创建外部网络（其他方式创建也行）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络交换机名称</span></span><br><span class="line"><span class="built_in">Get-VMSwitch</span> <span class="literal">-SwitchType</span> External</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/uTools_1679587233100.6blp5g6ezac0.jpg"                      alt="uTools_1679587233100"                ></p><p>配置 .wslconfig<br>存储在目录中 %UserProfile%，或者 PowerShell 中使用 cd ~ 访问主目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">networkingMode=bridge</span><br><span class="line">vmSwitch=WSL_Bridge</span><br><span class="line">ipv6=true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">dhcp=<span class="literal">false</span></span></span><br><span class="line">memory=8GB</span><br><span class="line">processors=4</span><br><span class="line">localhostforwarding=true</span><br><span class="line">debugConsole=false</span><br><span class="line">guiApplications=true</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重启 WSL2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br><span class="line">wsl</span><br><span class="line">ip a</span><br></pre></td></tr></table></figure><p>​       可以看到eth0的网络是桥接网络了</p><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/Snipaste_2023-03-25_17-27-51.1o5xgami6rds.jpg"                      alt="Snipaste_2023-03-25_17-27-51"                ></p><p>修改DNS禁止自动生成</p><p>添加 <code>/etc/wsl.conf</code> 加入以下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[boot]</span></span><br><span class="line"><span class="comment"># 启用systemctl命令</span></span><br><span class="line"><span class="attr">systemd</span>=<span class="literal">true</span></span><br><span class="line"><span class="section">[network]</span></span><br><span class="line"><span class="comment"># 取消自动生成resolv.conf文件，这个是关键点</span></span><br><span class="line"><span class="attr">generateResolvConf</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment"># 设置虚拟主机的名称，默认的不好看</span></span><br><span class="line"><span class="comment">#hostname = </span></span><br><span class="line"><span class="section">[user]</span></span><br><span class="line"><span class="comment"># 启动的默认用户，设为root吧，不然以后命令都要加sudo有点麻烦</span></span><br><span class="line"><span class="attr">default</span> = root</span><br></pre></td></tr></table></figure><p>先删除再创建，因为resolv.conf是软链接创建的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f /etc/resolv.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 223.5.5.5&quot;</span> &gt; /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS</span></span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>重启WSL2 (wsl –shutdown)</p><p>而且还启用了<code>systemd</code> (systemctl 命令回来了)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files --<span class="built_in">type</span>=service</span><br><span class="line"></span><br><span class="line">systemctl restart systemd-networkd</span><br><span class="line">systemctl <span class="built_in">enable</span> systemd-networkd</span><br><span class="line">systemctl restart systemd-resolved.service</span><br><span class="line">systemctl <span class="built_in">enable</span> systemd-resolved.service</span><br></pre></td></tr></table></figure><h2 id="设置特定静态IP-本人设置后ping不通"><a href="#设置特定静态IP-本人设置后ping不通" class="headerlink" title="设置特定静态IP [本人设置后ping不通]"></a>设置特定静态IP [本人设置后ping不通]</h2><p>修改 .wslconfig</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[wsl2]</span></span><br><span class="line"><span class="attr">networkingMode</span>=bridged</span><br><span class="line"><span class="attr">vmSwitch</span>=WSL_external</span><br><span class="line"><span class="attr">dhcp</span>=<span class="literal">false</span> <span class="comment"># 禁止动态分配</span></span><br><span class="line"><span class="attr">ipv6</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>当<code>dhcp=false</code>时会读取 <code>cd /lib/systemd/network/wsl_external.network</code> 的网络配置</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim wsl_external.network 加入以下内容</span><br><span class="line"></span><br><span class="line"><span class="section">[Match]</span></span><br><span class="line"><span class="attr">Name</span>=eth0</span><br><span class="line"><span class="section">[Network]</span></span><br><span class="line"><span class="attr">Description</span>=bridge</span><br><span class="line"><span class="attr">DHCP</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">Address</span>=<span class="number">192.168</span>.<span class="number">1.10</span>/<span class="number">24</span> <span class="comment"># 自行修改</span></span><br><span class="line"><span class="attr">Gateway</span>=<span class="number">192.168</span>.<span class="number">0.1</span> <span class="comment"># 自行修改</span></span><br></pre></td></tr></table></figure><p>重启WSL2 (wsl –shutdown)<br>你会发现eth0已经有自定义的网络了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://zhuanlan.zhihu.com/p/593263088" >WSL2 网络的最终解决方案 - 知乎 (zhihu.com)<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://zhuanlan.zhihu.com/p/60004296" >WSL2远程连接SSH1<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.cnblogs.com/lic0914/p/17003251.html" >WSL使用桥接网络指定IP<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://zhuanlan.zhihu.com/p/600042961" >安装WSL2并下载配置Ubuntu<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WSL设置静态IP&quot;&gt;&lt;a href=&quot;#WSL设置静态IP&quot; class=&quot;headerlink&quot; title=&quot;WSL设置静态IP&quot;&gt;&lt;/a&gt;WSL设置静态IP&lt;/h2&gt;&lt;p&gt;微软终于更新了 WSL2，允许用户自行指定用于 WSL2 的网卡，因此不再需要任何的</summary>
      
    
    
    
    <category term="WSL设置静态IP" scheme="http://example.com/categories/WSL%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/"/>
    
    
    <category term="WSL设置静态IP" scheme="http://example.com/tags/WSL%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/"/>
    
  </entry>
  
  <entry>
    <title>WSL安装图形界面xfce4</title>
    <link href="http://example.com/2023/03/25/WSL%E5%AE%89%E8%A3%85%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83xfce4/"/>
    <id>http://example.com/2023/03/25/WSL%E5%AE%89%E8%A3%85%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83xfce4/</id>
    <published>2023-03-25T11:58:50.623Z</published>
    <updated>2023-03-25T18:41:54.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WSL安装图形界面xfce4"><a href="#WSL安装图形界面xfce4" class="headerlink" title="WSL安装图形界面xfce4"></a>WSL安装图形界面xfce4</h1><p>最近想在WSL2里安装一个可视化图形界面，之前装过vcXsrv这种方案，不过最近打不开了，也是尝试了Vnc server 不过容易灰屏，最后在vcXsrv ，Vnc server和 xrdp这3种方案中最终选择了xrdp这种方案，利用Windows的远程连接来连接xfce4桌面</p><h4 id="更新升级软件-可选"><a href="#更新升级软件-可选" class="headerlink" title="更新升级软件 (可选)"></a>更新升级软件 (可选)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h4 id="安装桌面环境xfce4"><a href="#安装桌面环境xfce4" class="headerlink" title="安装桌面环境xfce4"></a>安装桌面环境xfce4</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xfce4 xfce4-goodies</span><br></pre></td></tr></table></figure><p><strong>注: <font color=red>display manager</font>选择 <font color=red>gdm3</font> 或<font color=red> lightdm </font>均可。</strong></p><h4 id="设置系统语言"><a href="#设置系统语言" class="headerlink" title="设置系统语言"></a>设置系统语言</h4><p>默认情况下，Linux是没有中文语言包的。我们需要手动下载语言包并配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装中文字体</span></span><br><span class="line">sudo apt-get install ttf-wqy-zenhei</span><br></pre></td></tr></table></figure><p>之后，我们设置系统的语言：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置系统语言</span></span><br><span class="line">sudo dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>方向键找到中文后<font color=red>zh_CN,UTF-8 UTF-8</font>，按空格：</p><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260039799.1ipe817m74ww.jpg"                      alt="202303260039799"                ></p><p>之后再回车确认，然后选择中文：<font color=red>zh_CN,UTF-8 </font></p><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260039597.d0b7i1sk4a8.jpg"                      alt="202303260039597"                ></p><h4 id="安装远程桌面服务xrdp"><a href="#安装远程桌面服务xrdp" class="headerlink" title="安装远程桌面服务xrdp"></a><strong>安装远程桌面服务</strong>xrdp</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xrdp</span><br></pre></td></tr></table></figure><h4 id="修改配置文件xrdp-ini"><a href="#修改配置文件xrdp-ini" class="headerlink" title="修改配置文件xrdp.ini"></a>修改配置文件xrdp.ini</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制一份备用</span></span><br><span class="line">sudo cp /etc/xrdp/xrdp.ini /etc/xrdp/xrdp.ini.bak</span><br></pre></td></tr></table></figure><h4 id="配置端口-3389-改为-3390，避免和windows的端口冲突"><a href="#配置端口-3389-改为-3390，避免和windows的端口冲突" class="headerlink" title="配置端口 3389 改为 3390，避免和windows的端口冲突"></a>配置端口 3389 改为 3390，避免和windows的端口冲突</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i &#x27;s/3389/3390/g&#x27; /etc/xrdp/xrdp.ini</span><br></pre></td></tr></table></figure><h4 id="max-bpp-x3D-32-修改为-128（最大位图深度）"><a href="#max-bpp-x3D-32-修改为-128（最大位图深度）" class="headerlink" title="max_bpp&#x3D;32 修改为 128（最大位图深度）"></a>max_bpp&#x3D;32 修改为 128（最大位图深度）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i &#x27;s/max_bpp=32/#max_bbp=32\nmax_bpp=128/g&#x27; /etc/xrdp/xrdp.ini</span><br></pre></td></tr></table></figure><h4 id="xserverbpp-x3D-24-修改为-128，取消注释"><a href="#xserverbpp-x3D-24-修改为-128，取消注释" class="headerlink" title="xserverbpp&#x3D;24 修改为 128，取消注释"></a>xserverbpp&#x3D;24 修改为 128，取消注释</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i &#x27;s/xservervpp=24/#xservervpp=24\nxserverbpp=128/g&#x27; /etc/xrdp/xrdp.ini</span><br></pre></td></tr></table></figure><h4 id="新增配置文件-xsession"><a href="#新增配置文件-xsession" class="headerlink" title="新增配置文件.xsession"></a>新增配置文件.xsession</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">告诉系统: 开启桌面环境的时候用xfce4-session</span></span><br><span class="line">sudo echo xfce4-session &gt; ~/.xsession</span><br></pre></td></tr></table></figure><h4 id="配置sesman-ini"><a href="#配置sesman-ini" class="headerlink" title="配置sesman.ini"></a>配置sesman.ini</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/xrdp/sesman.ini</span><br></pre></td></tr></table></figure><p>将 <strong><font color=red>KillDisconnected</font></strong> 的值修改为 **<font color=red>true</font>**保存退出</p><h4 id="修改配置startwm-sh"><a href="#修改配置startwm-sh" class="headerlink" title="修改配置startwm.sh"></a>修改配置startwm.sh</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/xrdp/startwm.sh</span><br></pre></td></tr></table></figure><p><strong>注释掉末尾亮行，并添加一行 <font color=red>startxfce4</font></strong> </p><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260040932.6swz4mq9ick0.jpg"                      alt="202303260040932"                ></p><h4 id="启用-xrdp-服务"><a href="#启用-xrdp-服务" class="headerlink" title="启用 xrdp 服务"></a>启用 xrdp 服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/xrdp start</span><br></pre></td></tr></table></figure><h3 id="远程桌面链接"><a href="#远程桌面链接" class="headerlink" title="远程桌面链接"></a>远程桌面链接</h3><p>按下 <strong>Windows+R</strong> 键，输入 <strong>mstsc</strong> 打开远程桌面连接</p><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260040033.5dw48sun3ts.jpg"                      alt="202303260040033"                ></p><p>IP为本机即 localhost，端口为配置的<strong>3390</strong>，IP 也可以使用 ip a 或 ifconfig命令查到的 eth0 inet 地址</p><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260040872.50b5o6ruz8s0.jpg"                      alt="202303260040872"                ></p><p>连接后进入登录页面，用户名和密码填写 WSL 的用户名和密码。注：不要使用 <strong>root</strong>用户登录</p><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260040129.2k694if582u0.jpg"                      alt="202303260040129"                ></p><p>登录成功进入xfce4桌面</p><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260041097.701kmlgg8yo0.jpg"                      alt="202303260041097"                ></p><h4 id="停止-xrdp-服务"><a href="#停止-xrdp-服务" class="headerlink" title="停止 xrdp 服务"></a>停止 xrdp 服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/xrdp stop</span><br></pre></td></tr></table></figure><p>不使用时执行停止命令就行</p><h4 id="卸载-xrdp-服务"><a href="#卸载-xrdp-服务" class="headerlink" title="卸载 xrdp 服务"></a>卸载 xrdp 服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge xrdp</span><br></pre></td></tr></table></figure><p><strong><a class="link"   href="https://blog.csdn.net/w47_csdn/article/details/129107705" >参考 Xrdp 方式连接<i class="fas fa-external-link-alt"></i></a></strong></p><p><strong><a class="link"   href="https://www.mintimate.cn/2021/05/15/installVNC/#%F0%9F%98%8B%E5%88%9D%E5%A7%8B%E5%8C%96tightvncserver" >参考VNC server方式连接<i class="fas fa-external-link-alt"></i></a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WSL安装图形界面xfce4&quot;&gt;&lt;a href=&quot;#WSL安装图形界面xfce4&quot; class=&quot;headerlink&quot; title=&quot;WSL安装图形界面xfce4&quot;&gt;&lt;/a&gt;WSL安装图形界面xfce4&lt;/h1&gt;&lt;p&gt;最近想在WSL2里安装一个可视化图形界面，之</summary>
      
    
    
    
    <category term="WSL图形界面xfce4" scheme="http://example.com/categories/WSL%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2xfce4/"/>
    
    
    <category term="WSL图形界面xfce4" scheme="http://example.com/tags/WSL%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2xfce4/"/>
    
  </entry>
  
  <entry>
    <title>Docker 搭建私服仓库</title>
    <link href="http://example.com/2023/03/25/Docker-%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%8D%E4%BB%93%E5%BA%93/"/>
    <id>http://example.com/2023/03/25/Docker-%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%8D%E4%BB%93%E5%BA%93/</id>
    <published>2023-03-25T11:57:27.091Z</published>
    <updated>2023-03-25T18:29:55.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-搭建私服仓库"><a href="#Docker-搭建私服仓库" class="headerlink" title="Docker 搭建私服仓库"></a>Docker 搭建私服仓库</h1><p>最近想搭建一个属于自己的私服仓库，目前人们普遍使用的有GitLab、Gogs、Gitea、Gitblit 这几个比较常用，GitLab主要公司用的比较多，功能也比较全面，但是比较占用内存，我安装完又给卸载了，如果你内存比较大使用也挺好，Gogs是基于Go语言开发的，跨平台性也挺好，Windows、Linux、Mac端也都有，比较轻量级，安装包也比较小，占用内存最少，Gitea和Gogs之前是一个团队，因为意向不同分开了，也是基于Gogs的分支开发的，界面有些类似但是功能目前比Gogs多，个人觉得还是比较好用的，Gitblit 之前我也使用过不过当时是在Windows端安装的，Gitblit是基于Java语言开发的，跨平台性也比较好，各个平台也都有，用着还不错不过和这几个对比一下，总觉的图形界面不够美观，目前感觉使用的人不是太多了，对比而言个人使用的话还是比较推荐Gogs和Gitea，我目前会使用Gitea，相对于Gogs的内存占用也不是太多，功能还比较全面！</p><h3 id="1-安装gogs"><a href="#1-安装gogs" class="headerlink" title="1.安装gogs"></a>1.安装gogs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要创建 gogs 数据库</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull gogs/gogs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建映射文件目录</span></span><br><span class="line">mkdir -p /var/gogs</span><br><span class="line"></span><br><span class="line">docker run --name=gogs --restart always -p 122:22 -p 3000:3000 -v /var/gogs:/data gogs/gogs</span><br><span class="line"></span><br><span class="line">docker start gogs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">踩坑记录 切记http 要填写3000端口 不要更改，不然无法访问</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/4fc497e048ae4888adf4d0c0caf55821.65q01cj2ayg0.webp"                      alt="4fc497e048ae4888adf4d0c0caf55821"                ></p><h3 id="2-安装gitea"><a href="#2-安装gitea" class="headerlink" title="2.安装gitea"></a>2.安装gitea</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要创建 gitea 数据库</span> </span><br><span class="line">docker pull gitea/gitea</span><br><span class="line"></span><br><span class="line">mkdir -p /var/gitea</span><br><span class="line"></span><br><span class="line">docker run -d --name=gitea --restart always -p 121:22 -p 3000:3000 -v /var/gitea:/data gitea/gitea</span><br><span class="line"></span><br><span class="line">docker start gitea</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">踩坑记录 切记http 要填写3000端口 不要更改，不然无法访问</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260026608.4e4pnz1nj860.webp"                      alt="202303260026608"                ></p><h3 id="3-安装gitblit"><a href="#3-安装gitblit" class="headerlink" title="3.安装gitblit"></a>3.安装gitblit</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitblit/gitblit:rpc</span><br><span class="line"></span><br><span class="line">mkdir -p /var/gitblit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https访问</span></span><br><span class="line">docker run -d --name gitblit -p 8443:8443 -p 29418:29418 -v /var/gitblit:/data gitblit/gitblit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https和http访问</span></span><br><span class="line">docker run -d --name gitblit --restart always -p 8180:8080 -p 8443:8443 -p 9418:9418 -p 29418:29418 -v /var/gitblit:/data gitblit/gitblit</span><br><span class="line"></span><br><span class="line">docker start gitblit</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260102544.13qayufmyzsw.webp"                      alt="202303260102544"                ></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line">docker run --name mysql5.7 -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-搭建私服仓库&quot;&gt;&lt;a href=&quot;#Docker-搭建私服仓库&quot; class=&quot;headerlink&quot; title=&quot;Docker 搭建私服仓库&quot;&gt;&lt;/a&gt;Docker 搭建私服仓库&lt;/h1&gt;&lt;p&gt;最近想搭建一个属于自己的私服仓库，目前人们普遍使用的</summary>
      
    
    
    
    <category term="Gogs Gitea Gitblit" scheme="http://example.com/categories/Gogs-Gitea-Gitblit/"/>
    
    
    <category term="Gogs Gitea Gitblit 部署" scheme="http://example.com/tags/Gogs-Gitea-Gitblit-%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>gitlab 域名与克隆地址</title>
    <link href="http://example.com/2023/03/22/GitLab%20%E5%9F%9F%E5%90%8D%E4%B8%8E%E5%85%8B%E9%9A%86%E5%9C%B0%E5%9D%80%E4%B8%8D%E4%B8%80%E8%87%B4%E4%BF%AE%E6%94%B9/"/>
    <id>http://example.com/2023/03/22/GitLab%20%E5%9F%9F%E5%90%8D%E4%B8%8E%E5%85%8B%E9%9A%86%E5%9C%B0%E5%9D%80%E4%B8%8D%E4%B8%80%E8%87%B4%E4%BF%AE%E6%94%B9/</id>
    <published>2023-03-22T03:09:28.783Z</published>
    <updated>2023-03-22T03:07:19.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gitlab-域名与克隆地址不一致修改"><a href="#gitlab-域名与克隆地址不一致修改" class="headerlink" title="gitlab 域名与克隆地址不一致修改"></a>gitlab 域名与克隆地址不一致修改</h2><h4 id="1-gitlab替换https"><a href="#1-gitlab替换https" class="headerlink" title="1.gitlab替换https"></a>1.gitlab替换https</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置gitlab替换https://域名 ,如：&#x27;https://xxx.com&#x27;</span></span><br><span class="line">vim /etc/gitlab/gitlab.rb   </span><br><span class="line"><span class="comment">#打开配置文件</span></span><br><span class="line">external_url <span class="string">&#x27;external_url &#x27;</span>https://192.168.1.12:8089<span class="string">&#x27;  # 注：一定要HTTPS</span></span><br></pre></td></tr></table></figure><h4 id="2-添加ssl-证书"><a href="#2-添加ssl-证书" class="headerlink" title="2.添加ssl 证书"></a>2.添加ssl 证书</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个ssl文件 把申请的证书放在这个文件夹里</span></span><br><span class="line"><span class="built_in">mkdir</span> /etc/gitlab/ssl  </span><br><span class="line"><span class="comment">#打开配置文件</span></span><br><span class="line">vim  /etc/gitlab/gitlab.rb  </span><br><span class="line"><span class="comment">#取消注释改为 true</span></span><br><span class="line">nginx[<span class="string">&#x27;redirect_http_to_https&#x27;</span>]= <span class="literal">true</span></span><br><span class="line"><span class="comment">#放置对应的证书名称</span></span><br><span class="line">nginx[<span class="string">&#x27;ssl_certificate&#x27;</span>] = <span class="string">&quot;/etc/gitlab/ssl/xxxx.crt&quot;</span>  </span><br><span class="line"><span class="comment">#放置对应的证书名称</span></span><br><span class="line">nginx[<span class="string">&#x27;ssl_certificate_key&#x27;</span>] = <span class="string">&quot;/etc/gitlab/ssl/xxxx.key&quot;</span> </span><br><span class="line"><span class="comment">#使配置生效</span></span><br><span class="line">gitlab-ctl reconfigure </span><br></pre></td></tr></table></figure><h4 id="3-修改clone-地址"><a href="#3-修改clone-地址" class="headerlink" title="3.修改clone 地址"></a>3.修改clone 地址</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /var/opt/gitlab/gitlab-rails/etc/gitlab.yml  <span class="comment">#打开配置文件，参考图修改后重启</span></span><br><span class="line">gitlab-ctl restart  <span class="comment"># 重起生效 # </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;gitlab-域名与克隆地址不一致修改&quot;&gt;&lt;a href=&quot;#gitlab-域名与克隆地址不一致修改&quot; class=&quot;headerlink&quot; title=&quot;gitlab 域名与克隆地址不一致修改&quot;&gt;&lt;/a&gt;gitlab 域名与克隆地址不一致修改&lt;/h2&gt;&lt;h4 i</summary>
      
    
    
    
    <category term="SSL认证" scheme="http://example.com/categories/SSL%E8%AE%A4%E8%AF%81/"/>
    
    
    <category term="SSL认证" scheme="http://example.com/tags/SSL%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux 配置 JDK Maven 环境变量</title>
    <link href="http://example.com/2023/03/22/%E9%85%8D%E7%BD%AEMaven%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://example.com/2023/03/22/%E9%85%8D%E7%BD%AEMaven%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2023-03-21T19:13:04.673Z</published>
    <updated>2023-03-21T19:14:14.378Z</updated>
    
    <content type="html"><![CDATA[<p>使用命令 <strong>java</strong> 、<strong>javac</strong> 、 <strong>java -version</strong> 来查看是否安装了JDK</p><p>rpm -qa | grep java 或 rpm -qa | grep jdk <strong>命令来查询出系统自带的jdk（蓝框的四个就是系统自带的）注：其余的不要删</strong></p><p>然后通过    rpm -e –nodeps   后面跟系统自带的jdk名    这个命令来删除系统自带的jdk，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载 CentOS 7.9 自带JDK</span></span><br><span class="line">rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.262.b10-1.el7.x86_64</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.261-2.6.22.2.el7_8.x86_64</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64</span><br></pre></td></tr></table></figure><h4 id="配置Java环境变量"><a href="#配置Java环境变量" class="headerlink" title="配置Java环境变量"></a>配置Java环境变量</h4><p>解压下载好的JDK安装包<br>解压路径：&#x2F;usr&#x2F;local&#x2F;java&#x2F;</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置Java环境变量</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/java/jdk1.8.0_221</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> JAVA_PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$&#123;JRE_HOME&#125;</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;JAVA_PATH&#125;</span></span><br></pre></td></tr></table></figure><h4 id="配置Maven环境变量"><a href="#配置Maven环境变量" class="headerlink" title="配置Maven环境变量"></a>配置Maven环境变量</h4><p>解压下载好的maven安装包<br>解压路径：&#x2F;usr&#x2F;local&#x2F;maven&#x2F;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置Maven环境变量</span></span><br><span class="line"></span><br><span class="line">export MAVEN_HOME=/usr/local/maven/apache-maven-3.9.0</span><br><span class="line">export PATH=$&#123;MAVEN_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><h4 id="Linux：-解决每次重启机器环境变量都需要-source-x2F-etc-x2F-profile-才生效"><a href="#Linux：-解决每次重启机器环境变量都需要-source-x2F-etc-x2F-profile-才生效" class="headerlink" title="Linux： 解决每次重启机器环境变量都需要 source &#x2F;etc&#x2F;profile 才生效"></a>Linux： 解决每次重启机器环境变量都需要 source &#x2F;etc&#x2F;profile 才生效</h4><ul><li><a class="link"   href="https://blog.csdn.net/qq_41538097/article/details/107110230#1bashrc_6" >1、将环境变量配置在~&#x2F;.bashrc里面。<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/qq_41538097/article/details/107110230#2bashrcsource_etcprofile_24" >2、在~&#x2F;.bashrc里面加一句source &#x2F;etc&#x2F;profile<i class="fas fa-external-link-alt"></i></a></li></ul><p>.bashrc 文件说明：bash 在每次启动时都会自动载入 bashrc 配置文件中的内容，.bashrc 文件可以执行一些命令以及脚本，有以下两种解决方法解决每次重启机器环境变量都需要 source &#x2F;etc&#x2F;profile 才生效</p><h5 id="1、将环境变量配置在-x2F-bashrc里面。"><a href="#1、将环境变量配置在-x2F-bashrc里面。" class="headerlink" title="1、将环境变量配置在~&#x2F;.bashrc里面。"></a>1、将环境变量配置在~&#x2F;.bashrc里面。</h5><p>~代表当前用户目录，我是root用户登录的，如可以使用如下命令进入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /root/.bashrc</span><br><span class="line">或</span><br><span class="line">vi ~/.bashrc</span><br></pre></td></tr></table></figure><h5 id="2-添加环境变量"><a href="#2-添加环境变量" class="headerlink" title="2.添加环境变量"></a>2.添加环境变量</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置Java环境变量</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/java/jdk1.8.0_221</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> JAVA_PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$&#123;JRE_HOME&#125;</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;JAVA_PATH&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用命令 &lt;strong&gt;java&lt;/strong&gt; 、&lt;strong&gt;javac&lt;/strong&gt; 、 &lt;strong&gt;java -version&lt;/strong&gt; 来查看是否安装了JDK&lt;/p&gt;
&lt;p&gt;rpm -qa | grep java 或 rpm -qa | gr</summary>
      
    
    
    
    <category term="JDK Maven 环境变量" scheme="http://example.com/categories/JDK-Maven-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
    
    <category term="JDK Maven 环境变量" scheme="http://example.com/tags/JDK-Maven-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>安装Jenkins 的方式</title>
    <link href="http://example.com/2023/03/22/%E5%AE%89%E8%A3%85Jenkins-%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2023/03/22/%E5%AE%89%E8%A3%85Jenkins-%E7%9A%84%E6%96%B9%E5%BC%8F/</id>
    <published>2023-03-21T19:13:04.671Z</published>
    <updated>2023-03-25T18:55:13.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Jenkins-的方式"><a href="#安装Jenkins-的方式" class="headerlink" title="安装Jenkins 的方式"></a>安装Jenkins 的方式</h1><p>Jenkins 是一个可扩展的持续集成（CI）平台。它只是一个平台，真正运作的都是插件。<br>Jenkins的主要作用：持续的监控软件版本发布&#x2F;测试项目。<br>监控外部定时调用执行的工作。</p><p><strong>接下来记录一下所踩得的坑 !</strong></p><h3 id="1-Docker安装"><a href="#1-Docker安装" class="headerlink" title="1.Docker安装"></a>1.Docker安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Linux本地目录并赋权</span></span><br><span class="line"></span><br><span class="line">mkdir -p /var/jenkins_data</span><br><span class="line">chmod 777 /var/jenkins_data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像 目前  对应 jenkins 官方 2.332.3</span></span><br><span class="line"></span><br><span class="line">docker pull jenkinsci/blueocean:1.25.3   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对应 jenkins 官方 2.346.1 LTS 支持JDK8-11-17</span> </span><br><span class="line"></span><br><span class="line">docker pull jenkinsci/blueocean:1.25.5   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一定要挂载Maven和JDK8 自带JDK11也可以用</span></span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">  -u root \</span><br><span class="line">  -d \</span><br><span class="line">  --name jenkins \</span><br><span class="line">  --restart always \</span><br><span class="line">  -p 8090:8080 \</span><br><span class="line">  -p 8091:50000 \</span><br><span class="line">  -v /var/jenkins_data:/var/jenkins_home \</span><br><span class="line">  -v /usr/local/java/jdk1.8.0_221:/usr/local/java/jdk1.8.0_221 \</span><br><span class="line">  -v /usr/local/maven/apache-maven-3.9.0:/usr/local/maven/apache-maven-3.9.0 \</span><br><span class="line">   jenkinsci/blueocean:1.25.5</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260100237.1ln1ov5u5ygw.jpg"                      alt="202303260100237"                ></p><h3 id="Docker安装第一次需要进入容器才能获取密码"><a href="#Docker安装第一次需要进入容器才能获取密码" class="headerlink" title="Docker安装第一次需要进入容器才能获取密码"></a>Docker安装第一次需要进入容器才能获取密码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/jenkins_home/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260100692.7l264u4ylho0.jpg"                      alt="202303260100692"                ></p><h3 id="接下来登录安装插件"><a href="#接下来登录安装插件" class="headerlink" title="接下来登录安装插件!"></a>接下来登录安装插件!</h3><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260100519.174eefsn5u4g.jpg"                      alt="202303260100519"                ></p><h3 id="插件安装完注册账号重启登录"><a href="#插件安装完注册账号重启登录" class="headerlink" title="插件安装完注册账号重启登录"></a>插件安装完注册账号重启登录</h3><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260100147.5keh2gw2c9s0.jpg"                      alt="202303260100147"                ></p><h3 id="修改为国内的清华大学官方镜像地址，最终内容如下："><a href="#修改为国内的清华大学官方镜像地址，最终内容如下：" class="headerlink" title="修改为国内的清华大学官方镜像地址，最终内容如下："></a>修改为国内的清华大学官方镜像地址，最终内容如下：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">找到这个配置文件hudson.model.UpdateCenter.xml</span></span><br><span class="line"></span><br><span class="line">   &lt;?xml version=&#x27;1.1&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span><br><span class="line">&lt;sites&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;id&gt;default&lt;/id&gt;</span><br><span class="line">    &lt;!--清华镜像--&gt;</span><br><span class="line">    &lt;url&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&lt;/url&gt;</span><br><span class="line">    &lt;!--官方镜像</span><br><span class="line">    &lt;url&gt;https://updates.jenkins.io/update-center.json&lt;/url&gt;--&gt;</span><br><span class="line">  &lt;/site&gt;</span><br><span class="line">&lt;/sites&gt;</span><br></pre></td></tr></table></figure><h3 id="插件管理高级里更改URL地址"><a href="#插件管理高级里更改URL地址" class="headerlink" title="插件管理高级里更改URL地址"></a>插件管理高级里更改URL地址</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260101482.2w22v4uztoy0.jpg"                      alt="202303260101482"                ></p><h3 id="配置Maven-Setting-xml路径-Docker安装最好挂载本地Maven"><a href="#配置Maven-Setting-xml路径-Docker安装最好挂载本地Maven" class="headerlink" title="配置Maven Setting.xml路径 Docker安装最好挂载本地Maven"></a>配置Maven Setting.xml路径 Docker安装最好挂载本地Maven</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件目录  获取JDK目录</span></span><br><span class="line"></span><br><span class="line">  echo $JAVA_HOME </span><br><span class="line">  /opt/java/openjdk</span><br><span class="line">  /usr/local/java/jdk1.8.0_221</span><br><span class="line">  /usr/local/maven/apache-maven-3.9.0</span><br><span class="line">  /usr/local/maven/apache-maven-3.9.0/conf/settings.xml</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260101807.6dsymz4ilbc0.jpg"                      alt="202303260101807"                ></p><h3 id="配置JDK-容器里自带JDK，也可挂载本地JDK-8"><a href="#配置JDK-容器里自带JDK，也可挂载本地JDK-8" class="headerlink" title="配置JDK 容器里自带JDK，也可挂载本地JDK 8"></a>配置JDK 容器里自带JDK，也可挂载本地JDK 8</h3><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260101281.6s72vdeqgb40.jpg"                      alt="202303260101281"                ></p><h3 id="配置Maven本地安装路径"><a href="#配置Maven本地安装路径" class="headerlink" title="配置Maven本地安装路径"></a>配置Maven本地安装路径</h3><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260101138.5hjkup5xcfk0.jpg"                      alt="202303260101138"                ></p><h3 id="最后测试一下构建项目"><a href="#最后测试一下构建项目" class="headerlink" title="最后测试一下构建项目"></a>最后测试一下构建项目</h3><p><img                       lazyload                     alt="image"                     data-src="https://cdn.staticaly.com/gh/5ober/chart-bed@main/20230326/202303260101792.yqeskaz3fzk.jpg"                      alt="202303260101792"                ></p><h3 id="2-war包安装方式"><a href="#2-war包安装方式" class="headerlink" title="2.war包安装方式"></a>2.war包安装方式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载jenkins.war包 安装目录 Java-jar启动</span></span><br><span class="line"></span><br><span class="line">java -jar jenkins.war --httpPort=8081</span><br></pre></td></tr></table></figure><h3 id="3-安装版jenkins看链接"><a href="#3-安装版jenkins看链接" class="headerlink" title="3.安装版jenkins看链接"></a>3.安装版jenkins看链接</h3><p><a class="link"   href="https://developer.aliyun.com/article/885497" >安装版Jenkins教程<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装Jenkins-的方式&quot;&gt;&lt;a href=&quot;#安装Jenkins-的方式&quot; class=&quot;headerlink&quot; title=&quot;安装Jenkins 的方式&quot;&gt;&lt;/a&gt;安装Jenkins 的方式&lt;/h1&gt;&lt;p&gt;Jenkins 是一个可扩展的持续集成（CI）平台。</summary>
      
    
    
    
    <category term="Jenkins 自动化部署" scheme="http://example.com/categories/Jenkins-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="Jenkins部署" scheme="http://example.com/tags/Jenkins%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>宝塔安装的redis开启远程连接</title>
    <link href="http://example.com/2023/03/19/%E5%AE%9D%E5%A1%94%E5%AE%89%E8%A3%85%E7%9A%84redis%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    <id>http://example.com/2023/03/19/%E5%AE%9D%E5%A1%94%E5%AE%89%E8%A3%85%E7%9A%84redis%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</id>
    <published>2023-03-19T08:39:43.081Z</published>
    <updated>2023-03-19T07:58:20.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="宝塔安装的Redis开启远程连接"><a href="#宝塔安装的Redis开启远程连接" class="headerlink" title="宝塔安装的Redis开启远程连接"></a>宝塔安装的Redis开启远程连接</h3><p>第一步，打开配置文件&#x2F;www&#x2F;server&#x2F;redis&#x2F;redis.conf</p><p>搜索bind，修改自己的IP地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.1.16</span><br></pre></td></tr></table></figure><p>搜索protected-mode，将保护模式yes改成no</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br></pre></td></tr></table></figure><p>将 requirepass foobared 的 foobared 改为自己需要设置的Redis密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass sober</span><br></pre></td></tr></table></figure><p>最后重启配置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;宝塔安装的Redis开启远程连接&quot;&gt;&lt;a href=&quot;#宝塔安装的Redis开启远程连接&quot; class=&quot;headerlink&quot; title=&quot;宝塔安装的Redis开启远程连接&quot;&gt;&lt;/a&gt;宝塔安装的Redis开启远程连接&lt;/h3&gt;&lt;p&gt;第一步，打开配置文件&amp;#x2</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="Redis开启远程连接" scheme="http://example.com/tags/Redis%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>GitLab 部署及管理员账号初始化</title>
    <link href="http://example.com/2023/03/18/GitLab%20%E9%83%A8%E7%BD%B2%E5%BF%98%E8%AE%B0root%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9/"/>
    <id>http://example.com/2023/03/18/GitLab%20%E9%83%A8%E7%BD%B2%E5%BF%98%E8%AE%B0root%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9/</id>
    <published>2023-03-18T08:27:30.194Z</published>
    <updated>2023-03-18T08:27:22.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitLab-部署及管理员账号初始化"><a href="#GitLab-部署及管理员账号初始化" class="headerlink" title="GitLab 部署及管理员账号初始化"></a>GitLab 部署及管理员账号初始化</h2><h4 id="1-首先登录gitlab服务器执行以下命令："><a href="#1-首先登录gitlab服务器执行以下命令：" class="headerlink" title="1.首先登录gitlab服务器执行以下命令："></a>1.<strong>首先登录gitlab服务器执行以下命令：</strong></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到gitlab安装目录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /opt/gitlab/bin</span><br><span class="line"></span><br><span class="line">sudo  gitlab-rails console -e production</span><br></pre></td></tr></table></figure><h4 id="2-通过命令查找，确定用户为“root”"><a href="#2-通过命令查找，确定用户为“root”" class="headerlink" title="2.通过命令查找，确定用户为“root”"></a>2.通过命令查找，确定用户为“root”</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下这两个命令都可以，随便输入一个</span></span><br><span class="line"></span><br><span class="line">user = User.<span class="built_in">where</span>(<span class="built_in">id</span>: 1).first </span><br><span class="line"></span><br><span class="line">user = User.<span class="built_in">where</span>(name: <span class="string">&quot;root&quot;</span>).first</span><br></pre></td></tr></table></figure><h4 id="3-将root用户密码重置为admin123"><a href="#3-将root用户密码重置为admin123" class="headerlink" title="3.将root用户密码重置为admin123!"></a>3.将root用户密码重置为admin123!</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入重置密码命令</span></span><br><span class="line"></span><br><span class="line">user.password=<span class="string">&quot;admin123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次确认密码</span></span><br><span class="line"></span><br><span class="line">user.password_confirmation=<span class="string">&quot;admin123&quot;</span></span><br></pre></td></tr></table></figure><h4 id="4-保存重置信息，并结束"><a href="#4-保存重置信息，并结束" class="headerlink" title="4.保存重置信息，并结束"></a>4.保存重置信息，并结束</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入保存命令，以便使更改信息生效</span></span><br><span class="line"></span><br><span class="line">user.save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出修改窗口</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>如果看到上面截图中的true ，恭喜你已经成功了，执行 exit 或quit退出当前设置流程即可。</p><p>回到gitlab ,可以通过 root&#x2F;admin123 这一超级管理员账号登录了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GitLab-部署及管理员账号初始化&quot;&gt;&lt;a href=&quot;#GitLab-部署及管理员账号初始化&quot; class=&quot;headerlink&quot; title=&quot;GitLab 部署及管理员账号初始化&quot;&gt;&lt;/a&gt;GitLab 部署及管理员账号初始化&lt;/h2&gt;&lt;h4 id=&quot;1</summary>
      
    
    
    
    <category term="GitLab" scheme="http://example.com/categories/GitLab/"/>
    
    
    <category term="GitLab 部署" scheme="http://example.com/tags/GitLab-%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Linux 配置静态IP</title>
    <link href="http://example.com/2023/03/16/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/"/>
    <id>http://example.com/2023/03/16/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/</id>
    <published>2023-03-16T12:15:28.222Z</published>
    <updated>2023-03-25T12:02:29.158Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-配置静态IP"><a href="#Linux-配置静态IP" class="headerlink" title="Linux 配置静态IP"></a>Linux 配置静态IP</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CentOS 7 为例</span><br><span class="line">    </span><br><span class="line">修改网卡配置文件</span><br><span class="line"></span><br><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"><span class="comment"># 配置的IP地址</span></span><br><span class="line">IPADDR=192.168.1.30</span><br><span class="line"><span class="comment"># 配置子网掩码</span></span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line"><span class="comment"># 配置网关</span></span><br><span class="line">GATEWAY=192.168.1.2</span><br><span class="line"><span class="comment"># 配置DNS服务器</span></span><br><span class="line"><span class="comment"># 114 DNS</span></span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line"><span class="comment"># 阿里DNS</span></span><br><span class="line">DNS2=233.5.5.5</span><br><span class="line"><span class="comment"># 谷歌DNS</span></span><br><span class="line">DNS3=8.8.8.8</span><br><span class="line"></span><br><span class="line">重启网卡</span><br><span class="line"></span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure><h3 id="Rocky-9-0-NetworkManager-配置文件位置（ens160网卡名称）"><a href="#Rocky-9-0-NetworkManager-配置文件位置（ens160网卡名称）" class="headerlink" title="Rocky 9.0 NetworkManager 配置文件位置（ens160网卡名称）"></a>Rocky 9.0 NetworkManager 配置文件位置（ens160网卡名称）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">修改网卡配置文件</span><br><span class="line"></span><br><span class="line">vim /etc/NetworkManager/system-connections/ens160.nmconnection</span><br><span class="line"></span><br><span class="line">[ipv4]</span><br><span class="line"></span><br><span class="line"> //添加ip/子网掩码,网关</span><br><span class="line"></span><br><span class="line">address1=192.168.1.30/24,192.168.1.254 </span><br><span class="line"></span><br><span class="line">//添加dns地址（多个用;隔开）</span><br><span class="line"></span><br><span class="line">dns=8.8.8.8;114.114.114.114;                </span><br><span class="line"></span><br><span class="line">may-fail=false</span><br><span class="line"></span><br><span class="line">method=manual</span><br></pre></td></tr></table></figure><h4 id="重新加载配置文件"><a href="#重新加载配置文件" class="headerlink" title="重新加载配置文件"></a>重新加载配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection load /etc/NetworkManager/system-connections/ens160.nmconnectioni</span><br></pre></td></tr></table></figure><h4 id="激活配置文件"><a href="#激活配置文件" class="headerlink" title="激活配置文件"></a>激活配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up /etc/NetworkManager/system-connections/ens160.nmconnection</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Linux-配置静态IP&quot;&gt;&lt;a href=&quot;#Linux-配置静态IP&quot; class=&quot;headerlink&quot; title=&quot;Linux 配置静态IP&quot;&gt;&lt;/a&gt;Linux 配置静态IP&lt;/h3&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="Linux 静态IP" scheme="http://example.com/categories/Linux-%E9%9D%99%E6%80%81IP/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>宝塔面板</title>
    <link href="http://example.com/2023/03/16/%E5%AE%9D%E5%A1%94Linux%E9%9D%A2%E6%9D%BF/"/>
    <id>http://example.com/2023/03/16/%E5%AE%9D%E5%A1%94Linux%E9%9D%A2%E6%9D%BF/</id>
    <published>2023-03-16T11:37:16.251Z</published>
    <updated>2023-03-18T08:26:00.298Z</updated>
    
    <content type="html"><![CDATA[<h3 id="宝塔面板"><a href="#宝塔面板" class="headerlink" title="宝塔面板"></a>宝塔面板</h3><p><strong>Centos安装脚本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec</span><br></pre></td></tr></table></figure><h3 id="一键卸载宝塔Linux面板及运行环境命令"><a href="#一键卸载宝塔Linux面板及运行环境命令" class="headerlink" title="一键卸载宝塔Linux面板及运行环境命令"></a>一键卸载宝塔Linux面板及运行环境命令</h3><p>注：卸载环境可能会影响服务器数据 请谨慎操作！</p><p> 1.进入ssh 输入以下命令下载脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.bt.cn/install/bt-uninstall.sh</span><br></pre></td></tr></table></figure><p>2.执行脚本 （若是ubutnu用户请在前面加sudo 例子sudo sh bt-uninstall.sh）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bt-uninstall.sh</span><br></pre></td></tr></table></figure><p>外网面板地址: <a class="link"   href="https://101.86.227.152:36726/29b6342f" >https://101.86.227.152:36726/29b6342f<i class="fas fa-external-link-alt"></i></a><br>内网面板地址: <a class="link"   href="https://192.168.1.10:36726/29b6342f" >https://192.168.1.10:36726/29b6342f<i class="fas fa-external-link-alt"></i></a> 已改为sober<br>username: gduslnen 已改为sober<br>password: c813af86  已改为sober123<br>If you cannot access the panel,<br>release the following panel port [36726] in the security group<br>若无法访问面板，请检查防火墙&#x2F;安全组是否有放行面板[36726]端口<br>因已开启面板自签证书，访问面板会提示不匹配证书，请参考以下链接配置证书<br><a class="link"   href="https://www.bt.cn/bbs/thread-105443-1-1.html" >https://www.bt.cn/bbs/thread-105443-1-1.html<i class="fas fa-external-link-alt"></i></a></p><p><strong>防火墙命令</strong></p><p>1）查看防火墙的版本。<br>firewall-cmd –version<br>2）查看firewall的状态。<br>firewall-cmd –state<br>3）查看firewall服务状态（普通用户可执行）。<br>systemctl status firewalld<br>4）查看防火墙全部的信息。<br>firewall-cmd –list-all<br>5）查看防火墙已开通的端口。<br>firewall-cmd –list-port<br>6）查看防火墙已开通的服务。<br>firewall-cmd –list-service<br>7）查看全部的服务列表（普通用户可执行）。<br>firewall-cmd –get-services<br>8）查看防火墙服务是否开机启动。<br>systemctl is-enabled firewalld<br>2、配置防火墙的命令<br> 1）启动、重启、关闭防火墙服务。</p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>systemctl start firewalld</p><h4 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h4><p>systemctl restart firewalld</p><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>systemctl stop firewalld<br>2）开放、移去某个端口。</p><h4 id="开放80端口"><a href="#开放80端口" class="headerlink" title="开放80端口"></a>开放80端口</h4><p>firewall-cmd –zone&#x3D;public –add-port&#x3D;80&#x2F;tcp –permanent</p><h4 id="移去80端口"><a href="#移去80端口" class="headerlink" title="移去80端口"></a>移去80端口</h4><p>firewall-cmd –zone&#x3D;public –remove-port&#x3D;80&#x2F;tcp –permanent<br>3）开放、移去范围端口。</p><h4 id="开放5000-5500之间的端口"><a href="#开放5000-5500之间的端口" class="headerlink" title="开放5000-5500之间的端口"></a>开放5000-5500之间的端口</h4><p>firewall-cmd –zone&#x3D;public –add-port&#x3D;5000-5500&#x2F;tcp –permanent</p><h4 id="移去5000-5500之间的端口"><a href="#移去5000-5500之间的端口" class="headerlink" title="移去5000-5500之间的端口"></a>移去5000-5500之间的端口</h4><p>firewall-cmd –zone&#x3D;public –remove-port&#x3D;5000-5500&#x2F;tcp –permanent<br>4）开放、移去服务。</p><h4 id="开放ftp服务"><a href="#开放ftp服务" class="headerlink" title="开放ftp服务"></a>开放ftp服务</h4><p>firewall-cmd –zone&#x3D;public –add-service&#x3D;ftp –permanent</p><h4 id="移去http服务"><a href="#移去http服务" class="headerlink" title="移去http服务"></a>移去http服务</h4><p>firewall-cmd –zone&#x3D;public –remove-service&#x3D;ftp –permanent<br>5）重新加载防火墙配置（修改配置后要重新加载防火墙配置或重启防火墙服务）。<br>firewall-cmd –reload<br>6）设置开机时启用、禁用防火墙服务。</p><h4 id="启用服务"><a href="#启用服务" class="headerlink" title="启用服务"></a>启用服务</h4><p>systemctl enable firewalld</p><h4 id="禁用服务"><a href="#禁用服务" class="headerlink" title="禁用服务"></a>禁用服务</h4><p>systemctl disable firewalld</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;宝塔面板&quot;&gt;&lt;a href=&quot;#宝塔面板&quot; class=&quot;headerlink&quot; title=&quot;宝塔面板&quot;&gt;&lt;/a&gt;宝塔面板&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Centos安装脚本&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight shell</summary>
      
    
    
    
    <category term="宝塔面板" scheme="http://example.com/categories/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"/>
    
    
    <category term="宝塔Linux面板" scheme="http://example.com/tags/%E5%AE%9D%E5%A1%94Linux%E9%9D%A2%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>MySQL远程连接授权</title>
    <link href="http://example.com/2023/03/16/MySQL%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%8E%88%E6%9D%83/"/>
    <id>http://example.com/2023/03/16/MySQL%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%8E%88%E6%9D%83/</id>
    <published>2023-03-16T10:52:18.516Z</published>
    <updated>2023-03-19T08:39:11.680Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL中grant-all-privileges-on赋给用户远程权限"><a href="#MySQL中grant-all-privileges-on赋给用户远程权限" class="headerlink" title="MySQL中grant all privileges on赋给用户远程权限"></a>MySQL中grant all privileges on赋给用户远程权限</h3><p>当你的帐号不允许从远程登陆，只能在<code>localhost</code>连接时。这个时候只要在mysql服务器上，更改 <code>mysql</code> 数据库里的 <code>user</code> 表里的 <code>host</code> 项，从<code>localhost&quot;</code>改成<code>%</code>即可实现用户远程登录</p><h4 id="1-授权法"><a href="#1-授权法" class="headerlink" title="1.授权法"></a>1.授权法</h4><p>MySQL 5.0+版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给root账户授权（root默认只有本机访问的权限，要通过其他机器访问，必须授权）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> root@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最后刷新数据库服务</span></span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>模板： grant all privileges on 库名.表名 to ‘用户名‘@’IP地址’ identified by ‘密码’ with grant option; </p><p>flush privileges;</p><p>注意授权后必须FLUSH PRIVILEGES;否则无法立即生效。</p><p>高版本8.0数据库不能按照<code>grant all privileges on *.* to &quot;root&quot;@&quot;%&quot; identified by &quot;xxxx&quot;;</code>去修改用户权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@VERSION</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@VERSION</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">8.0</span><span class="number">.14</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>MySQL 8.0+版本</p><p>查看用户账号信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">User</span>, host <span class="keyword">from</span> mysql.user;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">User</span>             <span class="operator">|</span> host      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> mysql.infoschema <span class="operator">|</span> localhost <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql.session    <span class="operator">|</span> localhost <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql.sys        <span class="operator">|</span> localhost <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> root             <span class="operator">|</span> localhost <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>先创建远程用户，再授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span>  <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次查看发现有了root %</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">User</span>, host <span class="keyword">from</span> mysql.user;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">User</span>             <span class="operator">|</span> Host      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> root             <span class="operator">|</span> <span class="operator">%</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql.infoschema <span class="operator">|</span> localhost <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql.session    <span class="operator">|</span> localhost <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql.sys        <span class="operator">|</span> localhost <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> root             <span class="operator">|</span> localhost <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MySQL中grant-all-privileges-on赋给用户远程权限&quot;&gt;&lt;a href=&quot;#MySQL中grant-all-privileges-on赋给用户远程权限&quot; class=&quot;headerlink&quot; title=&quot;MySQL中grant all pr</summary>
      
    
    
    
    <category term="MySQL连接" scheme="http://example.com/categories/MySQL%E8%BF%9E%E6%8E%A5/"/>
    
    
    <category term="MySQL远程连接授权" scheme="http://example.com/tags/MySQL%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%8E%88%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>IDEA的日常快捷键及Linux命令</title>
    <link href="http://example.com/2023/03/13/IDEA%20%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8ALInux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2023/03/13/IDEA%20%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8ALInux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2023-03-12T19:06:19.760Z</published>
    <updated>2023-03-16T11:43:15.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IntelliJ-IDEA-常用快捷键一览表"><a href="#IntelliJ-IDEA-常用快捷键一览表" class="headerlink" title="IntelliJ IDEA 常用快捷键一览表"></a>IntelliJ IDEA 常用快捷键一览表</h1><hr><h2 id="1-IDEA的日常快捷键"><a href="#1-IDEA的日常快捷键" class="headerlink" title="1-IDEA的日常快捷键"></a>1-IDEA的日常快捷键</h2><h3 id="第1组：通用型"><a href="#第1组：通用型" class="headerlink" title="第1组：通用型"></a>第1组：通用型</h3><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>复制代码-copy</td><td>ctrl + c</td></tr><tr><td>粘贴-paste</td><td>ctrl + v</td></tr><tr><td>剪切-cut</td><td>ctrl + x</td></tr><tr><td>撤销-undo</td><td>ctrl + z</td></tr><tr><td>反撤销-redo</td><td>ctrl + shift + z</td></tr><tr><td>保存-save all</td><td>ctrl + s</td></tr><tr><td>全选-select all</td><td>ctrl + a</td></tr></tbody></table><h3 id="第2组：提高编写速度（上）"><a href="#第2组：提高编写速度（上）" class="headerlink" title="第2组：提高编写速度（上）"></a>第2组：提高编写速度（上）</h3><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>智能提示-edit</td><td>alt + enter</td></tr><tr><td>提示代码模板-insert live template</td><td>ctrl+j</td></tr><tr><td>使用xx块环绕-surround with …</td><td>ctrl+alt+t</td></tr><tr><td>调出生成getter&#x2F;setter&#x2F;构造器等结构-generate …</td><td>alt+insert</td></tr><tr><td>自动生成返回值变量-introduce variable …</td><td>ctrl+alt+v</td></tr><tr><td>复制指定行的代码-duplicate line or selection</td><td>ctrl+d</td></tr><tr><td>删除指定行的代码-delete line</td><td>ctrl+y</td></tr><tr><td>切换到下一行代码空位-start new line</td><td>shift + enter</td></tr><tr><td>切换到上一行代码空位-start new line before current</td><td>ctrl +alt+ enter</td></tr><tr><td>向上移动代码-move statement up</td><td>ctrl+shift+↑</td></tr><tr><td>向下移动代码-move statement down</td><td>ctrl+shift+↓</td></tr><tr><td>向上移动一行-move line up</td><td>alt+shift+↑</td></tr><tr><td>向下移动一行-move line down</td><td>alt+shift+↓</td></tr><tr><td>方法的形参列表提醒-parameter info</td><td>ctrl+p</td></tr></tbody></table><h3 id="第3组：提高编写速度（下）"><a href="#第3组：提高编写速度（下）" class="headerlink" title="第3组：提高编写速度（下）"></a>第3组：提高编写速度（下）</h3><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>批量修改指定的变量名、方法名、类名等-rename</td><td>shift+f6</td></tr><tr><td>抽取代码重构方法-extract method …</td><td>ctrl+alt+m</td></tr><tr><td>重写父类的方法-override methods …</td><td>ctrl+o</td></tr><tr><td>实现接口的方法-implements methods …</td><td>ctrl+i</td></tr><tr><td>选中的结构的大小写的切换-toggle case</td><td>ctrl+shift+u</td></tr><tr><td>批量导包-optimize imports</td><td>ctrl+alt+o</td></tr></tbody></table><h3 id="第4组：类结构、查找和查看源码"><a href="#第4组：类结构、查找和查看源码" class="headerlink" title="第4组：类结构、查找和查看源码"></a>第4组：类结构、查找和查看源码</h3><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>如何查看源码-go to class…</td><td>ctrl + 选中指定的结构 或 ctrl+n</td></tr><tr><td>显示当前类结构，支持搜索指定的方法、属性等-file structure</td><td>ctrl+f12</td></tr><tr><td>退回到前一个编辑的页面-back</td><td>ctrl+alt+←</td></tr><tr><td>进入到下一个编辑的页面-forward</td><td>ctrl+alt+→</td></tr><tr><td>打开的类文件之间切换-select previous&#x2F;next tab</td><td>alt+←&#x2F;→</td></tr><tr><td>光标选中指定的类，查看继承树结构-Type Hierarchy</td><td>ctrl+h</td></tr><tr><td>查看方法文档-quick documentation</td><td>ctrl+q</td></tr><tr><td>类的UML关系图-show uml popup</td><td>ctrl+alt+u</td></tr><tr><td>定位某行-go to line&#x2F;column</td><td>ctrl+g</td></tr><tr><td>回溯变量或方法的来源-go to implementation(s)</td><td>ctrl+alt+b</td></tr><tr><td>折叠方法实现-collapse all</td><td>ctrl+shift+ -</td></tr><tr><td>展开方法实现-expand all</td><td>ctrl+shift+ +</td></tr></tbody></table><h3 id="第5组：查找、替换与关闭"><a href="#第5组：查找、替换与关闭" class="headerlink" title="第5组：查找、替换与关闭"></a>第5组：查找、替换与关闭</h3><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>查找指定的结构</td><td>ctlr+f</td></tr><tr><td>快速查找：选中的Word快速定位到下一个-find next</td><td>ctrl+l</td></tr><tr><td>查找与替换-replace</td><td>ctrl+r</td></tr><tr><td>直接定位到当前行的首位-move caret to line start</td><td>home</td></tr><tr><td>直接定位到当前行的末位 -move caret to line end</td><td>end</td></tr><tr><td>查询当前元素在当前文件中的引用，然后按 F3 可以选择</td><td>ctrl+f7</td></tr><tr><td>全项目搜索文本-find in path …</td><td>ctrl+shift+f</td></tr><tr><td>关闭当前窗口-close</td><td>ctrl+f4</td></tr></tbody></table><h3 id="第6组：调整格式"><a href="#第6组：调整格式" class="headerlink" title="第6组：调整格式"></a>第6组：调整格式</h3><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>格式化代码-reformat code</td><td>ctrl+alt+l</td></tr><tr><td>使用单行注释-comment with line comment</td><td>ctrl + &#x2F;</td></tr><tr><td>使用&#x2F;取消多行注释-comment with block comment</td><td>ctrl + shift + &#x2F;</td></tr><tr><td>选中数行，整体往后移动-tab</td><td>tab</td></tr><tr><td>选中数行，整体往前移动-prev tab</td><td>shift + tab</td></tr></tbody></table><h2 id="2-Debug快捷键"><a href="#2-Debug快捷键" class="headerlink" title="2-Debug快捷键"></a>2-Debug快捷键</h2><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>单步调试（不进入函数内部）- step over</td><td>F8</td></tr><tr><td>单步调试（进入函数内部）- step into</td><td>F7</td></tr><tr><td>强制单步调试（进入函数内部） - force step into</td><td>alt+shift+f7</td></tr><tr><td>选择要进入的函数 - smart step into</td><td>shift + F7</td></tr><tr><td>跳出函数 - step out</td><td>shift + F8</td></tr><tr><td>运行到断点 - run to cursor</td><td>alt + F9</td></tr><tr><td>继续执行，进入下一个断点或执行完程序 - resume program</td><td>F9</td></tr><tr><td>停止 - stop</td><td>Ctrl+F2</td></tr><tr><td>查看断点 - view breakpoints</td><td>Ctrl+Shift+F8</td></tr><tr><td>关闭 - close</td><td>Ctrl+F4</td></tr></tbody></table><h3 id="3-常用代码模板"><a href="#3-常用代码模板" class="headerlink" title="3- 常用代码模板"></a>3- 常用代码模板</h3><h4 id="1、非空判断"><a href="#1、非空判断" class="headerlink" title="1、非空判断"></a>1、非空判断</h4><ul><li>变量.null：if(变量 &#x3D;&#x3D; null)</li><li>变量.nn：if(变量 !&#x3D; null) </li><li>变量.notnull：if(变量 !&#x3D; null) </li><li>ifn：if(xx  &#x3D;&#x3D; null)</li><li>inn：if(xx  !&#x3D; null)</li></ul><h4 id="2、遍历数组和集合"><a href="#2、遍历数组和集合" class="headerlink" title="2、遍历数组和集合"></a>2、遍历数组和集合</h4><ul><li>数组或集合变量.fori：for循环</li><li>数组或集合变量.for：增强for循环</li><li>数组或集合变量.forr：反向for循环</li><li>数组或集合变量.iter：增强for循环遍历数组或集合</li></ul><h4 id="3、输出语句"><a href="#3、输出语句" class="headerlink" title="3、输出语句"></a>3、输出语句</h4><ul><li>sout：相当于System.out.println</li><li>soutm：打印当前方法的名称</li><li>soutp：打印当前方法的形参及形参对应的实参值</li><li>soutv：打印方法中声明的最近的变量的值</li><li>变量.sout：打印当前变量值</li><li>变量.soutv：打印当前变量名及变量值</li></ul><h4 id="4、对象操作"><a href="#4、对象操作" class="headerlink" title="4、对象操作"></a>4、对象操作</h4><ul><li>创建对象<ul><li>Xxx.new  .var ：创建Xxx类的对象，并赋给相应的变量</li><li>Xxx.new  .field：会将方法内刚创建的Xxx对象抽取为一个属性</li></ul></li><li>强转<ul><li>对象.cast：将对象进行强转</li><li>对象.castvar：将对象强转后，并赋给一个变量</li></ul></li></ul><h4 id="5、静态常量声明"><a href="#5、静态常量声明" class="headerlink" title="5、静态常量声明"></a>5、静态常量声明</h4><ul><li>psf：public static final</li><li>psfi：public static final int</li><li>psfs：public static final String</li><li>prsf：private static final</li></ul><p><a class="link"   href="https://blog.csdn.net/weixin_44895651/article/details/105289038" >Linux常用命令<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.linuxcool.com/" >Linux命令大全(手册)<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IntelliJ-IDEA-常用快捷键一览表&quot;&gt;&lt;a href=&quot;#IntelliJ-IDEA-常用快捷键一览表&quot; class=&quot;headerlink&quot; title=&quot;IntelliJ IDEA 常用快捷键一览表&quot;&gt;&lt;/a&gt;IntelliJ IDEA 常用快捷键一</summary>
      
    
    
    
    <category term="IDEA 快捷键" scheme="http://example.com/categories/IDEA-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
    
    <category term="IDEA Linux" scheme="http://example.com/tags/IDEA-Linux/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/21/3.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2023/02/21/3.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2023-02-20T16:57:05.502Z</published>
    <updated>2023-02-20T16:29:32.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3. 数组中重复的数字"></a>3. 数组中重复的数字</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a class="link"   href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" >牛客网<i class="fas fa-external-link-alt"></i></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;2, 3, 1, 0, 2, 5&#125;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。</p><p>对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。本题要求找出重复的数字，因此在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。</p><p>以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：</p><div align="center"> <img                       lazyload                     alt="image"                     data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/643b6f18-f933-4ac5-aa7a-e304dbd7fe49.gif"                      width="350px"                > </div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">duplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> length, <span class="type">int</span>[] duplication)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><img  width="320px"                      lazyload                     alt="image"                     data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"                                     ></img></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-数组中重复的数字&quot;&gt;&lt;a href=&quot;#3-数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;3. 数组中重复的数字&quot;&gt;&lt;/a&gt;3. 数组中重复的数字&lt;/h1&gt;&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/21/4.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://example.com/2023/02/21/4.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
    <published>2023-02-20T16:57:05.499Z</published>
    <updated>2023-02-20T16:29:32.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4. 二维数组中的查找"></a>4. 二维数组中的查找</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a class="link"   href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" >牛客网<i class="fas fa-external-link-alt"></i></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。</p><p>该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p><div align="center"> <img                       lazyload                     alt="image"                     data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/35a8c711-0dc0-4613-95f3-be96c6c6e104.gif"                      width="400px"                > </div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, c = cols - <span class="number">1</span>; <span class="comment">// 从右上角开始</span></span><br><span class="line">    <span class="keyword">while</span> (r &lt;= rows - <span class="number">1</span> &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == matrix[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[r][c])</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><img  width="320px"                      lazyload                     alt="image"                     data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"                                     ></img></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4-二维数组中的查找&quot;&gt;&lt;a href=&quot;#4-二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;4. 二维数组中的查找&quot;&gt;&lt;/a&gt;4. 二维数组中的查找&lt;/h1&gt;&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java 并发 - 知识专题</title>
    <link href="http://example.com/2023/02/20/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/"/>
    <id>http://example.com/2023/02/20/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/</id>
    <published>2023-02-19T16:00:00.000Z</published>
    <updated>2023-03-25T17:06:31.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java并发知识专题"><a href="#java并发知识专题" class="headerlink" title="java并发知识专题"></a>java并发知识专题</h1><hr><p>努力的意义，就是，在以后的日子里，放眼望去全是自己喜欢的人和事！</p><p>整个系列文章为<strong>Java并发专题</strong>，一是自己的兴趣，二是，这部分在实际理解上很有难度，另外在面试过程中也是经常被问到。所以在学习过程中，记录了Java并发相关的基础知识，一是自己对知识能够建立体系，同时也希望有幸能够对其他人有用。</p><p>关于Java并发专题：</p><p>（1）包含了并发的基础知识，每个标题链接到一篇具体的文章；</p><p>（2）包含了秋招面试的问题，弄懂了会让你有所收获（也祝大家都能找到心仪的工作 😃 ）</p><p>（3）在阅读过程中，如果有所帮助，麻烦点赞，算是对我码字的这份坚持的鼓励。</p><ol><li><p><strong>基础知识</strong></p><p>1.1 <a class="link"   href="https://juejin.im/post/5ae6c3ef6fb9a07ab508ac85" >并发编程的优缺点<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）为什么要用到并发？（优点）；（2）并发编程的缺点；（3）易混淆的概念</p><p>1.2 <a class="link"   href="https://juejin.im/post/5ae6cf7a518825670960fcc2" >线程的状态和基本操作<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）如何新建线程；（2）线程状态的转换；（3）线程的基本操作；（4）守护线程Daemon；</p></li><li><p><strong>并发理论（JMM）</strong></p><p><a class="link"   href="https://juejin.im/post/5ae6d309518825673123fd0e" >java内存模型以及happens-before规则<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）JMM内存结构；（2）重排序；（3）happens-before规则</p></li><li><p><strong>并发关键字</strong></p><p>3.1 <a class="link"   href="https://juejin.im/post/5ae6dc04f265da0ba351d3ff" >让你彻底理解Synchronized<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）如何使用synchronized；（2）monitor机制；（3）synchronized的happens-before关系；（4）synchronized的内存语义；（5）锁优化；（6）锁升级策略</p><p>3.2 <a class="link"   href="https://juejin.im/post/5ae9b41b518825670b33e6c4" >让你彻底理解volatile<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）实现原理；（2）happens-before的关系推导；（3）内存语义；（4）内存语义的实现</p><p>3.3 <a class="link"   href="https://juejin.im/post/5ae9b82c6fb9a07ac3634941" >你以为你真的了解final吗？<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）如何使用；（2）final的重排序规则；（3）final实现原理；（4）final引用不能从构造函数中“溢出”（this逃逸）</p><p>3.4 <a class="link"   href="https://juejin.im/post/5aeb022cf265da0b722af7b8" >三大性质总结：原子性，有序性，可见性<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）原子性：synchronized；（2）可见性：synchronized，volatile；（3）有序性：synchronized，volatile</p></li><li><p><strong>Lock体系</strong></p><p>4.1 <a class="link"   href="https://juejin.im/post/5aeb055b6fb9a07abf725c8c" >初识Lock与AbstractQueuedSynchronizer(AQS)<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）Lock和synchronized的比较；（2）AQS设计意图；（3）如何使用AQS实现自定义同步组件；（4）可重写的方法；（5）AQS提供的模板方法；</p><p>4.2 <a class="link"   href="https://juejin.im/post/5aeb07ab6fb9a07ac36350c8" >深入理解AbstractQueuedSynchronizer(AQS)<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）AQS同步队列的数据结构；（2）独占式锁；（3）共享式锁；</p><p>4.3 <a class="link"   href="https://juejin.im/post/5aeb0a8b518825673a2066f0" >再一次理解ReentrantLock<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）重入锁的实现原理；（2）公平锁的实现原理；（3）非公平锁的实现原理；（4）公平锁和非公平锁的比较</p><p>4.4 <a class="link"   href="https://juejin.im/post/5aeb0e016fb9a07ab7740d90" >深入理解读写锁ReentrantReadWriteLock<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）如何表示读写状态；（2）WriteLock的获取和释放；（3）ReadLock的获取和释放；（4）锁降级策略；（5）生成Condition等待队列；（6）应用场景</p><p>4.5 <a class="link"   href="https://juejin.im/post/5aeea5e951882506a36c67f0" >详解Condition的await和signal等待&#x2F;通知机制<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）与Object的wait&#x2F;notify机制相比具有的特性；（2）与Object的wait&#x2F;notify相对应的方法；（3）底层数据结构；（4）await实现原理；（5）signal&#x2F;signalAll实现原理；（6）await和signal&#x2F;signalAll的结合使用；</p><p>4.6 <a class="link"   href="https://juejin.im/post/5aeed27f51882567336aa0fa" >LockSupport工具<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）主要功能；（2）与synchronized阻塞唤醒相比具有的特色；</p></li><li><p><strong>并发容器</strong></p><p>5.1 <a class="link"   href="https://juejin.im/post/5aeeaba8f265da0b9d781d16" >并发容器之ConcurrentHashMap(JDK 1.8版本)<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）关键属性；（2）重要内部类；（3）涉及到的CAS操作；（4）构造方法；（5）put执行流程；（6）get执行流程；（7）扩容机制；（8）用于统计size的方法的执行流程；（9）1.8版本的ConcurrentHashMap与之前版本的比较</p><p>5.2 <a class="link"   href="https://juejin.im/post/5aeeb55f5188256715478c21" >并发容器之CopyOnWriteArrayList<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）实现原理；（2）COW和ReentrantReadWriteLock的区别；（3）应用场景；（4）为什么具有弱一致性；（5）COW的缺点；</p><p>5.3 <a class="link"   href="https://juejin.im/post/5aeeae756fb9a07ab11112af" >并发容器之ConcurrentLinkedQueue<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）实现原理；（2）数据结构；（3）核心方法；（4）HOPS延迟更新的设计意图</p><p>5.4 <a class="link"   href="https://juejin.im/post/5aeeb22e6fb9a07aa213404a" >并发容器之ThreadLocal<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）实现原理；（2）set方法原理；（3）get方法原理；（4）remove方法原理；（5）ThreadLocalMap</p><p><a class="link"   href="https://www.jianshu.com/p/dde92ec37bd1" >一篇文章，从源码深入详解ThreadLocal内存泄漏问题<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）ThreadLocal内存泄漏原理；（2）ThreadLocal的最佳实践；（3）应用场景</p><p>5.5 <a class="link"   href="https://juejin.im/post/5aeebd02518825672f19c546" >并发容器之BlockingQueue<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）BlockingQueue的基本操作；（2）常用的BlockingQueue；</p><p><a class="link"   href="https://juejin.im/post/5aeebdb26fb9a07aa83ea17e" >并发容器之ArrayBlockingQueue和LinkedBlockingQueue实现原理详解<i class="fas fa-external-link-alt"></i></a></p></li><li><p><strong>线程池（Executor体系）</strong></p><p>6.1 <a class="link"   href="https://juejin.im/post/5aeec0106fb9a07ab379574f" >线程池实现原理<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）为什么要用到线程池？（2）执行流程；（3）构造器各个参数的意义；（4）如何关闭线程池；（5）如何配置线程池；</p><p>6.2 <a class="link"   href="https://juejin.im/post/5aeec106518825670a10328a" >线程池之ScheduledThreadPoolExecutor<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）类结构；（2）常用方法；（3）ScheduledFutureTask；（3）DelayedWorkQueue;</p><p>6.3 <a class="link"   href="https://juejin.im/post/5aeec249f265da0b886d5101" >FutureTask基本操作总结<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）FutureTask的几种状态；（2）get方法；（3）cancel方法；（4）应用场景；（5）实现 Runnable接口</p></li><li><p><strong>原子操作类</strong></p><p>7.1 <a class="link"   href="https://juejin.im/post/5aeec351518825670a103292" >Java中atomic包中的原子操作类总结<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）实现原理；（2）原子更新基本类型；（3）原子更新数组类型；（4）原子更新引用类型；（5）原子更新字段类型</p></li><li><p><strong>并发工具</strong></p><p>8.1 <a class="link"   href="https://juejin.im/post/5aeec3ebf265da0ba76fa327" >大白话说java并发工具类-CountDownLatch，CyclicBarrier<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）倒计时器CountDownLatch；（2）循环栅栏CyclicBarrier；（3）CountDownLatch与CyclicBarrier的比较</p><p>8.2 <a class="link"   href="https://juejin.im/post/5aeec49b518825673614d183" >大白话说java并发工具类-Semaphore，Exchanger<i class="fas fa-external-link-alt"></i></a></p><p>知识点：（1）资源访问控制Semaphore；（2）数据交换Exchanger</p></li><li><p><strong>并发实践</strong></p><p>9.1 <a class="link"   href="https://juejin.im/post/5aeec675f265da0b7c072c56" >一篇文章，让你彻底弄懂生产者–消费者问题<i class="fas fa-external-link-alt"></i></a></p></li></ol><blockquote><p>JAVA并发知识图谱</p></blockquote><p><strong>可移动到新窗口，放大查看效果更好或者查看原图</strong></p><p><a class="link"   href="https://www.processon.com/view/5ab5a979e4b0a248b0e026b3?fromnew=1" >知识图谱原图链接，如果有用，可克隆给自己使用<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java并发知识专题&quot;&gt;&lt;a href=&quot;#java并发知识专题&quot; class=&quot;headerlink&quot; title=&quot;java并发知识专题&quot;&gt;&lt;/a&gt;java并发知识专题&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;努力的意义，就是，在以后的日子里，放眼望去全是自己喜欢的人和事！&lt;</summary>
      
    
    
    
    <category term="Java多线程" scheme="http://example.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java高并发" scheme="http://example.com/tags/Java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ-03</title>
    <link href="http://example.com/2023/02/19/RocketMQ-03/"/>
    <id>http://example.com/2023/02/19/RocketMQ-03/</id>
    <published>2023-02-18T23:00:28.908Z</published>
    <updated>2023-02-20T07:49:59.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ-03"><a href="#RocketMQ-03" class="headerlink" title="RocketMQ-03"></a>RocketMQ-03</h1><ul><li>1.1 消息存储<ul><li>1.1.1 存储介质</li><li>1.1.3 消息的存储和发送</li><li>1.1.4 消息存储结构</li><li>1.1.5 刷盘机制</li></ul></li><li>1.2 高可用性机制<ul><li>1.2.1 消息消费高可用</li><li>1.2.2 消息发送高可用</li><li>1.2.3 消息主从复制</li></ul></li><li>1.3 负载均衡<ul><li>1.3.1 Producer负载均衡</li><li>1.3.2 Consumer负载均衡</li></ul></li><li>1.4 消息重试<ul><li>1.4.1 顺序消息的重试</li><li>1.4.2 无序消息的重试</li></ul></li><li>1.5 死信队列<ul><li>1.5.1 死信特性</li><li>1.5.2 查看死信信息</li></ul></li><li>1.6 消费幂等<ul><li>1.6.1 消费幂等的必要性</li><li>1.6.2 处理方式</li></ul></li><li>2.1 环境搭建<ul><li>2.1.1 源码拉取</li><li>2.1.3 调试</li></ul></li><li>2.2 NameServer<ul><li>2.2.1 架构设计</li><li>2.2.2 启动流程</li><li>2.2.3 路由管理</li><li>2.2.4 小结</li></ul></li><li>2.3 Producer<ul><li>2.3.2 启动流程</li><li>2.3.3 消息发送</li><li>2.3.4 批量消息发送</li></ul></li><li>2.4 消息存储<ul><li>2.4.2 消息存储流程</li><li>2.4.3 存储文件</li><li>2.4.4 存储文件内存映射</li><li>2.4.5 实时更新消息消费队列与索引文件</li><li>2.4.6 消息队列和索引文件恢复</li><li>2.4.7 刷盘机制</li><li>2.4.8 过期文件删除机制</li><li>2.4.9 小结</li></ul></li><li>2.5 Consumer<ul><li>2.5.1 消息消费概述</li><li>2.5.3 消费者启动流程</li><li>2.5.4 消息拉取</li><li>2.5.5 消息队列负载与重新分布机制</li><li>2.5.6 消息消费过程</li><li>2.5.7 定时消息机制</li><li>2.5.8 顺序消息</li><li>2.5.9 小结</li></ul></li></ul><h1 id="1-高级功能"><a href="#1-高级功能" class="headerlink" title="1. 高级功能"></a>1. 高级功能</h1><h2 id="1-1-消息存储"><a href="#1-1-消息存储" class="headerlink" title="1.1 消息存储"></a>1.1 消息存储</h2><p>分布式队列因为有高可靠性的要求，所以数据要进行持久化存储。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png"                      alt="img"                ></p><ol><li>消息生成者发送消息</li><li>MQ收到消息，将消息进行持久化，在存储中新增一条记录</li><li>返回ACK给生产者</li><li>MQ push 消息给对应的消费者，然后等待消费者返回ACK</li><li>如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,重复执行4、5、6步骤</li><li>MQ删除消息</li></ol><h3 id="1-1-1-存储介质"><a href="#1-1-1-存储介质" class="headerlink" title="1.1.1 存储介质"></a>1.1.1 存储介质</h3><ul><li>关系型数据库DB</li></ul><p>Apache下开源的另外一款MQ—ActiveMQ（默认采用的KahaDB做消息存储）可选用JDBC的方式来做消息持久化，通过简单的xml配置信息即可实现JDBC消息存储。由于，普通关系型数据库（如Mysql）在单表数据量达到千万级别的情况下，其IO读写性能往往会出现瓶颈。在可靠性方面，该种方案非常依赖DB，如果一旦DB出现故障，则MQ的消息就无法落盘存储会导致线上故障</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/MySQL.png"                      alt="img"                ></p><ul><li><p>文件系统</p><p>目前业界较为常用的几款产品（RocketMQ&#x2F;Kafka&#x2F;RabbitMQ）均采用的是消息刷盘至所部署虚拟机&#x2F;物理机的文件系统来做持久化（刷盘一般可以分为异步刷盘和同步刷盘两种模式）。消息刷盘为消息存储提供了一种高效率、高可靠性和高性能的数据持久化方式。除非部署MQ机器本身或是本地磁盘挂了，否则一般是不会出现无法持久化的故障问题。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E7%A3%81%E7%9B%98.png"                      alt="img"                ></p></li></ul><p>###1.1.2 性能对比</p><p>文件系统&gt;关系型数据库DB</p><h3 id="1-1-3-消息的存储和发送"><a href="#1-1-3-消息的存储和发送" class="headerlink" title="1.1.3 消息的存储和发送"></a>1.1.3 消息的存储和发送</h3><h4 id="1）消息存储"><a href="#1）消息存储" class="headerlink" title="1）消息存储"></a>1）消息存储</h4><p>磁盘如果使用得当，磁盘的速度完全可以匹配上网络 的数据传输速度。目前的高性能磁盘，顺序写速度可以达到600MB&#x2F;s， 超过了一般网卡的传输速度。但是磁盘随机写的速度只有大概100KB&#x2F;s，和顺序写的性能相差6000倍！因为有如此巨大的速度差别，好的消息队列系统会比普通的消息队列系统速度快多个数量级。RocketMQ的消息用顺序写,保证了消息存储的速度。</p><p>####2）消息发送</p><p>Linux操作系统分为【用户态】和【内核态】，文件操作、网络操作需要涉及这两种形态的切换，免不了进行数据复制。</p><p>一台服务器 把本机磁盘文件的内容发送到客户端，一般分为两个步骤：</p><p>1）read；读取本地文件内容；</p><p>2）write；将读取的内容通过网络发送出去。</p><p>这两个看似简单的操作，实际进行了4 次数据复制，分别是：</p><ol><li>从磁盘复制数据到内核态内存；</li><li>从内核态内存复 制到用户态内存；</li><li>然后从用户态 内存复制到网络驱动的内核态内存；</li><li>最后是从网络驱动的内核态内存复 制到网卡中进行传输。</li></ol><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C.png"                      alt="img"                >通过使用mmap的方式，可以省去向用户态的内存复制，提高速度。这种机制在Java中是通过MappedByteBuffer实现的</p><p>RocketMQ充分利用了上述特性，也就是所谓的“零拷贝”技术，提高消息存盘和网络发送的速度。</p><blockquote><p>这里需要注意的是，采用MappedByteBuffer这种内存映射的方式有几个限制，其中之一是一次只能映射1.5~2G 的文件至用户态的虚拟内存，这也是为何RocketMQ默认设置单个CommitLog日志数据文件为1G的原因了</p></blockquote><h3 id="1-1-4-消息存储结构"><a href="#1-1-4-消息存储结构" class="headerlink" title="1.1.4 消息存储结构"></a>1.1.4 消息存储结构</h3><p>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成 的，消息真正的物理存储文件是CommitLog，ConsumeQueue是消息的逻辑队列，类似数据库的索引文件，存储的是指向物理存储的地址。每 个Topic下的每个Message Queue都有一个对应的ConsumeQueue文件。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"                      alt="img"                ></p><ul><li>CommitLog：存储消息的元数据</li><li>ConsumerQueue：存储消息在CommitLog的索引</li><li>IndexFile：为了消息查询提供了一种通过key或时间区间来查询消息的方法，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程</li></ul><h3 id="1-1-5-刷盘机制"><a href="#1-1-5-刷盘机制" class="headerlink" title="1.1.5 刷盘机制"></a>1.1.5 刷盘机制</h3><p>RocketMQ的消息是存储到磁盘上的，这样既能保证断电后恢复， 又可以让存储的消息量超出内存的限制。RocketMQ为了提高性能，会尽可能地保证磁盘的顺序写。消息在通过Producer写入RocketMQ的时 候，有两种写磁盘方式，分布式同步刷盘和异步刷盘。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98.png"                      alt="img"                ></p><h4 id="1）同步刷盘"><a href="#1）同步刷盘" class="headerlink" title="1）同步刷盘"></a>1）同步刷盘</h4><p>在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写 成功的状态。</p><h4 id="2）异步刷盘"><a href="#2）异步刷盘" class="headerlink" title="2）异步刷盘"></a>2）异步刷盘</h4><p>在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</p><h4 id="3）配置"><a href="#3）配置" class="headerlink" title="3）配置"></a>3）配置</h4><p>同步刷盘还是异步刷盘，都是通过Broker配置文件里的flushDiskType 参数设置的，这个参数被配置成SYNC_FLUSH、ASYNC_FLUSH中的 一个。</p><h2 id="1-2-高可用性机制"><a href="#1-2-高可用性机制" class="headerlink" title="1.2 高可用性机制"></a>1.2 高可用性机制</h2><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/RocketMQ%E8%A7%92%E8%89%B2.jpg"                      alt="img"                ></p><p>RocketMQ分布式集群是通过Master和Slave的配合达到高可用性的。</p><p>Master和Slave的区别：在Broker的配置文件中，参数 brokerId的值为0表明这个Broker是Master，大于0表明这个Broker是 Slave，同时brokerRole参数也会说明这个Broker是Master还是Slave。</p><p>Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。</p><h3 id="1-2-1-消息消费高可用"><a href="#1-2-1-消息消费高可用" class="headerlink" title="1.2.1 消息消费高可用"></a>1.2.1 消息消费高可用</h3><p>在Consumer的配置文件中，并不需要设置是从Master读还是从Slave 读，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave 读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性。</p><h3 id="1-2-2-消息发送高可用"><a href="#1-2-2-消息发送高可用" class="headerlink" title="1.2.2 消息发送高可用"></a>1.2.2 消息发送高可用</h3><p>在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可 用后，其他组的Master仍然可用，Producer仍然可以发送消息。 RocketMQ目前还不支持把Slave自动转成Master，如果机器资源不足， 需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文 件，用新的配置文件启动Broker。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1.jpg"                      alt="img"                ></p><h3 id="1-2-3-消息主从复制"><a href="#1-2-3-消息主从复制" class="headerlink" title="1.2.3 消息主从复制"></a>1.2.3 消息主从复制</h3><p>如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。</p><p>####1）同步复制</p><p>同步复制方式是等Master和Slave均写 成功后才反馈给客户端写成功状态；</p><p>在同步复制方式下，如果Master出故障， Slave上有全部的备份数据，容易恢复，但是同步复制会增大数据写入 延迟，降低系统吞吐量。</p><p>####2）异步复制</p><p>异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。</p><p>在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失；</p><p>####3）配置</p><p>同步复制和异步复制是通过Broker配置文件里的brokerRole参数进行设置的，这个参数可以被设置成ASYNC_MASTER、 SYNC_MASTER、SLAVE三个值中的一个。</p><p>####4）总结</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E5%A4%8D%E5%88%B6%E5%88%B7%E7%9B%98.png"                      alt="img"                ></p><p>实际应用中要结合业务场景，合理设置刷盘方式和主从复制方式， 尤其是SYNC_FLUSH方式，由于频繁地触发磁盘写动作，会明显降低 性能。通常情况下，应该把Master和Save配置成ASYNC_FLUSH的刷盘 方式，主从之间配置成SYNC_MASTER的复制方式，这样即使有一台 机器出故障，仍然能保证数据不丢，是个不错的选择。</p><h2 id="1-3-负载均衡"><a href="#1-3-负载均衡" class="headerlink" title="1.3 负载均衡"></a>1.3 负载均衡</h2><h3 id="1-3-1-Producer负载均衡"><a href="#1-3-1-Producer负载均衡" class="headerlink" title="1.3.1 Producer负载均衡"></a>1.3.1 Producer负载均衡</h3><p>Producer端，每个实例在发消息的时候，默认会轮询所有的message queue发送，以达到让消息平均落在不同的queue上。而由于queue可以散落在不同的broker，所以消息就发送到不同的broker下，如下图：</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/producer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"                      alt="img"                ></p><p>图中箭头线条上的标号代表顺序，发布方会把第一条消息发送至 Queue 0，然后第二条消息发送至 Queue 1，以此类推。</p><h3 id="1-3-2-Consumer负载均衡"><a href="#1-3-2-Consumer负载均衡" class="headerlink" title="1.3.2 Consumer负载均衡"></a>1.3.2 Consumer负载均衡</h3><h4 id="1）集群模式"><a href="#1）集群模式" class="headerlink" title="1）集群模式"></a>1）集群模式</h4><p>在集群消费模式下，每条消息只需要投递到订阅这个topic的Consumer Group下的一个实例即可。RocketMQ采用主动拉取的方式拉取并消费消息，在拉取的时候需要明确指定拉取哪一条message queue。</p><p>而每当实例的数量有变更，都会触发一次所有实例的负载均衡，这时候会按照queue的数量和实例的数量平均分配queue给每个实例。</p><p>默认的分配算法是AllocateMessageQueueAveragely，如下图：</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/consumer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"                      alt="img"                ></p><p>还有另外一种平均的算法是AllocateMessageQueueAveragelyByCircle，也是平均分摊每一条queue，只是以环状轮流分queue的形式，如下图：</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/consumer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A12.png"                      alt="img"                ></p><p>需要注意的是，集群模式下，queue都是只允许分配只一个实例，这是由于如果多个实例同时消费一个queue的消息，由于拉取哪些消息是consumer主动控制的，那样会导致同一个消息在不同的实例下被消费多次，所以算法上都是一个queue只分给一个consumer实例，一个consumer实例可以允许同时分到不同的queue。</p><p>通过增加consumer实例去分摊queue的消费，可以起到水平扩展的消费能力的作用。而有实例下线的时候，会重新触发负载均衡，这时候原来分配到的queue将分配到其他实例上继续消费。</p><p>但是如果consumer实例的数量比message queue的总数量还多的话，多出来的consumer实例将无法分到queue，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让queue的总数量大于等于consumer的数量。</p><p>####2）广播模式</p><p>由于广播模式下要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。</p><p>在实现上，其中一个不同就是在consumer分配queue的时候，所有consumer都分到所有的queue。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/consumer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A13.png"                      alt="img"                ></p><h2 id="1-4-消息重试"><a href="#1-4-消息重试" class="headerlink" title="1.4 消息重试"></a>1.4 消息重试</h2><h3 id="1-4-1-顺序消息的重试"><a href="#1-4-1-顺序消息的重试" class="headerlink" title="1.4.1 顺序消息的重试"></a>1.4.1 顺序消息的重试</h3><p>对于顺序消息，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试（每次间隔时间为 1 秒），这时，应用会出现消息消费被阻塞的情况。因此，在使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生。</p><h3 id="1-4-2-无序消息的重试"><a href="#1-4-2-无序消息的重试" class="headerlink" title="1.4.2 无序消息的重试"></a>1.4.2 无序消息的重试</h3><p>对于无序消息（普通、定时、延时、事务消息），当消费者消费消息失败时，您可以通过设置返回状态达到消息重试的结果。</p><p>无序消息的重试只针对集群消费方式生效；广播方式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息。</p><h4 id="1）重试次数"><a href="#1）重试次数" class="headerlink" title="1）重试次数"></a>1）重试次数</h4><p>消息队列 RocketMQ 默认允许每条消息最多重试 16 次，每次重试的间隔时间如下：</p><table><thead><tr><th align="center">第几次重试</th><th align="center">与上次重试的间隔时间</th><th align="center">第几次重试</th><th align="center">与上次重试的间隔时间</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">10 秒</td><td align="center">9</td><td align="center">7 分钟</td></tr><tr><td align="center">2</td><td align="center">30 秒</td><td align="center">10</td><td align="center">8 分钟</td></tr><tr><td align="center">3</td><td align="center">1 分钟</td><td align="center">11</td><td align="center">9 分钟</td></tr><tr><td align="center">4</td><td align="center">2 分钟</td><td align="center">12</td><td align="center">10 分钟</td></tr><tr><td align="center">5</td><td align="center">3 分钟</td><td align="center">13</td><td align="center">20 分钟</td></tr><tr><td align="center">6</td><td align="center">4 分钟</td><td align="center">14</td><td align="center">30 分钟</td></tr><tr><td align="center">7</td><td align="center">5 分钟</td><td align="center">15</td><td align="center">1 小时</td></tr><tr><td align="center">8</td><td align="center">6 分钟</td><td align="center">16</td><td align="center">2 小时</td></tr></tbody></table><p>如果消息重试 16 次后仍然失败，消息将不再投递。如果严格按照上述重试时间间隔计算，某条消息在一直消费失败的前提下，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，超过这个时间范围消息将不再重试投递。</p><p><strong>注意：</strong> 一条消息无论重试多少次，这些重试消息的 Message ID 不会改变。</p><h4 id="2）配置方式"><a href="#2）配置方式" class="headerlink" title="2）配置方式"></a>2）配置方式</h4><p>消费失败后，重试配置方式</p><p>集群消费方式下，消息消费失败后期望消息重试，需要在消息监听器接口的实现中明确进行配置（三种方式任选一种）：</p><ul><li>返回 Action.ReconsumeLater （推荐）</li><li>返回 Null</li><li>抛出异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="comment">//处理消息</span></span><br><span class="line">        doConsumeMessage(message);</span><br><span class="line">        <span class="comment">//方式1：返回 Action.ReconsumeLater，消息将重试</span></span><br><span class="line">        <span class="keyword">return</span> Action.ReconsumeLater;</span><br><span class="line">        <span class="comment">//方式2：返回 null，消息将重试</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//方式3：直接抛出异常， 消息将重试</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Consumer Message exceotion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费失败后，不重试配置方式</strong></p><p>集群消费方式下，消息失败后期望消息不重试，需要捕获消费逻辑中可能抛出的异常，最终返回 Action.CommitMessage，此后这条消息将不会再重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doConsumeMessage(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">//捕获消费逻辑中的所有异常，并返回 Action.CommitMessage;</span></span><br><span class="line">            <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息处理正常，直接返回 Action.CommitMessage;</span></span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义消息最大重试次数</strong></p><p>消息队列 RocketMQ 允许 Consumer 启动的时候设置最大重试次数，重试时间间隔将按照如下策略：</p><ul><li>最大重试次数小于等于 16 次，则重试时间间隔同上表描述。</li><li>最大重试次数大于 16 次，超过 16 次的重试时间间隔均为每次 2 小时。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//配置对应 Group ID 的最大消息重试次数为 20 次</span></span><br><span class="line">properties.put(PropertyKeyConst.MaxReconsumeTimes,<span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span>ONSFactory.createConsumer(properties);</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p></blockquote><ul><li>消息最大重试次数的设置对相同 Group ID 下的所有 Consumer 实例有效。</li><li>如果只对相同 Group ID 下两个 Consumer 实例中的其中一个设置了 MaxReconsumeTimes，那么该配置对两个 Consumer 实例均生效。</li><li>配置采用覆盖的方式生效，即最后启动的 Consumer 实例会覆盖之前的启动实例的配置</li></ul><p><strong>获取消息重试次数</strong></p><p>消费者收到消息后，可按照如下方式获取消息的重试次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="comment">//获取消息的重试次数</span></span><br><span class="line">        System.out.println(message.getReconsumeTimes());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-死信队列"><a href="#1-5-死信队列" class="headerlink" title="1.5 死信队列"></a>1.5 死信队列</h2><p>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p><p>在消息队列 RocketMQ 中，这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。</p><h3 id="1-5-1-死信特性"><a href="#1-5-1-死信特性" class="headerlink" title="1.5.1 死信特性"></a>1.5.1 死信特性</h3><p>死信消息具有以下特性</p><ul><li>不会再被消费者正常消费。</li><li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，请在死信消息产生后的 3 天内及时处理。</li></ul><p>死信队列具有以下特性：</p><ul><li>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例。</li><li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li><li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li></ul><h3 id="1-5-2-查看死信信息"><a href="#1-5-2-查看死信信息" class="headerlink" title="1.5.2 查看死信信息"></a>1.5.2 查看死信信息</h3><ol><li>在控制台查询出现死信队列的主题信息</li></ol><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%B8%BB%E9%A2%98.png"                      alt="img"                ></p><ol><li>在消息界面根据主题查询死信消息</li></ol><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%B8%BB%E9%A2%982.png"                      alt="img"                ></p><ol><li>选择重新发送消息</li></ol><p>一条消息进入死信队列，意味着某些因素导致消费者无法正常消费该消息，因此，通常需要您对其进行特殊处理。排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息，让消费者重新消费一次。</p><h2 id="1-6-消费幂等"><a href="#1-6-消费幂等" class="headerlink" title="1.6 消费幂等"></a>1.6 消费幂等</h2><p>消息队列 RocketMQ 消费者在接收到消息以后，有必要根据业务上的唯一 Key 对消息做幂等处理的必要性。</p><h3 id="1-6-1-消费幂等的必要性"><a href="#1-6-1-消费幂等的必要性" class="headerlink" title="1.6.1 消费幂等的必要性"></a>1.6.1 消费幂等的必要性</h3><p>在互联网应用中，尤其在网络不稳定的情况下，消息队列 RocketMQ 的消息有可能会出现重复，这个重复简单可以概括为以下情况：</p><ul><li><p>发送时消息重复</p><p>当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p></li><li><p>投递时消息重复</p><p>消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。 为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p></li><li><p>负载均衡时消息重复（包括但不限于网络抖动、Broker 重启以及订阅方应用重启）</p><p>当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息。</p></li></ul><h3 id="1-6-2-处理方式"><a href="#1-6-2-处理方式" class="headerlink" title="1.6.2 处理方式"></a>1.6.2 处理方式</h3><p>因为 Message ID 有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据。 最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 进行设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">message.setKey(<span class="string">&quot;ORDERID_100&quot;</span>);</span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br></pre></td></tr></table></figure><p>订阅方收到消息时可以根据消息的 Key 进行幂等处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;ons_test&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getKey()</span><br><span class="line">        <span class="comment">// 根据业务唯一标识的 key 做幂等处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h1><h2 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h2><p>依赖工具</p><ul><li>JDK ：1.8+</li><li>Maven</li><li>IntelliJ IDEA</li></ul><h3 id="2-1-1-源码拉取"><a href="#2-1-1-源码拉取" class="headerlink" title="2.1.1 源码拉取"></a>2.1.1 源码拉取</h3><p>从官方仓库 <a class="link"   href="https://github.com/apache/rocketmq" >https://github.com/apache/rocketmq<i class="fas fa-external-link-alt"></i></a> <code>clone</code>或者<code>download</code>源码。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%BA%90%E7%A0%811.png"                      alt="img"                ></p><p><strong>源码目录结构：</strong></p><ul><li>broker: broker 模块（broke 启动进程）</li><li>client ：消息客户端，包含消息生产者、消息消费者相关类</li><li>common ：公共包</li><li>dev ：开发者信息（非源代码）</li><li>distribution ：部署实例文件夹（非源代码）</li><li>example: RocketMQ 例代码</li><li>filter ：消息过滤相关基础类</li><li>filtersrv：消息过滤服务器实现相关类（Filter启动进程）</li><li>logappender：日志实现相关类</li><li>namesrv：NameServer实现相关类（NameServer启动进程）</li><li>openmessageing：消息开放标准</li><li>remoting：远程通信模块，给予Netty</li><li>srcutil：服务工具类</li><li>store：消息存储实现相关类</li><li>style：checkstyle相关实现</li><li>test：测试相关类</li><li>tools：工具类，监控命令相关实现类</li></ul><p>###2.1.2 导入IDEA</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%BA%90%E7%A0%812.png"                      alt="img"                ></p><p><strong>执行安装</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean install -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="2-1-3-调试"><a href="#2-1-3-调试" class="headerlink" title="2.1.3 调试"></a>2.1.3 调试</h3><p>创建<code>conf</code>配置文件夹,从<code>distribution</code>拷贝<code>broker.conf</code>和<code>logback_broker.xml</code>和<code>logback_namesrv.xml</code></p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%BA%90%E7%A0%816.png"                      alt="img"                ></p><h4 id="1）启动NameServer"><a href="#1）启动NameServer" class="headerlink" title="1）启动NameServer"></a>1）启动NameServer</h4><ul><li>展开namesrv模块，右键NamesrvStartup.java</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%BA%90%E7%A0%813.png"                      alt="img"                ></p><ul><li>配置<strong>ROCKETMQ_HOME</strong></li></ul><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%BA%90%E7%A0%814.png"                      alt="img"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%BA%90%E7%A0%815.png"                      alt="img"                ></p><ul><li><p>重新启动</p><p>控制台打印结果</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Name Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure><p>1</p><h4 id="2）启动Broker"><a href="#2）启动Broker" class="headerlink" title="2）启动Broker"></a>2）启动Broker</h4><ul><li><code>broker.conf</code>配置文件内容</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">brokerClusterName</span> = <span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span> = <span class="string">broker-a</span></span><br><span class="line"><span class="attr">brokerId</span> = <span class="string">0</span></span><br><span class="line"><span class="comment"># namesrvAddr地址</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">127.0.0.1:9876</span></span><br><span class="line"><span class="attr">deleteWhen</span> = <span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span> = <span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span> = <span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="attr">flushDiskType</span> = <span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">E:\\RocketMQ\\data\\rocketmq\\dataDir</span></span><br><span class="line"><span class="comment"># commitLog路径</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">E:\\RocketMQ\\data\\rocketmq\\dataDir\\commitlog</span></span><br><span class="line"><span class="comment"># 消息队列存储路径</span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">E:\\RocketMQ\\data\\rocketmq\\dataDir\\consumequeue</span></span><br><span class="line"><span class="comment"># 消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">E:\\RocketMQ\\data\\rocketmq\\dataDir\\index</span></span><br><span class="line"><span class="comment"># checkpoint文件路径</span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">E:\\RocketMQ\\data\\rocketmq\\dataDir\\checkpoint</span></span><br><span class="line"><span class="comment"># abort文件存储路径</span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">E:\\RocketMQ\\data\\rocketmq\\dataDir\\abort</span></span><br></pre></td></tr></table></figure><ul><li>创建数据文件夹<code>dataDir</code></li><li>启动<code>BrokerStartup</code>,配置<code>broker.conf</code>和<code>ROCKETMQ_HOME</code></li></ul><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%BA%90%E7%A0%817.png"                      alt="img"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%BA%90%E7%A0%818.png"                      alt="img"                ></p><h4 id="3）发送消息"><a href="#3）发送消息" class="headerlink" title="3）发送消息"></a>3）发送消息</h4><ul><li>进入example模块的<code>org.apache.rocketmq.example.quickstart</code></li><li>指定Namesrv地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>运行<code>main</code>方法，发送消息</li></ul><h4 id="4）消费消息"><a href="#4）消费消息" class="headerlink" title="4）消费消息"></a>4）消费消息</h4><ul><li>进入example模块的<code>org.apache.rocketmq.example.quickstart</code></li><li>指定Namesrv地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;please_rename_unique_group_name_4&quot;</span>);</span><br><span class="line">consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>运行<code>main</code>方法，消费消息</li></ul><h2 id="2-2-NameServer"><a href="#2-2-NameServer" class="headerlink" title="2.2 NameServer"></a>2.2 NameServer</h2><h3 id="2-2-1-架构设计"><a href="#2-2-1-架构设计" class="headerlink" title="2.2.1 架构设计"></a>2.2.1 架构设计</h3><p>消息中间件的设计思路一般是基于主题订阅发布的机制，消息生产者（Producer）发送某一个主题到消息服务器，消息服务器负责将消息持久化存储，消息消费者（Consumer）订阅该兴趣的主题，消息服务器根据订阅信息（路由信息）将消息推送到消费者（Push模式）或者消费者主动向消息服务器拉去（Pull模式），从而实现消息生产者与消息消费者解耦。为了避免消息服务器的单点故障导致的整个系统瘫痪，通常会部署多台消息服务器共同承担消息的存储。那消息生产者如何知道消息要发送到哪台消息服务器呢？如果某一台消息服务器宕机了，那么消息生产者如何在不重启服务情况下感知呢？</p><p>NameServer就是为了解决以上问题设计的。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/RocketMQ%E8%A7%92%E8%89%B2.jpg"                      alt="img"                ></p><p>Broker消息服务器在启动的时向所有NameServer注册，消息生产者（Producer）在发送消息时之前先从NameServer获取Broker服务器地址列表，然后根据负载均衡算法从列表中选择一台服务器进行发送。NameServer与每台Broker保持长连接，并间隔30S检测Broker是否存活，如果检测到Broker宕机，则从路由注册表中删除。但是路由变化不会马上通知消息生产者。这样设计的目的是为了降低NameServer实现的复杂度，在消息发送端提供容错机制保证消息发送的可用性。</p><p>NameServer本身的高可用是通过部署多台NameServer来实现，但彼此之间不通讯，也就是NameServer服务器之间在某一个时刻的数据并不完全相同，但这对消息发送并不会造成任何影响，这也是NameServer设计的一个亮点，总之，RocketMQ设计追求简单高效。</p><h3 id="2-2-2-启动流程"><a href="#2-2-2-启动流程" class="headerlink" title="2.2.2 启动流程"></a>2.2.2 启动流程</h3><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/NameServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png"                      alt="img"                ></p><p>启动类：<code>org.apache.rocketmq.namesrv.NamesrvStartup</code></p><p>####步骤一</p><p>解析配置文件，填充NameServerConfig、NettyServerConfig属性值，并创建NamesrvController</p><p><em><strong>代码：NamesrvController#createNamesrvController</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建NamesrvConfig</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">NamesrvConfig</span> <span class="variable">namesrvConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamesrvConfig</span>();</span><br><span class="line"><span class="comment">//创建NettyServerConfig</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServerConfig</span>();</span><br><span class="line"><span class="comment">//设置启动端口号</span></span><br><span class="line">nettyServerConfig.setListenPort(<span class="number">9876</span>);</span><br><span class="line"><span class="comment">//解析启动-c参数</span></span><br><span class="line"><span class="keyword">if</span> (commandLine.hasOption(<span class="string">&#x27;c&#x27;</span>)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> commandLine.getOptionValue(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">        properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(in);</span><br><span class="line">        MixAll.properties2Object(properties, namesrvConfig);</span><br><span class="line">        MixAll.properties2Object(properties, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">        namesrvConfig.setConfigStorePath(file);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;load config properties file OK, %s%n&quot;</span>, file);</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析启动-p参数</span></span><br><span class="line"><span class="keyword">if</span> (commandLine.hasOption(<span class="string">&#x27;p&#x27;</span>)) &#123;</span><br><span class="line">    <span class="type">InternalLogger</span> <span class="variable">console</span> <span class="operator">=</span> InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME);</span><br><span class="line">    MixAll.printObjectProperties(console, namesrvConfig);</span><br><span class="line">    MixAll.printObjectProperties(console, nettyServerConfig);</span><br><span class="line">    System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将启动参数填充到namesrvConfig,nettyServerConfig</span></span><br><span class="line">MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建NameServerController</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">NamesrvController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamesrvController</span>(namesrvConfig, nettyServerConfig);</span><br></pre></td></tr></table></figure><p><strong>NamesrvConfig属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">rocketmqHome</span> <span class="operator">=</span> System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">kvConfigPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>) + File.separator + <span class="string">&quot;namesrv&quot;</span> + File.separator + <span class="string">&quot;kvConfig.json&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">configStorePath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>) + File.separator + <span class="string">&quot;namesrv&quot;</span> + File.separator + <span class="string">&quot;namesrv.properties&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">productEnvName</span> <span class="operator">=</span> <span class="string">&quot;center&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">clusterTest</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">orderMessageEnable</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p><strong>rocketmqHome：</strong>rocketmq主目录</p><p><strong>kvConfig：</strong>NameServer存储KV配置属性的持久化路径</p><p><strong>configStorePath：</strong>nameServer默认配置文件路径</p><p><strong>orderMessageEnable：</strong>是否支持顺序消息</p><p><strong>NettyServerConfig属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">listenPort</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverWorkerThreads</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverCallbackExecutorThreads</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverSelectorThreads</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverOnewaySemaphoreValue</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverAsyncSemaphoreValue</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverChannelMaxIdleTimeSeconds</span> <span class="operator">=</span> <span class="number">120</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverSocketSndBufSize</span> <span class="operator">=</span> NettySystemConfig.socketSndbufSize;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverSocketRcvBufSize</span> <span class="operator">=</span> NettySystemConfig.socketRcvbufSize;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">serverPooledByteBufAllocatorEnable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">useEpollNativeSelector</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p><strong>listenPort：</strong>NameServer监听端口，该值默认会被初始化为9876 <strong>serverWorkerThreads：</strong>Netty业务线程池线程个数 <strong>serverCallbackExecutorThreads：</strong>Netty public任务线程池线程个数，Netty网络设计，根据业务类型会创建不同的线程池，比如处理消息发送、消息消费、心跳检测等。如果该业务类型未注册线程池，则由public线程池执行。 <strong>serverSelectorThreads：</strong>IO线程池个数，主要是NameServer、Broker端解析请求、返回相应的线程个数，这类线程主要是处理网路请求的，解析请求包，然后转发到各个业务线程池完成具体的操作，然后将结果返回给调用方; <strong>serverOnewaySemaphoreValue：</strong>send oneway消息请求并发读（Broker端参数）; <strong>serverAsyncSemaphoreValue：</strong>异步消息发送最大并发度; <strong>serverChannelMaxIdleTimeSeconds ：</strong>网络连接最大的空闲时间，默认120s。 <strong>serverSocketSndBufSize：</strong>网络socket发送缓冲区大小。 <strong>serverSocketRcvBufSize：</strong> 网络接收端缓存区大小。 <strong>serverPooledByteBufAllocatorEnable：</strong>ByteBuffer是否开启缓存; <strong>useEpollNativeSelector：</strong>是否启用Epoll IO模型。</p><h4 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h4><p>根据启动属性创建NamesrvController实例，并初始化该实例。NameServerController实例为NameServer核心控制器</p><p><em><strong>代码：NamesrvController#initialize</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//加载KV配置</span></span><br><span class="line">    <span class="built_in">this</span>.kvConfigManager.load();</span><br><span class="line"><span class="comment">//创建NettyServer网络处理对象</span></span><br><span class="line">    <span class="built_in">this</span>.remotingServer = <span class="keyword">new</span> <span class="title class_">NettyRemotingServer</span>(<span class="built_in">this</span>.nettyServerConfig, <span class="built_in">this</span>.brokerHousekeepingService);</span><br><span class="line"><span class="comment">//开启定时任务:每隔10s扫描一次Broker,移除不活跃的Broker</span></span><br><span class="line">    <span class="built_in">this</span>.remotingExecutor =</span><br><span class="line">        Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> <span class="title class_">ThreadFactoryImpl</span>(<span class="string">&quot;RemotingExecutorThread_&quot;</span>));</span><br><span class="line">    <span class="built_in">this</span>.registerProcessor();</span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            NamesrvController.<span class="built_in">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//开启定时任务:每隔10min打印一次KV配置</span></span><br><span class="line"><span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            NamesrvController.<span class="built_in">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h4><p>在JVM进程关闭之前，先将线程池关闭，及时释放资源</p><p><em><strong>代码：NamesrvStartup#start</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册JVM钩子函数代码</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">ShutdownHookThread</span>(log, <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Void <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        controller.shutdown();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="2-2-3-路由管理"><a href="#2-2-3-路由管理" class="headerlink" title="2.2.3 路由管理"></a>2.2.3 路由管理</h3><p>NameServer的主要作用是为消息的生产者和消息消费者提供关于主题Topic的路由信息，那么NameServer需要存储路由的基础信息，还要管理Broker节点，包括路由注册、路由删除等。</p><h4 id="2-2-3-1-路由元信息"><a href="#2-2-3-1-路由元信息" class="headerlink" title="2.2.3.1 路由元信息"></a>2.2.3.1 路由元信息</h4><p>代码：RouteInfoManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E8%B7%AF%E7%94%B1%E5%AE%9E%E4%BD%93%E5%9B%BE.png"                      alt="img"                ></p><p><strong>topicQueueTable：</strong>Topic消息队列路由信息，消息发送时根据路由表进行负载均衡</p><p><strong>brokerAddrTable：</strong>Broker基础信息，包括brokerName、所属集群名称、主备Broker地址</p><p><strong>clusterAddrTable：</strong>Broker集群信息，存储集群中所有Broker名称</p><p><strong>brokerLiveTable：</strong>Broker状态信息，NameServer每次收到心跳包是会替换该信息</p><p><strong>filterServerTable：</strong>Broker上的FilterServer列表，用于类模式消息过滤。</p><blockquote><p>RocketMQ基于定于发布机制，一个Topic拥有多个消息队列，一个Broker为每一个主题创建4个读队列和4个写队列。多个Broker组成一个集群，集群由相同的多台Broker组成Master-Slave架构，brokerId为0代表Master，大于0为Slave。BrokerLiveInfo中的lastUpdateTimestamp存储上次收到Broker心跳包的时间。</p></blockquote><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E5%AE%9E%E4%BE%8B.png"                      alt="img"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E5%AE%9E%E4%BE%8B2.png"                      alt="img"                ></p><h4 id="2-2-3-2-路由注册"><a href="#2-2-3-2-路由注册" class="headerlink" title="2.2.3.2 路由注册"></a>2.2.3.2 路由注册</h4><h4 id="1）发送心跳包"><a href="#1）发送心跳包" class="headerlink" title="1）发送心跳包"></a>1）发送心跳包</h4><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C.png"                      alt="img"                ></p><p>RocketMQ路由注册是通过Broker与NameServer的心跳功能实现的。Broker启动时向集群中所有的NameServer发送心跳信息，每隔30s向集群中所有NameServer发送心跳包，NameServer收到心跳包时会更新brokerLiveTable缓存中BrokerLiveInfo的lastUpdataTimeStamp信息，然后NameServer每隔10s扫描brokerLiveTable，如果连续120S没有收到心跳包，NameServer将移除Broker的路由信息同时关闭Socket连接。</p><p><em><strong>代码：BrokerController#start</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册Broker信息</span></span><br><span class="line"><span class="built_in">this</span>.registerBrokerAll(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//每隔30s上报Broker信息到NameServer</span></span><br><span class="line"><span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BrokerController.<span class="built_in">this</span>.registerBrokerAll(<span class="literal">true</span>, <span class="literal">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;registerBrokerAll Exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), </span><br><span class="line">                                                  TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p><em><strong>代码：BrokerOuterAPI#registerBrokerAll</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得nameServer地址信息</span></span><br><span class="line">List&lt;String&gt; nameServerAddressList = <span class="built_in">this</span>.remotingClient.getNameServerAddressList();</span><br><span class="line"><span class="comment">//遍历所有nameserver列表</span></span><br><span class="line"><span class="keyword">if</span> (nameServerAddressList != <span class="literal">null</span> &amp;&amp; nameServerAddressList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装请求头</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RegisterBrokerRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegisterBrokerRequestHeader</span>();</span><br><span class="line">    requestHeader.setBrokerAddr(brokerAddr);</span><br><span class="line">    requestHeader.setBrokerId(brokerId);</span><br><span class="line">    requestHeader.setBrokerName(brokerName);</span><br><span class="line">    requestHeader.setClusterName(clusterName);</span><br><span class="line">    requestHeader.setHaServerAddr(haServerAddr);</span><br><span class="line">    requestHeader.setCompressed(compressed);</span><br><span class="line"><span class="comment">//封装请求体</span></span><br><span class="line">    <span class="type">RegisterBrokerBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegisterBrokerBody</span>();</span><br><span class="line">    requestBody.setTopicConfigSerializeWrapper(topicConfigWrapper);</span><br><span class="line">    requestBody.setFilterServerList(filterServerList);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] body = requestBody.encode(compressed);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">bodyCrc32</span> <span class="operator">=</span> UtilAll.crc32(body);</span><br><span class="line">    requestHeader.setBodyCrc32(bodyCrc32);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(nameServerAddressList.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String namesrvAddr : nameServerAddressList) &#123;</span><br><span class="line">        brokerOuterExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//分别向NameServer注册</span></span><br><span class="line">                    <span class="type">RegisterBrokerResult</span> <span class="variable">result</span> <span class="operator">=</span> registerBroker(namesrvAddr,oneway, timeoutMills,requestHeader,body);</span><br><span class="line">                    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                        registerBrokerResultList.add(result);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">&quot;register broker[&#123;&#125;]to name server &#123;&#125; OK&quot;</span>, brokerId, namesrvAddr);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;registerBroker Exception, &#123;&#125;&quot;</span>, namesrvAddr, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：BrokerOutAPI#registerBroker</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oneway) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.remotingClient.invokeOneway(namesrvAddr, request, timeoutMills);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingTooMuchRequestException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> <span class="built_in">this</span>.remotingClient.invokeSync(namesrvAddr, request, timeoutMills);</span><br></pre></td></tr></table></figure><h5 id="2）处理心跳包"><a href="#2）处理心跳包" class="headerlink" title="2）处理心跳包"></a>2）处理心跳包</h5><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/NameServer%E5%A4%84%E7%90%86%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C.png"                      alt="img"                ></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor`网路处理类解析请求类型，如果请求类型是为***REGISTER_BROKER***，则将请求转发到`RouteInfoManager#regiesterBroker</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultRequestProcessor#processRequest</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是注册Broker信息</span></span><br><span class="line"><span class="keyword">case</span> RequestCode.REGISTER_BROKER:</span><br><span class="line"><span class="type">Version</span> <span class="variable">brokerVersion</span> <span class="operator">=</span> MQVersion.value2Version(request.getVersion());</span><br><span class="line"><span class="keyword">if</span> (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.registerBrokerWithFilterServer(ctx, request);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//注册Broker信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.registerBroker(ctx, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultRequestProcessor#registerBroker</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RegisterBrokerResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.namesrvController.getRouteInfoManager().registerBroker(</span><br><span class="line">    requestHeader.getClusterName(),</span><br><span class="line">    requestHeader.getBrokerAddr(),</span><br><span class="line">    requestHeader.getBrokerName(),</span><br><span class="line">    requestHeader.getBrokerId(),</span><br><span class="line">    requestHeader.getHaServerAddr(),</span><br><span class="line">    topicConfigWrapper,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    ctx.channel()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><em><strong>代码：RouteInfoManager#registerBroker</strong></em></p><p>维护路由信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="built_in">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line"><span class="comment">//维护clusterAddrTable</span></span><br><span class="line">Set&lt;String&gt; brokerNames = <span class="built_in">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == brokerNames) &#123;</span><br><span class="line">    brokerNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">    <span class="built_in">this</span>.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">&#125;</span><br><span class="line">brokerNames.add(brokerName);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护brokerAddrTable</span></span><br><span class="line"><span class="type">BrokerData</span> <span class="variable">brokerData</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line"><span class="comment">//第一次注册,则创建brokerData</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == brokerData) &#123;</span><br><span class="line">    registerFirst = <span class="literal">true</span>;</span><br><span class="line">    brokerData = <span class="keyword">new</span> <span class="title class_">BrokerData</span>(clusterName, brokerName, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, String&gt;());</span><br><span class="line">    <span class="built_in">this</span>.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非第一次注册,更新Broker</span></span><br><span class="line">Map&lt;Long, String&gt; brokerAddrsMap = brokerData.getBrokerAddrs();</span><br><span class="line">Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerAddrsMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Entry&lt;Long, String&gt; item = it.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId != item.getKey()) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">oldAddr</span> <span class="operator">=</span> brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">registerFirst = registerFirst || (<span class="literal">null</span> == oldAddr);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护topicQueueTable</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != topicConfigWrapper &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion()) || </span><br><span class="line">        registerFirst) &#123;</span><br><span class="line">        ConcurrentMap&lt;String, TopicConfig&gt; tcTable = topicConfigWrapper.getTopicConfigTable();</span><br><span class="line">        <span class="keyword">if</span> (tcTable != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：RouteInfoManager#createAndUpdateQueueData</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createAndUpdateQueueData</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> TopicConfig topicConfig)</span> &#123;</span><br><span class="line">    <span class="comment">//创建QueueData</span></span><br><span class="line"><span class="type">QueueData</span> <span class="variable">queueData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueueData</span>();</span><br><span class="line">queueData.setBrokerName(brokerName);</span><br><span class="line">queueData.setWriteQueueNums(topicConfig.getWriteQueueNums());</span><br><span class="line">queueData.setReadQueueNums(topicConfig.getReadQueueNums());</span><br><span class="line">queueData.setPerm(topicConfig.getPerm());</span><br><span class="line">queueData.setTopicSynFlag(topicConfig.getTopicSysFlag());</span><br><span class="line"><span class="comment">//获得topicQueueTable中队列集合</span></span><br><span class="line">List&lt;QueueData&gt; queueDataList = <span class="built_in">this</span>.topicQueueTable.get(topicConfig.getTopicName());</span><br><span class="line">    <span class="comment">//topicQueueTable为空,则直接添加queueData到队列集合</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == queueDataList) &#123;</span><br><span class="line">    queueDataList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;QueueData&gt;();</span><br><span class="line">    queueDataList.add(queueData);</span><br><span class="line">    <span class="built_in">this</span>.topicQueueTable.put(topicConfig.getTopicName(), queueDataList);</span><br><span class="line">    log.info(<span class="string">&quot;new topic registered, &#123;&#125; &#123;&#125;&quot;</span>, topicConfig.getTopicName(), queueData);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否是新的队列</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">addNewOne</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    Iterator&lt;QueueData&gt; it = queueDataList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="type">QueueData</span> <span class="variable">qd</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="comment">//如果brokerName相同,代表不是新的队列</span></span><br><span class="line">        <span class="keyword">if</span> (qd.getBrokerName().equals(brokerName)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (qd.equals(queueData)) &#123;</span><br><span class="line">                addNewOne = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;topic changed, &#123;&#125; OLD: &#123;&#125; NEW: &#123;&#125;&quot;</span>, topicConfig.getTopicName(), qd,</span><br><span class="line">                        queueData);</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果是新的队列,则添加队列到queueDataList</span></span><br><span class="line">        <span class="keyword">if</span> (addNewOne) &#123;</span><br><span class="line">            queueDataList.add(queueData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护brokerLiveTable</span></span><br><span class="line"><span class="type">BrokerLiveInfo</span> <span class="variable">prevBrokerLiveInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerLiveTable.put(brokerAddr,<span class="keyword">new</span> <span class="title class_">BrokerLiveInfo</span>(</span><br><span class="line">    System.currentTimeMillis(),</span><br><span class="line">    topicConfigWrapper.getDataVersion(),</span><br><span class="line">    channel,</span><br><span class="line">    haServerAddr));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护filterServerList</span></span><br><span class="line"><span class="keyword">if</span> (filterServerList != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (filterServerList.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.filterServerTable.remove(brokerAddr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">masterAddr</span> <span class="operator">=</span> brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">    <span class="keyword">if</span> (masterAddr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">BrokerLiveInfo</span> <span class="variable">brokerLiveInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line">        <span class="keyword">if</span> (brokerLiveInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">            result.setMasterAddr(masterAddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-3-路由删除"><a href="#2-2-3-3-路由删除" class="headerlink" title="2.2.3.3 路由删除"></a>2.2.3.3 路由删除</h4><p>Broker每隔30s向NameServer发送一个心跳包，心跳包包含BrokerId，Broker地址，Broker名称，Broker所属集群名称、Broker关联的FilterServer列表。但是如果Broker宕机，NameServer无法收到心跳包，此时NameServer如何来剔除这些失效的Broker呢？NameServer会每隔10s扫描brokerLiveTable状态表，如果BrokerLive的lastUpdateTimestamp的时间戳距当前时间超过120s，则认为Broker失效，移除该Broker，关闭与Broker连接，同时更新topicQueueTable、brokerAddrTable、brokerLiveTable、filterServerTable。</p><p><strong>RocketMQ有两个触发点来删除路由信息</strong>：</p><ul><li>NameServer定期扫描brokerLiveTable检测上次心跳包与当前系统的时间差，如果时间超过120s，则需要移除broker。</li><li>Broker在正常关闭的情况下，会执行unregisterBroker指令</li></ul><p>这两种方式路由删除的方法都是一样的，就是从相关路由表中删除与该broker相关的信息。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E8%B7%AF%E7%94%B1%E5%88%A0%E9%99%A4.png"                      alt="img"                ></p><p><em><strong>代码：NamesrvController#initialize</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每隔10s扫描一次为活跃Broker</span></span><br><span class="line"><span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        NamesrvController.<span class="built_in">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p><em><strong>代码：RouteInfoManager#scanNotActiveBroker</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scanNotActiveBroker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获得brokerLiveTable</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = <span class="built_in">this</span>.brokerLiveTable.entrySet().iterator();</span><br><span class="line">    <span class="comment">//遍历brokerLiveTable</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, BrokerLiveInfo&gt; next = it.next();</span><br><span class="line">        <span class="type">long</span> <span class="variable">last</span> <span class="operator">=</span> next.getValue().getLastUpdateTimestamp();</span><br><span class="line">        <span class="comment">//如果收到心跳包的时间距当时时间是否超过120s</span></span><br><span class="line">        <span class="keyword">if</span> ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class="line">            <span class="comment">//移除broker</span></span><br><span class="line">            it.remove();</span><br><span class="line">            <span class="comment">//维护路由表</span></span><br><span class="line">            <span class="built_in">this</span>.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：RouteInfoManager#onChannelDestroy</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请写锁,根据brokerAddress从brokerLiveTable和filterServerTable移除</span></span><br><span class="line"><span class="built_in">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line"><span class="built_in">this</span>.brokerLiveTable.remove(brokerAddrFound);</span><br><span class="line"><span class="built_in">this</span>.filterServerTable.remove(brokerAddrFound);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护brokerAddrTable</span></span><br><span class="line"><span class="type">String</span> <span class="variable">brokerNameFound</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">removeBrokerName</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">Iterator&lt;Entry&lt;String, BrokerData&gt;&gt; itBrokerAddrTable =<span class="built_in">this</span>.brokerAddrTable.entrySet().iterator();</span><br><span class="line"><span class="comment">//遍历brokerAddrTable</span></span><br><span class="line"><span class="keyword">while</span> (itBrokerAddrTable.hasNext() &amp;&amp; (<span class="literal">null</span> == brokerNameFound)) &#123;</span><br><span class="line">    <span class="type">BrokerData</span> <span class="variable">brokerData</span> <span class="operator">=</span> itBrokerAddrTable.next().getValue();</span><br><span class="line">    <span class="comment">//遍历broker地址</span></span><br><span class="line">    Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerData.getBrokerAddrs().entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;Long, String&gt; entry = it.next();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">brokerId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">brokerAddr</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="comment">//根据broker地址移除brokerAddr</span></span><br><span class="line">        <span class="keyword">if</span> (brokerAddr.equals(brokerAddrFound)) &#123;</span><br><span class="line">            brokerNameFound = brokerData.getBrokerName();</span><br><span class="line">            it.remove();</span><br><span class="line">            log.info(<span class="string">&quot;remove brokerAddr[&#123;&#125;, &#123;&#125;] from brokerAddrTable, because channel destroyed&quot;</span>,</span><br><span class="line">                brokerId, brokerAddr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果当前主题只包含待移除的broker,则移除该topic</span></span><br><span class="line">    <span class="keyword">if</span> (brokerData.getBrokerAddrs().isEmpty()) &#123;</span><br><span class="line">        removeBrokerName = <span class="literal">true</span>;</span><br><span class="line">        itBrokerAddrTable.remove();</span><br><span class="line">        log.info(<span class="string">&quot;remove brokerName[&#123;&#125;] from brokerAddrTable, because channel destroyed&quot;</span>,</span><br><span class="line">            brokerData.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护clusterAddrTable</span></span><br><span class="line"><span class="keyword">if</span> (brokerNameFound != <span class="literal">null</span> &amp;&amp; removeBrokerName) &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;String, Set&lt;String&gt;&gt;&gt; it = <span class="built_in">this</span>.clusterAddrTable.entrySet().iterator();</span><br><span class="line">    <span class="comment">//遍历clusterAddrTable</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, Set&lt;String&gt;&gt; entry = it.next();</span><br><span class="line">        <span class="comment">//获得集群名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">clusterName</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="comment">//获得集群中brokerName集合</span></span><br><span class="line">        Set&lt;String&gt; brokerNames = entry.getValue();</span><br><span class="line">        <span class="comment">//从brokerNames中移除brokerNameFound</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> brokerNames.remove(brokerNameFound);</span><br><span class="line">        <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;remove brokerName[&#123;&#125;], clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed&quot;</span>,</span><br><span class="line">                brokerNameFound, clusterName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerNames.isEmpty()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;remove the clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed and no broker in this cluster&quot;</span>,</span><br><span class="line">                    clusterName);</span><br><span class="line">                <span class="comment">//如果集群中不包含任何broker,则移除该集群</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护topicQueueTable队列</span></span><br><span class="line"><span class="keyword">if</span> (removeBrokerName) &#123;</span><br><span class="line">    <span class="comment">//遍历topicQueueTable</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, List&lt;QueueData&gt;&gt;&gt; itTopicQueueTable =</span><br><span class="line">        <span class="built_in">this</span>.topicQueueTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (itTopicQueueTable.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, List&lt;QueueData&gt;&gt; entry = itTopicQueueTable.next();</span><br><span class="line">        <span class="comment">//主题名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="comment">//队列集合</span></span><br><span class="line">        List&lt;QueueData&gt; queueDataList = entry.getValue();</span><br><span class="line"><span class="comment">//遍历该主题队列</span></span><br><span class="line">        Iterator&lt;QueueData&gt; itQueueData = queueDataList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (itQueueData.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//从队列中移除为活跃broker信息</span></span><br><span class="line">            <span class="type">QueueData</span> <span class="variable">queueData</span> <span class="operator">=</span> itQueueData.next();</span><br><span class="line">            <span class="keyword">if</span> (queueData.getBrokerName().equals(brokerNameFound)) &#123;</span><br><span class="line">                itQueueData.remove();</span><br><span class="line">                log.info(<span class="string">&quot;remove topic[&#123;&#125; &#123;&#125;], from topicQueueTable, because channel destroyed&quot;</span>,</span><br><span class="line">                    topic, queueData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果该topic的队列为空,则移除该topic</span></span><br><span class="line">        <span class="keyword">if</span> (queueDataList.isEmpty()) &#123;</span><br><span class="line">            itTopicQueueTable.remove();</span><br><span class="line">            log.info(<span class="string">&quot;remove topic[&#123;&#125;] all queue, from topicQueueTable, because channel destroyed&quot;</span>,</span><br><span class="line">                topic);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放写锁</span></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-4-路由发现"><a href="#2-2-3-4-路由发现" class="headerlink" title="2.2.3.4 路由发现"></a>2.2.3.4 路由发现</h4><p>RocketMQ路由发现是非实时的，当Topic路由出现变化后，NameServer不会主动推送给客户端，而是由客户端定时拉取主题最新的路由。</p><p><em><strong>代码：DefaultRequestProcessor#getRouteInfoByTopic</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">getRouteInfoByTopic</span><span class="params">(ChannelHandlerContext ctx,</span></span><br><span class="line"><span class="params">    RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> RemotingCommand.createResponseCommand(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">GetRouteInfoRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span></span><br><span class="line">        (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class);</span><br><span class="line"><span class="comment">//调用RouteInfoManager的方法,从路由表topicQueueTable、brokerAddrTable、filterServerTable中分别填充TopicRouteData的List&lt;QueueData&gt;、List&lt;BrokerData&gt;、filterServer</span></span><br><span class="line">    <span class="type">TopicRouteData</span> <span class="variable">topicRouteData</span> <span class="operator">=</span> <span class="built_in">this</span>.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());</span><br><span class="line"><span class="comment">//如果找到主题对应你的路由信息并且该主题为顺序消息，则从NameServer KVConfig中获取关于顺序消息相关的配置填充路由信息</span></span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.namesrvController.getNamesrvConfig().isOrderMessageEnable()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">orderTopicConf</span> <span class="operator">=</span></span><br><span class="line">                <span class="built_in">this</span>.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG,</span><br><span class="line">                    requestHeader.getTopic());</span><br><span class="line">            topicRouteData.setOrderTopicConf(orderTopicConf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] content = topicRouteData.encode();</span><br><span class="line">        response.setBody(content);</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(ResponseCode.TOPIC_NOT_EXIST);</span><br><span class="line">    response.setRemark(<span class="string">&quot;No topic route info in name server for the topic: &quot;</span> + requestHeader.getTopic()</span><br><span class="line">        + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4 小结"></a>2.2.4 小结</h3><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/NameServer%E5%B0%8F%E7%BB%93.png"                      alt="img"                ></p><h2 id="2-3-Producer"><a href="#2-3-Producer" class="headerlink" title="2.3 Producer"></a>2.3 Producer</h2><p>消息生产者的代码都在client模块中，相对于RocketMQ来讲，消息生产者就是客户端，也是消息的提供者。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/DefaultMQProducer%E7%B1%BB%E5%9B%BE.png"                      alt="img"                ></p><p>###2.3.1 方法和属性</p><p>####1）主要方法介绍</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/MQAdmin.png"                      alt="img"                ></p><ul><li><pre><code class="java">//创建主题void createTopic(final String key, final String newTopic, final int queueNum) throws MQClientException;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //根据时间戳从队列中查找消息偏移量</span><br><span class="line">  long searchOffset(final MessageQueue mq, final long timestamp)</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="java">//查找消息队列中最大的偏移量long maxOffset(final MessageQueue mq) throws MQClientException;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //查找消息队列中最小的偏移量</span><br><span class="line">  long minOffset(final MessageQueue mq) </span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="java">//根据偏移量查找消息MessageExt viewMessage(final String offsetMsgId) throws RemotingException, MQBrokerException,        InterruptedException, MQClientException;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //根据条件查找消息</span><br><span class="line">  QueryResult queryMessage(final String topic, final String key, final int maxNum, final long begin,</span><br><span class="line">          final long end) throws MQClientException, InterruptedException;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="java">//根据消息ID和主题查找消息MessageExt viewMessage(String topic,String msgId) throws RemotingException, MQBrokerException, InterruptedException, MQClientException;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">![img](https://pchaoo.gitee.io/blog/img/rocketmq/MQProducer.png)</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //启动</span><br><span class="line">  void start() throws MQClientException;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="java">//关闭void shutdown();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //查找该主题下所有消息</span><br><span class="line">  List&lt;MessageQueue&gt; fetchPublishMessageQueues(final String topic) throws MQClientException;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="java">//同步发送消息SendResult send(final Message msg) throws MQClientException, RemotingException, MQBrokerException,        InterruptedException;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //同步超时发送消息</span><br><span class="line">  SendResult send(final Message msg, final long timeout) throws MQClientException,</span><br><span class="line">          RemotingException, MQBrokerException, InterruptedException;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="java">//异步发送消息void send(final Message msg, final SendCallback sendCallback) throws MQClientException,        RemotingException, InterruptedException;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //异步超时发送消息</span><br><span class="line">  void send(final Message msg, final SendCallback sendCallback, final long timeout)</span><br><span class="line">      throws MQClientException, RemotingException, InterruptedException;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="java">//发送单向消息void sendOneway(final Message msg) throws MQClientException, RemotingException,    InterruptedException;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //选择指定队列同步发送消息</span><br><span class="line">  SendResult send(final Message msg, final MessageQueue mq) throws MQClientException,</span><br><span class="line">      RemotingException, MQBrokerException, InterruptedException;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="java">//选择指定队列异步发送消息void send(final Message msg, final MessageQueue mq, final SendCallback sendCallback)    throws MQClientException, RemotingException, InterruptedException;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //选择指定队列单项发送消息</span><br><span class="line">  void sendOneway(final Message msg, final MessageQueue mq) throws MQClientException,</span><br><span class="line">      RemotingException, InterruptedException;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;批量发送消息<br>SendResult send(final Collection<Message> msgs) throws MQClientException, RemotingException, MQBrokerException,InterruptedException;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">\####2）属性介绍</span><br><span class="line"></span><br><span class="line">![img](https://pchaoo.gitee.io/blog/img/rocketmq/DefaultMQProducer%E5%B1%9E%E6%80%A7.png)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">producerGroup：生产者所属组</span><br><span class="line">createTopicKey：默认Topic</span><br><span class="line">defaultTopicQueueNums：默认主题在每一个Broker队列数量</span><br><span class="line">sendMsgTimeout：发送消息默认超时时间，默认3s</span><br><span class="line">compressMsgBodyOverHowmuch：消息体超过该值则启用压缩，默认4k</span><br><span class="line">retryTimesWhenSendFailed：同步方式发送消息重试次数，默认为2，总共执行3次</span><br><span class="line">retryTimesWhenSendAsyncFailed：异步方法发送消息重试次数，默认为2</span><br><span class="line">retryAnotherBrokerWhenNotStoreOK：消息重试时选择另外一个Broker时，是否不等待存储结果就返回，默认为false</span><br><span class="line">maxMessageSize：允许发送的最大消息长度，默认为4M</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-2-启动流程"><a href="#2-3-2-启动流程" class="headerlink" title="2.3.2 启动流程"></a>2.3.2 启动流程</h3><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E7%94%9F%E4%BA%A7%E8%80%85%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png"                      alt="img"                ></p><p><em><strong>代码：DefaultMQProducerImpl#start</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查生产者组是否满足要求</span></span><br><span class="line"><span class="built_in">this</span>.checkConfig();</span><br><span class="line"><span class="comment">//更改当前instanceName为进程ID</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得MQ客户端实例</span></span><br><span class="line"><span class="built_in">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="built_in">this</span>.defaultMQProducer, rpcHook);</span><br></pre></td></tr></table></figure><blockquote><p>整个JVM中只存在一个MQClientManager实例，维护一个MQClientInstance缓存表</p><p>ConcurrentMap&lt;String&#x2F;* clientId *&#x2F;, MQClientInstance&gt; factoryTable &#x3D; new ConcurrentHashMap&lt;String,MQClientInstance&gt;();</p><p>同一个clientId只会创建一个MQClientInstance。</p><p>MQClientInstance封装了RocketMQ网络处理API，是消息生产者和消息消费者与NameServer、Broker打交道的网络通道</p></blockquote><p><em><strong>代码：MQClientManager#getAndCreateMQClientInstance</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MQClientInstance <span class="title function_">getAndCreateMQClientInstance</span><span class="params">(<span class="keyword">final</span> ClientConfig clientConfig, </span></span><br><span class="line"><span class="params">                                                     RPCHook rpcHook)</span> &#123;</span><br><span class="line">    <span class="comment">//构建客户端ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> clientConfig.buildMQClientId();</span><br><span class="line">    <span class="comment">//根据客户端ID或者客户端实例</span></span><br><span class="line">    <span class="type">MQClientInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryTable.get(clientId);</span><br><span class="line">    <span class="comment">//实例如果为空就创建新的实例,并添加到实例表中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">        instance =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MQClientInstance</span>(clientConfig.cloneClientConfig(),</span><br><span class="line">                <span class="built_in">this</span>.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class="line">        <span class="type">MQClientInstance</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryTable.putIfAbsent(clientId, instance);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = prev;</span><br><span class="line">            log.warn(<span class="string">&quot;Returned Previous MQClientInstance for clientId:[&#123;&#125;]&quot;</span>, clientId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Created new MQClientInstance for clientId:[&#123;&#125;]&quot;</span>, clientId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMQProducerImpl#start</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册当前生产者到到MQClientInstance管理中,方便后续调用网路请求</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">registerOK</span> <span class="operator">=</span> mQClientFactory.registerProducer(<span class="built_in">this</span>.defaultMQProducer.getProducerGroup(), <span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">    <span class="built_in">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;The producer group[&quot;</span> + <span class="built_in">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">        + <span class="string">&quot;] has been created before, specify another name please.&quot;</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">        <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动生产者</span></span><br><span class="line"><span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">    mQClientFactory.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-消息发送"><a href="#2-3-3-消息发送" class="headerlink" title="2.3.3 消息发送"></a>2.3.3 消息发送</h3><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81.png"                      alt="img"                ></p><p><em><strong>代码：DefaultMQProducerImpl#send(Message msg)</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息</span></span><br><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> send(msg, <span class="built_in">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMQProducerImpl#send(Message msg,long timeout)</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息,默认超时时间为3s</span></span><br><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(Message msg,<span class="type">long</span> timeout)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class="literal">null</span>, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMQProducerImpl#sendDefaultImpl</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//校验消息</span></span><br><span class="line">Validators.checkMessage(msg, <span class="built_in">this</span>.defaultMQProducer);</span><br></pre></td></tr></table></figure><p>####1）验证消息</p><p><em><strong>代码：Validators#checkMessage</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkMessage</span><span class="params">(Message msg, DefaultMQProducer defaultMQProducer)</span></span><br><span class="line">    <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == msg) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(ResponseCode.MESSAGE_ILLEGAL, <span class="string">&quot;the message is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验主题</span></span><br><span class="line">    Validators.checkTopic(msg.getTopic());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验消息体</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == msg.getBody()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(ResponseCode.MESSAGE_ILLEGAL, <span class="string">&quot;the message body is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == msg.getBody().length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(ResponseCode.MESSAGE_ILLEGAL, <span class="string">&quot;the message body length is zero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg.getBody().length &gt; defaultMQProducer.getMaxMessageSize()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(ResponseCode.MESSAGE_ILLEGAL,</span><br><span class="line">            <span class="string">&quot;the message body size over max value, MAX: &quot;</span> + defaultMQProducer.getMaxMessageSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####2）查找路由</p><p><em><strong>代码：DefaultMQProducerImpl#tryToFindTopicPublishInfo</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TopicPublishInfo <span class="title function_">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> &#123;</span><br><span class="line">    <span class="comment">//从缓存中获得主题的路由信息</span></span><br><span class="line">    <span class="type">TopicPublishInfo</span> <span class="variable">topicPublishInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    <span class="comment">//路由信息为空,则从NameServer获取路由</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> <span class="title class_">TopicPublishInfo</span>());</span><br><span class="line">        <span class="built_in">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">        topicPublishInfo = <span class="built_in">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果未找到当前主题的路由信息,则用默认主题继续查找</span></span><br><span class="line">        <span class="built_in">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="literal">true</span>, <span class="built_in">this</span>.defaultMQProducer);</span><br><span class="line">        topicPublishInfo = <span class="built_in">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/Topic%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF.png"                      alt="img"                ></p><p><em><strong>代码：TopicPublishInfo</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicPublishInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">orderTopic</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//是否是顺序消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">haveTopicRouterInfo</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;();<span class="comment">//该主题消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">ThreadLocalIndex</span> <span class="variable">sendWhichQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalIndex</span>();<span class="comment">//每选择一次消息队列,该值+1</span></span><br><span class="line">    <span class="keyword">private</span> TopicRouteData topicRouteData;<span class="comment">//关联Topic路由元信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TopicRouteData topicRouteData;</span><br><span class="line"><span class="comment">//使用默认主题从NameServer获取路由信息</span></span><br><span class="line"><span class="keyword">if</span> (isDefault &amp;&amp; defaultMQProducer != <span class="literal">null</span>) &#123;</span><br><span class="line">    topicRouteData = <span class="built_in">this</span>.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),</span><br><span class="line">        <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (QueueData data : topicRouteData.getQueueDatas()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">queueNums</span> <span class="operator">=</span> Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());</span><br><span class="line">            data.setReadQueueNums(queueNums);</span><br><span class="line">            data.setWriteQueueNums(queueNums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//使用指定主题从NameServer获取路由信息</span></span><br><span class="line">    topicRouteData = <span class="built_in">this</span>.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断路由是否需要更改</span></span><br><span class="line"><span class="type">TopicRouteData</span> <span class="variable">old</span> <span class="operator">=</span> <span class="built_in">this</span>.topicRouteTable.get(topic);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> topicRouteDataIsChange(old, topicRouteData);</span><br><span class="line"><span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">    changed = <span class="built_in">this</span>.isNeedUpdateTopicRouteInfo(topic);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;the topic[&#123;&#125;] route info changed, old[&#123;&#125;] ,new[&#123;&#125;]&quot;</span>, topic, old, topicRouteData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (changed) &#123;</span><br><span class="line">    <span class="comment">//将topicRouteData转换为发布队列</span></span><br><span class="line">    <span class="type">TopicPublishInfo</span> <span class="variable">publishInfo</span> <span class="operator">=</span> topicRouteData2TopicPublishInfo(topic, topicRouteData);</span><br><span class="line">    publishInfo.setHaveTopicRouterInfo(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//遍历生产</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, MQProducerInner&gt;&gt; it = <span class="built_in">this</span>.producerTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, MQProducerInner&gt; entry = it.next();</span><br><span class="line">        <span class="type">MQProducerInner</span> <span class="variable">impl</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//生产者不为空时,更新publishInfo信息</span></span><br><span class="line">            impl.updateTopicPublishInfo(topic, publishInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：MQClientInstance#topicRouteData2TopicPublishInfo</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TopicPublishInfo <span class="title function_">topicRouteData2TopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> TopicRouteData route)</span> &#123;</span><br><span class="line">    <span class="comment">//创建TopicPublishInfo对象</span></span><br><span class="line">        <span class="type">TopicPublishInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPublishInfo</span>();</span><br><span class="line">    <span class="comment">//关联topicRoute</span></span><br><span class="line">        info.setTopicRouteData(route);</span><br><span class="line">    <span class="comment">//顺序消息,更新TopicPublishInfo</span></span><br><span class="line">        <span class="keyword">if</span> (route.getOrderTopicConf() != <span class="literal">null</span> &amp;&amp; route.getOrderTopicConf().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] brokers = route.getOrderTopicConf().split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String broker : brokers) &#123;</span><br><span class="line">                String[] item = broker.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> Integer.parseInt(item[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">                    <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(topic, item[<span class="number">0</span>], i);</span><br><span class="line">                    info.getMessageQueueList().add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            info.setOrderTopic(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非顺序消息更新TopicPublishInfo</span></span><br><span class="line">            List&lt;QueueData&gt; qds = route.getQueueDatas();</span><br><span class="line">            Collections.sort(qds);</span><br><span class="line">            <span class="comment">//遍历topic队列信息</span></span><br><span class="line">            <span class="keyword">for</span> (QueueData qd : qds) &#123;</span><br><span class="line">                <span class="comment">//是否是写队列</span></span><br><span class="line">                <span class="keyword">if</span> (PermName.isWriteable(qd.getPerm())) &#123;</span><br><span class="line">                    <span class="type">BrokerData</span> <span class="variable">brokerData</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//遍历写队列Broker</span></span><br><span class="line">                    <span class="keyword">for</span> (BrokerData bd : route.getBrokerDatas()) &#123;</span><br><span class="line">                        <span class="comment">//根据名称获得读队列对应的Broker</span></span><br><span class="line">                        <span class="keyword">if</span> (bd.getBrokerName().equals(qd.getBrokerName())) &#123;</span><br><span class="line">                        brokerData = bd;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == brokerData) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!brokerData.getBrokerAddrs().containsKey(MixAll.MASTER_ID)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//封装TopicPublishInfo写队列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; qd.getWriteQueueNums(); i++) &#123;</span><br><span class="line">                    <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(topic, qd.getBrokerName(), i);</span><br><span class="line">                    info.getMessageQueueList().add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        info.setOrderTopic(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回TopicPublishInfo对象</span></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）选择队列"><a href="#3）选择队列" class="headerlink" title="3）选择队列"></a>3）选择队列</h4><ul><li>默认不启用Broker故障延迟机制</li></ul><p><em><strong>代码：TopicPublishInfo#selectOneMessageQueue(lastBrokerName)</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MessageQueue <span class="title function_">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> &#123;</span><br><span class="line">    <span class="comment">//第一次选择队列</span></span><br><span class="line">    <span class="keyword">if</span> (lastBrokerName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//sendWhichQueue</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">        <span class="comment">//遍历消息队列集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//sendWhichQueue自增后取模</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> Math.abs(index++) % <span class="built_in">this</span>.messageQueueList.size();</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//规避上次Broker队列</span></span><br><span class="line">            <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> <span class="built_in">this</span>.messageQueueList.get(pos);</span><br><span class="line">            <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果以上情况都不满足,返回sendWhichQueue取模后的队列</span></span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：TopicPublishInfo#selectOneMessageQueue()</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次选择队列</span></span><br><span class="line"><span class="keyword">public</span> MessageQueue <span class="title function_">selectOneMessageQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//sendWhichQueue自增</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">    <span class="comment">//对队列大小取模</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> Math.abs(index) % <span class="built_in">this</span>.messageQueueList.size();</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//返回对应的队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.messageQueueList.get(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启用Broker故障延迟机制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MessageQueue <span class="title function_">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> &#123;</span><br><span class="line">    <span class="comment">//Broker故障延迟机制</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//对sendWhichQueue自增</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">            <span class="comment">//对消息队列轮询获取一个队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">                <span class="comment">//验证该队列是否可用</span></span><br><span class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                    <span class="comment">//可用</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                        <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//从规避的Broker中选择一个可用的Broker</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">notBestBroker</span> <span class="operator">=</span> latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">            <span class="comment">//获得Broker的写队列集合</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">writeQueueNums</span> <span class="operator">=</span> tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//获得一个队列,指定broker和队列ID并返回</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">                <span class="keyword">if</span> (notBestBroker != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mq.setBrokerName(notBestBroker);</span><br><span class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Error occurred when selecting message queue&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/Broker%E6%95%85%E9%9A%9C%E5%BB%B6%E8%BF%9F%E6%9C%BA%E5%88%B6%E6%A0%B8%E5%BF%83%E7%B1%BB.png"                      alt="img"                ></p><ul><li>延迟机制接口规范</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LatencyFaultTolerance</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//更新失败条目</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateFaultItem</span><span class="params">(<span class="keyword">final</span> T name, <span class="keyword">final</span> <span class="type">long</span> currentLatency, <span class="keyword">final</span> <span class="type">long</span> notAvailableDuration)</span>;</span><br><span class="line"><span class="comment">//判断Broker是否可用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAvailable</span><span class="params">(<span class="keyword">final</span> T name)</span>;</span><br><span class="line"><span class="comment">//移除Fault条目</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="keyword">final</span> T name)</span>;</span><br><span class="line"><span class="comment">//尝试从规避的Broker中选择一个可用的Broker</span></span><br><span class="line">    T <span class="title function_">pickOneAtLeast</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FaultItem：失败条目</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FaultItem</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;FaultItem&gt; &#123;</span><br><span class="line">    <span class="comment">//条目唯一键,这里为brokerName</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//本次消息发送延迟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> currentLatency;</span><br><span class="line">    <span class="comment">//故障规避开始时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> startTimestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消息失败策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQFaultStrategy</span> &#123;</span><br><span class="line">   <span class="comment">//根据currentLatency本地消息发送延迟,从latencyMax尾部向前找到第一个比currentLatency小的索引,如果没有找到,返回0</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span>[] latencyMax = &#123;<span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</span><br><span class="line">    <span class="comment">//根据这个索引从notAvailableDuration取出对应的时间,在该时长内,Broker设置为不可用</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span>[] notAvailableDuration = &#123;<span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>原理分析</strong></em></p><p><em><strong>代码：DefaultMQProducerImpl#sendDefaultImpl</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sendResult = <span class="built_in">this</span>.sendKernelImpl(msg, </span><br><span class="line">                                 mq, </span><br><span class="line">                                 communicationMode, </span><br><span class="line">                                 sendCallback, </span><br><span class="line">                                 topicPublishInfo, </span><br><span class="line">                                 timeout - costTime);</span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"><span class="built_in">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>如果上述发送过程出现异常，则调用<code>DefaultMQProducerImpl#updateFaultItem</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="type">long</span> currentLatency, <span class="type">boolean</span> isolation)</span> &#123;</span><br><span class="line">    <span class="comment">//参数一：broker名称</span></span><br><span class="line">    <span class="comment">//参数二:本次消息发送延迟时间</span></span><br><span class="line">    <span class="comment">//参数三:是否隔离</span></span><br><span class="line">    <span class="built_in">this</span>.mqFaultStrategy.updateFaultItem(brokerName, currentLatency, isolation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：MQFaultStrategy#updateFaultItem</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="type">long</span> currentLatency, <span class="type">boolean</span> isolation)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="comment">//计算broker规避的时长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> computeNotAvailableDuration(isolation ? <span class="number">30000</span> : currentLatency);</span><br><span class="line">        <span class="comment">//更新该FaultItem规避时长</span></span><br><span class="line">        <span class="built_in">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：MQFaultStrategy#computeNotAvailableDuration</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">computeNotAvailableDuration</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> currentLatency)</span> &#123;</span><br><span class="line">    <span class="comment">//遍历latencyMax</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> latencyMax.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//找到第一个比currentLatency的latencyMax值</span></span><br><span class="line">        <span class="keyword">if</span> (currentLatency &gt;= latencyMax[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.notAvailableDuration[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有找到则返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：LatencyFaultToleranceImpl#updateFaultItem</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="type">long</span> currentLatency, <span class="keyword">final</span> <span class="type">long</span> notAvailableDuration)</span> &#123;</span><br><span class="line">    <span class="comment">//获得原FaultItem</span></span><br><span class="line">    <span class="type">FaultItem</span> <span class="variable">old</span> <span class="operator">=</span> <span class="built_in">this</span>.faultItemTable.get(name);</span><br><span class="line">    <span class="comment">//为空新建faultItem对象,设置规避时长和开始时间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == old) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">FaultItem</span> <span class="variable">faultItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FaultItem</span>(name);</span><br><span class="line">        faultItem.setCurrentLatency(currentLatency);</span><br><span class="line">        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">        old = <span class="built_in">this</span>.faultItemTable.putIfAbsent(name, faultItem);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            old.setCurrentLatency(currentLatency);</span><br><span class="line">            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//更新规避时长和开始时间</span></span><br><span class="line">        old.setCurrentLatency(currentLatency);</span><br><span class="line">        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####4）发送消息</p><p>消息发送API核心入口<em><strong>DefaultMQProducerImpl#sendKernelImpl</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendKernelImpl</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> Message msg,//待发送消息</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> MessageQueue mq,//消息发送队列</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> CommunicationMode communicationMode,//消息发送内模式</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> SendCallback sendCallback,pp//异步消息回调函数</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,//主题路由信息</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> <span class="type">long</span> timeout//超时时间</span></span><br><span class="line"><span class="params">    )</span></span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMQProducerImpl#sendKernelImpl</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得broker网络地址信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">brokerAddr</span> <span class="operator">=</span> <span class="built_in">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == brokerAddr) &#123;</span><br><span class="line">    <span class="comment">//没有找到从NameServer更新broker网络地址信息</span></span><br><span class="line">    tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">    brokerAddr = <span class="built_in">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为消息分类唯一ID</span></span><br><span class="line"><span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">    MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">topicWithNamespace</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != <span class="built_in">this</span>.mQClientFactory.getClientConfig().getNamespace()) &#123;</span><br><span class="line">    msg.setInstanceId(<span class="built_in">this</span>.mQClientFactory.getClientConfig().getNamespace());</span><br><span class="line">    topicWithNamespace = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消息大小超过4K,启用消息压缩</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sysFlag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">msgBodyCompressed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">    msgBodyCompressed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是事务消息,设置消息标记MessageSysFlag.TRANSACTION_PREPARED_TYPE</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">tranMsg</span> <span class="operator">=</span> msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"><span class="keyword">if</span> (tranMsg != <span class="literal">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果注册了消息发送钩子函数,在执行消息发送前的增强逻辑</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">    context = <span class="keyword">new</span> <span class="title class_">SendMessageContext</span>();</span><br><span class="line">    context.setProducer(<span class="built_in">this</span>);</span><br><span class="line">    context.setProducerGroup(<span class="built_in">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    context.setCommunicationMode(communicationMode);</span><br><span class="line">    context.setBornHost(<span class="built_in">this</span>.defaultMQProducer.getClientIP());</span><br><span class="line">    context.setBrokerAddr(brokerAddr);</span><br><span class="line">    context.setMessage(msg);</span><br><span class="line">    context.setMq(mq);</span><br><span class="line">    context.setNamespace(<span class="built_in">this</span>.defaultMQProducer.getNamespace());</span><br><span class="line">    <span class="type">String</span> <span class="variable">isTrans</span> <span class="operator">=</span> msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">    <span class="keyword">if</span> (isTrans != <span class="literal">null</span> &amp;&amp; isTrans.equals(<span class="string">&quot;true&quot;</span>)) &#123;</span><br><span class="line">        context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg.getProperty(<span class="string">&quot;__STARTDELIVERTIME&quot;</span>) != <span class="literal">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="literal">null</span>) &#123;</span><br><span class="line">        context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：SendMessageHook</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SendMessageHook</span> &#123;</span><br><span class="line">    String <span class="title function_">hookName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessageBefore</span><span class="params">(<span class="keyword">final</span> SendMessageContext context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessageAfter</span><span class="params">(<span class="keyword">final</span> SendMessageContext context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMQProducerImpl#sendKernelImpl</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建消息发送请求包</span></span><br><span class="line"><span class="type">SendMessageRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendMessageRequestHeader</span>();</span><br><span class="line"><span class="comment">//生产者组</span></span><br><span class="line">requestHeader.setProducerGroup(<span class="built_in">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line"><span class="comment">//主题</span></span><br><span class="line">requestHeader.setTopic(msg.getTopic());</span><br><span class="line"><span class="comment">//默认创建主题Key</span></span><br><span class="line">requestHeader.setDefaultTopic(<span class="built_in">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line"><span class="comment">//该主题在单个Broker默认队列树</span></span><br><span class="line">requestHeader.setDefaultTopicQueueNums(<span class="built_in">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line"><span class="comment">//队列ID</span></span><br><span class="line">requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line"><span class="comment">//消息系统标记</span></span><br><span class="line">requestHeader.setSysFlag(sysFlag);</span><br><span class="line"><span class="comment">//消息发送时间</span></span><br><span class="line">requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line"><span class="comment">//消息标记</span></span><br><span class="line">requestHeader.setFlag(msg.getFlag());</span><br><span class="line"><span class="comment">//消息扩展信息</span></span><br><span class="line">requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"><span class="comment">//消息重试次数</span></span><br><span class="line">requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">requestHeader.setUnitMode(<span class="built_in">this</span>.isUnitMode());</span><br><span class="line"><span class="comment">//是否是批量消息等</span></span><br><span class="line">requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line"><span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">reconsumeTimes</span> <span class="operator">=</span> MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">    <span class="keyword">if</span> (reconsumeTimes != <span class="literal">null</span>) &#123;</span><br><span class="line">        requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">maxReconsumeTimes</span> <span class="operator">=</span> MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">    <span class="keyword">if</span> (maxReconsumeTimes != <span class="literal">null</span>) &#123;</span><br><span class="line">        requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ASYNC:<span class="comment">//异步发送</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">tmpMessage</span> <span class="operator">=</span> msg;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">messageCloned</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (msgBodyCompressed) &#123;</span><br><span class="line">        <span class="comment">//If msg body was compressed, msgbody should be reset using prevBody.</span></span><br><span class="line">        <span class="comment">//Clone new message using commpressed message body and recover origin massage.</span></span><br><span class="line">        <span class="comment">//Fix bug:https://github.com/apache/rocketmq-externals/issues/66</span></span><br><span class="line">        tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">        messageCloned = <span class="literal">true</span>;</span><br><span class="line">        msg.setBody(prevBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicWithNamespace) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!messageCloned) &#123;</span><br><span class="line">            tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">            messageCloned = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), </span><br><span class="line">                                                    <span class="built_in">this</span>.defaultMQProducer.getNamespace()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">costTimeAsync</span> <span class="operator">=</span> System.currentTimeMillis() - beginStartTime;</span><br><span class="line"><span class="keyword">if</span> (timeout &lt; costTimeAsync) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemotingTooMuchRequestException</span>(<span class="string">&quot;sendKernelImpl call timeout&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">sendResult = <span class="built_in">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">        brokerAddr,</span><br><span class="line">        mq.getBrokerName(),</span><br><span class="line">        tmpMessage,</span><br><span class="line">        requestHeader,</span><br><span class="line">        timeout - costTimeAsync,</span><br><span class="line">        communicationMode,</span><br><span class="line">        sendCallback,</span><br><span class="line">        topicPublishInfo,</span><br><span class="line">        <span class="built_in">this</span>.mQClientFactory,</span><br><span class="line">        <span class="built_in">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</span><br><span class="line">        context,</span><br><span class="line">        <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ONEWAY:</span><br><span class="line"><span class="keyword">case</span> SYNC:<span class="comment">//同步发送</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">costTimeSync</span> <span class="operator">=</span> System.currentTimeMillis() - beginStartTime;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; costTimeSync) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemotingTooMuchRequestException</span>(<span class="string">&quot;sendKernelImpl call timeout&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sendResult = <span class="built_in">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">            brokerAddr,</span><br><span class="line">            mq.getBrokerName(),</span><br><span class="line">            msg,</span><br><span class="line">            requestHeader,</span><br><span class="line">            timeout - costTimeSync,</span><br><span class="line">            communicationMode,</span><br><span class="line">            context,</span><br><span class="line">            <span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果注册了钩子函数,则发送完毕后执行钩子函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">    context.setSendResult(sendResult);</span><br><span class="line">    <span class="built_in">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-批量消息发送"><a href="#2-3-4-批量消息发送" class="headerlink" title="2.3.4 批量消息发送"></a>2.3.4 批量消息发送</h3><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E5%8F%91%E9%80%81%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF.png"                      alt="img"                ></p><p>批量消息发送是将同一个主题的多条消息一起打包发送到消息服务端，减少网络调用次数，提高网络传输效率。当然，并不是在同一批次中发送的消息数量越多越好，其判断依据是单条消息的长度，如果单条消息内容比较长，则打包多条消息发送会影响其他线程发送消息的响应时间，并且单批次消息总长度不能超过DefaultMQProducer#maxMessageSize。</p><p>批量消息发送要解决的问题是如何将这些消息编码以便服务端能够正确解码出每条消息的消息内容。</p><p><em><strong>代码：DefaultMQProducer#send</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(Collection&lt;Message&gt; msgs)</span> </span><br><span class="line">    <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">//压缩消息集合成一条消息,然后发送出去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.defaultMQProducerImpl.send(batch(msgs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMQProducer#batch</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MessageBatch <span class="title function_">batch</span><span class="params">(Collection&lt;Message&gt; msgs)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">    MessageBatch msgBatch;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将集合消息封装到MessageBatch</span></span><br><span class="line">        msgBatch = MessageBatch.generateFromList(msgs);</span><br><span class="line">        <span class="comment">//遍历消息集合,检查消息合法性,设置消息ID,设置Topic</span></span><br><span class="line">        <span class="keyword">for</span> (Message message : msgBatch) &#123;</span><br><span class="line">            Validators.checkMessage(message, <span class="built_in">this</span>);</span><br><span class="line">            MessageClientIDSetter.setUniqID(message);</span><br><span class="line">            message.setTopic(withNamespace(message.getTopic()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//压缩消息,设置消息body</span></span><br><span class="line">        msgBatch.setBody(msgBatch.encode());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;Failed to initiate the MessageBatch&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置msgBatch的topic</span></span><br><span class="line">    msgBatch.setTopic(withNamespace(msgBatch.getTopic()));</span><br><span class="line">    <span class="keyword">return</span> msgBatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-消息存储"><a href="#2-4-消息存储" class="headerlink" title="2.4 消息存储"></a>2.4 消息存储</h2><p>###2.4.1 消息存储核心类</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/DefaultMessageStore.png"                      alt="img"                ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageStoreConfig messageStoreConfig;<span class="comment">//消息配置属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CommitLog commitLog;<span class="comment">//CommitLog文件存储的实现类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, ConcurrentMap&lt;Integer<span class="comment">/* queueId */</span>, ConsumeQueue&gt;&gt; consumeQueueTable;<span class="comment">//消息队列存储缓存表,按照消息主题分组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FlushConsumeQueueService flushConsumeQueueService;<span class="comment">//消息队列文件刷盘线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CleanCommitLogService cleanCommitLogService;<span class="comment">//清除CommitLog文件服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CleanConsumeQueueService cleanConsumeQueueService;<span class="comment">//清除ConsumerQueue队列文件服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IndexService indexService;<span class="comment">//索引实现类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AllocateMappedFileService allocateMappedFileService;<span class="comment">//MappedFile分配服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReputMessageService reputMessageService;<span class="comment">//CommitLog消息分发,根据CommitLog文件构建ConsumerQueue、IndexFile文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HAService haService;<span class="comment">//存储HA机制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduleMessageService scheduleMessageService;<span class="comment">//消息服务调度线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StoreStatsService storeStatsService;<span class="comment">//消息存储服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransientStorePool transientStorePool;<span class="comment">//消息堆外内存缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BrokerStatsManager brokerStatsManager;<span class="comment">//Broker状态管理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageArrivingListener messageArrivingListener;<span class="comment">//消息拉取长轮询模式消息达到监听器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BrokerConfig brokerConfig;<span class="comment">//Broker配置类</span></span><br><span class="line"><span class="keyword">private</span> StoreCheckpoint storeCheckpoint;<span class="comment">//文件刷盘监测点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;CommitLogDispatcher&gt; dispatcherList;<span class="comment">//CommitLog文件转发请求</span></span><br></pre></td></tr></table></figure><h3 id="2-4-2-消息存储流程"><a href="#2-4-2-消息存储流程" class="headerlink" title="2.4.2 消息存储流程"></a>2.4.2 消息存储流程</h3><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%B5%81%E7%A8%8B.png"                      alt="img"                ></p><p><em><strong>消息存储入口：DefaultMessageStore#putMessage</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断Broker角色如果是从节点,则无需写入</span></span><br><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE == <span class="built_in">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.printTimes.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> ((value % <span class="number">50000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;message store is slave mode, so putMessage is forbidden &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PutMessageResult</span>(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前写入状态如果是正在写入,则不能继续</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.runningFlags.isWriteable()) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.printTimes.getAndIncrement();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PutMessageResult</span>(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="literal">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.printTimes.set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断消息主题长度是否超过最大限制</span></span><br><span class="line"><span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;putMessage message topic length too long &quot;</span> + msg.getTopic().length());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PutMessageResult</span>(PutMessageStatus.MESSAGE_ILLEGAL, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断消息属性长度是否超过限制</span></span><br><span class="line"><span class="keyword">if</span> (msg.getPropertiesString() != <span class="literal">null</span> &amp;&amp; msg.getPropertiesString().length() &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;putMessage message properties length too long &quot;</span> + msg.getPropertiesString().length());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PutMessageResult</span>(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断系统PageCache缓存去是否占用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.isOSPageCacheBusy()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PutMessageResult</span>(PutMessageStatus.OS_PAGECACHE_BUSY, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息写入CommitLog文件</span></span><br><span class="line"><span class="type">PutMessageResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.commitLog.putMessage(msg);</span><br></pre></td></tr></table></figure><p><em><strong>代码：CommitLog#putMessage</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录消息存储时间</span></span><br><span class="line">msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断如果mappedFile如果为空或者已满,创建新的mappedFile文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">    mappedFile = <span class="built_in">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果创建失败,直接返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == mappedFile) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;create mapped file1 error, topic: &quot;</span> + msg.getTopic() + <span class="string">&quot; clientAddr: &quot;</span> + msg.getBornHostString());</span><br><span class="line">    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PutMessageResult</span>(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入消息到mappedFile中</span></span><br><span class="line">result = mappedFile.appendMessage(msg, <span class="built_in">this</span>.appendMessageCallback);</span><br></pre></td></tr></table></figure><p><em><strong>代码：MappedFile#appendMessagesInner</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得文件的写入指针</span></span><br><span class="line"><span class="type">int</span> <span class="variable">currentPos</span> <span class="operator">=</span> <span class="built_in">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果指针大于文件大小则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (currentPos &lt; <span class="built_in">this</span>.fileSize) &#123;</span><br><span class="line">    <span class="comment">//通过writeBuffer.slice()创建一个与MappedFile共享的内存区,并设置position为当前指针</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> writeBuffer != <span class="literal">null</span> ? writeBuffer.slice() : <span class="built_in">this</span>.mappedByteBuffer.slice();</span><br><span class="line">    byteBuffer.position(currentPos);</span><br><span class="line">    <span class="type">AppendMessageResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</span><br><span class="line">       <span class="comment">//通过回调方法写入</span></span><br><span class="line">        result = cb.doAppend(<span class="built_in">this</span>.getFileFromOffset(), byteBuffer, <span class="built_in">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</span><br><span class="line">        result = cb.doAppend(<span class="built_in">this</span>.getFileFromOffset(), byteBuffer, <span class="built_in">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppendMessageResult</span>(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">    <span class="built_in">this</span>.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：CommitLog#doAppend</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件写入位置</span></span><br><span class="line"><span class="type">long</span> <span class="variable">wroteOffset</span> <span class="operator">=</span> fileFromOffset + byteBuffer.position();</span><br><span class="line"><span class="comment">//设置消息ID</span></span><br><span class="line"><span class="built_in">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">msgId</span> <span class="operator">=</span> MessageDecoder.createMessageId(<span class="built_in">this</span>.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得该消息在消息队列中的偏移量</span></span><br><span class="line">keyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">keyBuilder.append(msgInner.getTopic());</span><br><span class="line">keyBuilder.append(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">keyBuilder.append(msgInner.getQueueId());</span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyBuilder.toString();</span><br><span class="line"><span class="type">Long</span> <span class="variable">queueOffset</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.topicQueueTable.get(key);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == queueOffset) &#123;</span><br><span class="line">    queueOffset = <span class="number">0L</span>;</span><br><span class="line">    CommitLog.<span class="built_in">this</span>.topicQueueTable.put(key, queueOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得消息属性长度</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">byte</span>[] propertiesData =msgInner.getPropertiesString() == <span class="literal">null</span> ? <span class="literal">null</span> : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">propertiesLength</span> <span class="operator">=</span> propertiesData == <span class="literal">null</span> ? <span class="number">0</span> : propertiesData.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;putMessage message properties length too long. length=&#123;&#125;&quot;</span>, propertiesData.length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppendMessageResult</span>(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得消息主题大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">topicLength</span> <span class="operator">=</span> topicData.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得消息体大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">bodyLength</span> <span class="operator">=</span> msgInner.getBody() == <span class="literal">null</span> ? <span class="number">0</span> : msgInner.getBody().length;</span><br><span class="line"><span class="comment">//计算消息总长度</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">msgLen</span> <span class="operator">=</span> calMsgLength(bodyLength, topicLength, propertiesLength);</span><br></pre></td></tr></table></figure><p><em><strong>代码：CommitLog#calMsgLength</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calMsgLength</span><span class="params">(<span class="type">int</span> bodyLength, <span class="type">int</span> topicLength, <span class="type">int</span> propertiesLength)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">msgLen</span> <span class="operator">=</span> <span class="number">4</span> <span class="comment">//TOTALSIZE</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//MAGICCODE  </span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//BODYCRC</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//QUEUEID</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//FLAG</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//QUEUEOFFSET</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//PHYSICALOFFSET</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//SYSFLAG</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//BORNTIMESTAMP</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//BORNHOST</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//STORETIMESTAMP</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//STOREHOSTADDRESS</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//RECONSUMETIMES</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//Prepared Transaction Offset</span></span><br><span class="line">        + <span class="number">4</span> + (bodyLength &gt; <span class="number">0</span> ? bodyLength : <span class="number">0</span>) <span class="comment">//BODY</span></span><br><span class="line">        + <span class="number">1</span> + topicLength <span class="comment">//TOPIC</span></span><br><span class="line">        + <span class="number">2</span> + (propertiesLength &gt; <span class="number">0</span> ? propertiesLength : <span class="number">0</span>) <span class="comment">//propertiesLength</span></span><br><span class="line">        + <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> msgLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：CommitLog#doAppend</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息长度不能超过4M</span></span><br><span class="line"><span class="keyword">if</span> (msgLen &gt; <span class="built_in">this</span>.maxMessageSize) &#123;</span><br><span class="line">    CommitLog.log.warn(<span class="string">&quot;message size exceeded, msg total size: &quot;</span> + msgLen + <span class="string">&quot;, msg body size: &quot;</span> + bodyLength</span><br><span class="line">        + <span class="string">&quot;, maxMessageSize: &quot;</span> + <span class="built_in">this</span>.maxMessageSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppendMessageResult</span>(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息是如果没有足够的存储空间则新创建CommitLog文件</span></span><br><span class="line"><span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</span><br><span class="line">    <span class="built_in">this</span>.resetByteBuffer(<span class="built_in">this</span>.msgStoreItemMemory, maxBlank);</span><br><span class="line">    <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">    <span class="built_in">this</span>.msgStoreItemMemory.putInt(maxBlank);</span><br><span class="line">    <span class="comment">// 2 MAGICCODE</span></span><br><span class="line">    <span class="built_in">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</span><br><span class="line">    <span class="comment">// 3 The remaining space may be any value</span></span><br><span class="line">    <span class="comment">// Here the length of the specially set maxBlank</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">beginTimeMills</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.now();</span><br><span class="line">    byteBuffer.put(<span class="built_in">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppendMessageResult</span>(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</span><br><span class="line">        queueOffset, CommitLog.<span class="built_in">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息存储到ByteBuffer中,返回AppendMessageResult</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">beginTimeMills</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.now();</span><br><span class="line"><span class="comment">// Write messages to the queue buffer</span></span><br><span class="line">byteBuffer.put(<span class="built_in">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, msgLen);</span><br><span class="line"><span class="type">AppendMessageResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppendMessageResult</span>(AppendMessageStatus.PUT_OK, wroteOffset, </span><br><span class="line">                                                     msgLen, msgId,msgInner.getStoreTimestamp(), </span><br><span class="line">                                                     queueOffset, </span><br><span class="line">                                                     CommitLog.<span class="built_in">this</span>.defaultMessageStore.now() </span><br><span class="line">                                                     -beginTimeMills);</span><br><span class="line"><span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">        <span class="comment">//更新消息队列偏移量</span></span><br><span class="line">        CommitLog.<span class="built_in">this</span>.topicQueueTable.put(key, ++queueOffset);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：CommitLog#putMessage</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">putMessageLock.unlock();</span><br><span class="line"><span class="comment">//刷盘</span></span><br><span class="line">handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line"><span class="comment">//执行HA主从同步</span></span><br><span class="line">handleHA(result, putMessageResult, msg);</span><br></pre></td></tr></table></figure><h3 id="2-4-3-存储文件"><a href="#2-4-3-存储文件" class="headerlink" title="2.4.3 存储文件"></a>2.4.3 存储文件</h3><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6.png"                      alt="img"                ></p><ul><li>commitLog：消息存储目录</li><li>config：运行期间一些配置信息</li><li>consumerqueue：消息消费队列存储目录</li><li>index：消息索引文件存储目录</li><li>abort：如果存在改文件寿命Broker非正常关闭</li><li>checkpoint：文件检查点，存储CommitLog文件最后一次刷盘时间戳、consumerquueue最后一次刷盘时间，index索引文件最后一次刷盘时间戳。</li></ul><h3 id="2-4-4-存储文件内存映射"><a href="#2-4-4-存储文件内存映射" class="headerlink" title="2.4.4 存储文件内存映射"></a>2.4.4 存储文件内存映射</h3><p>RocketMQ通过使用内存映射文件提高IO访问性能，无论是CommitLog、ConsumerQueue还是IndexFile，单个文件都被设计为固定长度，如果一个文件写满以后再创建一个新文件，文件名就为该文件第一条消息对应的全局物理偏移量。</p><p>####1）MappedFileQueue</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/MappedFileQueue.png"                      alt="img"                ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String storePath;<span class="comment">//存储目录</span></span><br><span class="line"><span class="type">int</span> mappedFileSize;<span class="comment">// 单个文件大小</span></span><br><span class="line">CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles;<span class="comment">//MappedFile文件集合</span></span><br><span class="line">AllocateMappedFileService allocateMappedFileService;<span class="comment">//创建MapFile服务类</span></span><br><span class="line"><span class="type">long</span> <span class="variable">flushedWhere</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前刷盘指针</span></span><br><span class="line"><span class="type">long</span> <span class="variable">committedWhere</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前数据提交指针,内存中ByteBuffer当前的写指针,该值大于等于flushWhere</span></span><br></pre></td></tr></table></figure><ul><li>根据存储时间查询MappedFile</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MappedFile <span class="title function_">getMappedFileByTime</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> timestamp)</span> &#123;</span><br><span class="line">    Object[] mfs = <span class="built_in">this</span>.copyMappedFiles(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == mfs)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//遍历MappedFile文件数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mfs.length; i++) &#123;</span><br><span class="line">        <span class="type">MappedFile</span> <span class="variable">mappedFile</span> <span class="operator">=</span> (MappedFile) mfs[i];</span><br><span class="line">        <span class="comment">//MappedFile文件的最后修改时间大于指定时间戳则返回该文件</span></span><br><span class="line">        <span class="keyword">if</span> (mappedFile.getLastModifiedTimestamp() &gt;= timestamp) &#123;</span><br><span class="line">            <span class="keyword">return</span> mappedFile;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (MappedFile) mfs[mfs.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据消息偏移量offset查找MappedFile</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MappedFile <span class="title function_">findMappedFileByOffset</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> offset, <span class="keyword">final</span> <span class="type">boolean</span> returnFirstOnNotFound)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获得第一个MappedFile文件</span></span><br><span class="line">        <span class="type">MappedFile</span> <span class="variable">firstMappedFile</span> <span class="operator">=</span> <span class="built_in">this</span>.getFirstMappedFile();</span><br><span class="line">        <span class="comment">//获得最后一个MappedFile文件</span></span><br><span class="line">        <span class="type">MappedFile</span> <span class="variable">lastMappedFile</span> <span class="operator">=</span> <span class="built_in">this</span>.getLastMappedFile();</span><br><span class="line">        <span class="comment">//第一个文件和最后一个文件均不为空,则进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (firstMappedFile != <span class="literal">null</span> &amp;&amp; lastMappedFile != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (offset &lt; firstMappedFile.getFileFromOffset() || </span><br><span class="line">                offset &gt;= lastMappedFile.getFileFromOffset() + <span class="built_in">this</span>.mappedFileSize) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获得文件索引</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) ((offset / <span class="built_in">this</span>.mappedFileSize) </span><br><span class="line">                                   - (firstMappedFile.getFileFromOffset() / <span class="built_in">this</span>.mappedFileSize));</span><br><span class="line">                <span class="type">MappedFile</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//根据索引返回目标文件</span></span><br><span class="line">                    targetFile = <span class="built_in">this</span>.mappedFiles.get(index);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (targetFile != <span class="literal">null</span> &amp;&amp; offset &gt;= targetFile.getFileFromOffset()</span><br><span class="line">                    &amp;&amp; offset &lt; targetFile.getFileFromOffset() + <span class="built_in">this</span>.mappedFileSize) &#123;</span><br><span class="line">                    <span class="keyword">return</span> targetFile;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (MappedFile tmpMappedFile : <span class="built_in">this</span>.mappedFiles) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (offset &gt;= tmpMappedFile.getFileFromOffset()</span><br><span class="line">                        &amp;&amp; offset &lt; tmpMappedFile.getFileFromOffset() + <span class="built_in">this</span>.mappedFileSize) &#123;</span><br><span class="line">                        <span class="keyword">return</span> tmpMappedFile;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (returnFirstOnNotFound) &#123;</span><br><span class="line">                <span class="keyword">return</span> firstMappedFile;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;findMappedFileByOffset Exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取存储文件最小偏移量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getMinOffset</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.mappedFiles.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.mappedFiles.get(<span class="number">0</span>).getFileFromOffset();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="comment">//continue;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;getMinOffset has exception.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取存储文件最大偏移量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getMaxOffset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MappedFile</span> <span class="variable">mappedFile</span> <span class="operator">=</span> getLastMappedFile();</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mappedFile.getFileFromOffset() + mappedFile.getReadPosition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回存储文件当前写指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getMaxWrotePosition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MappedFile</span> <span class="variable">mappedFile</span> <span class="operator">=</span> getLastMappedFile();</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mappedFile.getFileFromOffset() + mappedFile.getWrotePosition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####2）MappedFile</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/MappedFile.png"                      alt="img"                ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">OS_PAGE_SIZE</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">4</span>;<span class="comment">//操作系统每页大小,默认4K</span></span><br><span class="line"><span class="type">AtomicLong</span> <span class="variable">TOTAL_MAPPED_VIRTUAL_MEMORY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);<span class="comment">//当前JVM实例中MappedFile虚拟内存</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">TOTAL_MAPPED_FILES</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);<span class="comment">//当前JVM实例中MappedFile对象个数</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">wrotePosition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);<span class="comment">//当前文件的写指针</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">committedPosition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);<span class="comment">//当前文件的提交指针</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">flushedPosition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);<span class="comment">//刷写到磁盘指针</span></span><br><span class="line"><span class="type">int</span> fileSize;<span class="comment">//文件大小</span></span><br><span class="line">FileChannel fileChannel;<span class="comment">//文件通道</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//堆外内存ByteBuffer</span></span><br><span class="line"><span class="type">TransientStorePool</span> <span class="variable">transientStorePool</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//堆外内存池</span></span><br><span class="line">String fileName;<span class="comment">//文件名称</span></span><br><span class="line"><span class="type">long</span> fileFromOffset;<span class="comment">//该文件的处理偏移量</span></span><br><span class="line">File file;<span class="comment">//物理文件</span></span><br><span class="line">MappedByteBuffer mappedByteBuffer;<span class="comment">//物理文件对应的内存映射Buffer</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">storeTimestamp</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//文件最后一次内容写入时间</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">firstCreateInQueue</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//是否是MappedFileQueue队列中第一个文件</span></span><br></pre></td></tr></table></figure><p><em><strong>MappedFile初始化</strong></em></p><ul><li>未开启<code>transientStorePoolEnable</code>。<code>transientStorePoolEnable=true</code>为<code>true</code>表示数据先存储到堆外内存，然后通过<code>Commit</code>线程将数据提交到内存映射Buffer中，再通过<code>Flush</code>线程将内存映射<code>Buffer</code>中数据持久化磁盘。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="type">int</span> fileSize)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.fileName = fileName;</span><br><span class="line">    <span class="built_in">this</span>.fileSize = fileSize;</span><br><span class="line">    <span class="built_in">this</span>.file = <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">    <span class="built_in">this</span>.fileFromOffset = Long.parseLong(<span class="built_in">this</span>.file.getName());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ensureDirOK(<span class="built_in">this</span>.file.getParent());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fileChannel = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="built_in">this</span>.file, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">        <span class="built_in">this</span>.mappedByteBuffer = <span class="built_in">this</span>.fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, fileSize);</span><br><span class="line">        TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);</span><br><span class="line">        TOTAL_MAPPED_FILES.incrementAndGet();</span><br><span class="line">        ok = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;create file channel &quot;</span> + <span class="built_in">this</span>.fileName + <span class="string">&quot; Failed. &quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;map file &quot;</span> + <span class="built_in">this</span>.fileName + <span class="string">&quot; Failed. &quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ok &amp;&amp; <span class="built_in">this</span>.fileChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.fileChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启<code>transientStorePoolEnable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="type">int</span> fileSize,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> TransientStorePool transientStorePool)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    init(fileName, fileSize);</span><br><span class="line">    <span class="built_in">this</span>.writeBuffer = transientStorePool.borrowBuffer();<span class="comment">//初始化writeBuffer</span></span><br><span class="line">    <span class="built_in">this</span>.transientStorePool = transientStorePool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>MappedFile提交</strong></em></p><p>提交数据到FileChannel，commitLeastPages为本次提交最小的页数，如果待提交数据不满commitLeastPages，则不执行本次提交操作。如果writeBuffer如果为空，直接返回writePosition指针，无需执行commit操作，表名commit操作主体是writeBuffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">commit</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> commitLeastPages)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (writeBuffer == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//no need to commit data to file channel, so just regard wrotePosition as committedPosition.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.wrotePosition.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否满足提交条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isAbleToCommit(commitLeastPages)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hold()) &#123;</span><br><span class="line">            commit0(commitLeastPages);</span><br><span class="line">            <span class="built_in">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;in commit, hold failed, commit offset = &quot;</span> + <span class="built_in">this</span>.committedPosition.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有数据提交后,清空缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (writeBuffer != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.transientStorePool != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.fileSize == <span class="built_in">this</span>.committedPosition.get()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.transientStorePool.returnBuffer(writeBuffer);</span><br><span class="line">        <span class="built_in">this</span>.writeBuffer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.committedPosition.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>MappedFile#isAbleToCommit</strong></em></p><p>判断是否执行commit操作，如果文件已满返回true；如果commitLeastpages大于0，则比较writePosition与上一次提交的指针commitPosition的差值，除以OS_PAGE_SIZE得到当前脏页的数量，如果大于commitLeastPages则返回true，如果commitLeastpages小于0表示只要存在脏页就提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAbleToCommit</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> commitLeastPages)</span> &#123;</span><br><span class="line">    <span class="comment">//已经刷盘指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">flush</span> <span class="operator">=</span> <span class="built_in">this</span>.committedPosition.get();</span><br><span class="line">    <span class="comment">//文件写指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> <span class="built_in">this</span>.wrotePosition.get();</span><br><span class="line"><span class="comment">//写满刷盘</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isFull()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commitLeastPages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//文件内容达到commitLeastPages页数,则刷盘</span></span><br><span class="line">        <span class="keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= commitLeastPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> write &gt; flush;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>MappedFile#commit0</strong></em></p><p>具体提交的实现，首先创建WriteBuffer区共享缓存区，然后将新创建的position回退到上一次提交的位置（commitPosition），设置limit为wrotePosition（当前最大有效数据指针），然后把commitPosition到wrotePosition的数据写入到FileChannel中，然后更新committedPosition指针为wrotePosition。commit的作用就是将MappedFile的writeBuffer中数据提交到文件通道FileChannel中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commit0</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> commitLeastPages)</span> &#123;</span><br><span class="line">    <span class="comment">//写指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">writePos</span> <span class="operator">=</span> <span class="built_in">this</span>.wrotePosition.get();</span><br><span class="line">    <span class="comment">//上次提交指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastCommittedPosition</span> <span class="operator">=</span> <span class="built_in">this</span>.committedPosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writePos - <span class="built_in">this</span>.committedPosition.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//复制共享内存区域</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> writeBuffer.slice();</span><br><span class="line">            <span class="comment">//设置提交位置是上次提交位置</span></span><br><span class="line">            byteBuffer.position(lastCommittedPosition);</span><br><span class="line">            <span class="comment">//最大提交数量</span></span><br><span class="line">            byteBuffer.limit(writePos);</span><br><span class="line">            <span class="comment">//设置fileChannel位置为上次提交位置</span></span><br><span class="line">            <span class="built_in">this</span>.fileChannel.position(lastCommittedPosition);</span><br><span class="line">            <span class="comment">//将lastCommittedPosition到writePos的数据复制到FileChannel中</span></span><br><span class="line">            <span class="built_in">this</span>.fileChannel.write(byteBuffer);</span><br><span class="line">            <span class="comment">//重置提交位置</span></span><br><span class="line">            <span class="built_in">this</span>.committedPosition.set(writePos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Error occurred when commit data to FileChannel.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>MappedFile#flush</strong></em></p><p>刷写磁盘，直接调用MappedByteBuffer或fileChannel的force方法将内存中的数据持久化到磁盘，那么flushedPosition应该等于MappedByteBuffer中的写指针；如果writeBuffer不为空，则flushPosition应该等于上一次的commit指针；因为上一次提交的数据就是进入到MappedByteBuffer中的数据；如果writeBuffer为空，数据时直接进入到MappedByteBuffer，wrotePosition代表的是MappedByteBuffer中的指针，故设置flushPosition为wrotePosition。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/flush.jpg"                      alt="img"                ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">flush</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> flushLeastPages)</span> &#123;</span><br><span class="line">    <span class="comment">//数据达到刷盘条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isAbleToFlush(flushLeastPages)) &#123;</span><br><span class="line">        <span class="comment">//加锁，同步刷盘</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hold()) &#123;</span><br><span class="line">            <span class="comment">//获得读指针</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> getReadPosition();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//数据从writeBuffer提交数据到fileChannel再刷新到磁盘</span></span><br><span class="line">                <span class="keyword">if</span> (writeBuffer != <span class="literal">null</span> || <span class="built_in">this</span>.fileChannel.position() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.fileChannel.force(<span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//从mmap刷新数据到磁盘</span></span><br><span class="line">                    <span class="built_in">this</span>.mappedByteBuffer.force();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Error occurred when force data to disk.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//更新刷盘位置</span></span><br><span class="line">            <span class="built_in">this</span>.flushedPosition.set(value);</span><br><span class="line">            <span class="built_in">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;in flush, hold failed, flush offset = &quot;</span> + <span class="built_in">this</span>.flushedPosition.get());</span><br><span class="line">            <span class="built_in">this</span>.flushedPosition.set(getReadPosition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getFlushedPosition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>MappedFile#getReadPosition</strong></em></p><p>获取当前文件最大可读指针。如果writeBuffer为空，则直接返回当前的写指针；如果writeBuffer不为空，则返回上一次提交的指针。在MappedFile设置中,只有提交了的数据（写入到MappedByteBuffer或FileChannel中的数据）才是安全的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getReadPosition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//如果writeBuffer为空,刷盘的位置就是应该等于上次commit的位置,如果为空则为mmap的写指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.writeBuffer == <span class="literal">null</span> ? <span class="built_in">this</span>.wrotePosition.get() : <span class="built_in">this</span>.committedPosition.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>MappedFile#selectMappedBuffer</strong></em></p><p>查找pos到当前最大可读之间的数据，由于在整个写入期间都未曾改MappedByteBuffer的指针，如果mappedByteBuffer.slice()方法返回的共享缓存区空间为整个MappedFile，然后通过设置ByteBuffer的position为待查找的值，读取字节长度当前可读最大长度，最终返回的ByteBuffer的limit为size。整个共享缓存区的容量为（MappedFile#fileSize-pos）。故在操作SelectMappedBufferResult不能对包含在里面的ByteBuffer调用filp方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SelectMappedBufferResult <span class="title function_">selectMappedBuffer</span><span class="params">(<span class="type">int</span> pos)</span> &#123;</span><br><span class="line">    <span class="comment">//获得最大可读指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">readPosition</span> <span class="operator">=</span> getReadPosition();</span><br><span class="line">    <span class="comment">//pos小于最大可读指针,并且大于0</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; readPosition &amp;&amp; pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hold()) &#123;</span><br><span class="line">            <span class="comment">//复制mappedByteBuffer读共享区</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> <span class="built_in">this</span>.mappedByteBuffer.slice();</span><br><span class="line">            <span class="comment">//设置读指针位置</span></span><br><span class="line">            byteBuffer.position(pos);</span><br><span class="line">            <span class="comment">//获得可读范围</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> readPosition - pos;</span><br><span class="line">            <span class="comment">//设置最大刻度范围</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBufferNew</span> <span class="operator">=</span> byteBuffer.slice();</span><br><span class="line">            byteBufferNew.limit(size);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SelectMappedBufferResult</span>(<span class="built_in">this</span>.fileFromOffset + pos, byteBufferNew, size, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>MappedFile#shutdown</strong></em></p><p>MappedFile文件销毁的实现方法为public boolean destory(long intervalForcibly)，intervalForcibly表示拒绝被销毁的最大存活时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> intervalForcibly)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.available) &#123;</span><br><span class="line">        <span class="comment">//关闭MapedFile</span></span><br><span class="line">        <span class="built_in">this</span>.available = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//设置当前关闭时间戳</span></span><br><span class="line">        <span class="built_in">this</span>.firstShutdownTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="built_in">this</span>.release();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.getRefCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((System.currentTimeMillis() - <span class="built_in">this</span>.firstShutdownTimestamp) &gt;= intervalForcibly) &#123;</span><br><span class="line">            <span class="built_in">this</span>.refCount.set(-<span class="number">1000</span> - <span class="built_in">this</span>.getRefCount());</span><br><span class="line">            <span class="built_in">this</span>.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）TransientStorePool"><a href="#3）TransientStorePool" class="headerlink" title="3）TransientStorePool"></a>3）TransientStorePool</h4><p>短暂的存储池。RocketMQ单独创建一个MappedByteBuffer内存缓存池，用来临时存储数据，数据先写入该内存映射中，然后由commit线程定时将数据从该内存复制到与目标物理文件对应的内存映射中。RocketMQ引入该机制主要的原因是提供一种内存锁定，将当前堆外内存一直锁定在内存中，避免被进程将内存交换到磁盘。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/TransientStorePool.png"                      alt="img"                ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolSize;<span class="comment">//availableBuffers个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fileSize;<span class="comment">//每隔ByteBuffer大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ByteBuffer&gt; availableBuffers;<span class="comment">//ByteBuffer容器。双端队列</span></span><br></pre></td></tr></table></figure><p><em><strong>初始化</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//创建poolSize个堆外内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(fileSize);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">address</span> <span class="operator">=</span> ((DirectBuffer) byteBuffer).address();</span><br><span class="line">        <span class="type">Pointer</span> <span class="variable">pointer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pointer</span>(address);</span><br><span class="line">        <span class="comment">//使用com.sun.jna.Library类库将该批内存锁定,避免被置换到交换区,提高存储性能</span></span><br><span class="line">        LibC.INSTANCE.mlock(pointer, <span class="keyword">new</span> <span class="title class_">NativeLong</span>(fileSize));</span><br><span class="line"></span><br><span class="line">        availableBuffers.offer(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-5-实时更新消息消费队列与索引文件"><a href="#2-4-5-实时更新消息消费队列与索引文件" class="headerlink" title="2.4.5 实时更新消息消费队列与索引文件"></a>2.4.5 实时更新消息消费队列与索引文件</h3><p>消息消费队文件、消息属性索引文件都是基于CommitLog文件构建的，当消息生产者提交的消息存储在CommitLog文件中，ConsumerQueue、IndexFile需要及时更新，否则消息无法及时被消费，根据消息属性查找消息也会出现较大延迟。RocketMQ通过开启一个线程ReputMessageService来准实时转发CommitLog文件更新事件，相应的任务处理器根据转发的消息及时更新ConsumerQueue、IndexFile文件。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"                      alt="img"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%9E%84%E5%BB%BA%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97%E5%92%8C%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png"                      alt="img"                ></p><p><em><strong>代码：DefaultMessageStore：start</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置CommitLog内存中最大偏移量</span></span><br><span class="line"><span class="built_in">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line"><span class="built_in">this</span>.reputMessageService.start();</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore：run</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    DefaultMessageStore.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>);</span><br><span class="line"><span class="comment">//每隔1毫秒就继续尝试推送消息到消息消费队列和索引文件</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.doReput();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            DefaultMessageStore.log.warn(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultMessageStore.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore：deReput</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从result中循环遍历消息,一次读一条,创建DispatherRequest对象。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">readSize</span> <span class="operator">=</span> <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line"><span class="type">DispatchRequest</span> <span class="variable">dispatchRequest</span> <span class="operator">=</span>                               DefaultMessageStore.<span class="built_in">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dispatchRequest.getBufferSize() == -<span class="number">1</span> ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        DefaultMessageStore.<span class="built_in">this</span>.doDispatch(dispatchRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>DispatchRequest</strong></em></p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/DispatchRequest.png"                      alt="img"                ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String topic; <span class="comment">//消息主题名称</span></span><br><span class="line"><span class="type">int</span> queueId;  <span class="comment">//消息队列ID</span></span><br><span class="line"><span class="type">long</span> commitLogOffset;<span class="comment">//消息物理偏移量</span></span><br><span class="line"><span class="type">int</span> msgSize;<span class="comment">//消息长度</span></span><br><span class="line"><span class="type">long</span> tagsCode;<span class="comment">//消息过滤tag hashCode</span></span><br><span class="line"><span class="type">long</span> storeTimestamp;<span class="comment">//消息存储时间戳</span></span><br><span class="line"><span class="type">long</span> consumeQueueOffset;<span class="comment">//消息队列偏移量</span></span><br><span class="line">String keys;<span class="comment">//消息索引key</span></span><br><span class="line"><span class="type">boolean</span> success;<span class="comment">//是否成功解析到完整的消息</span></span><br><span class="line">String uniqKey;<span class="comment">//消息唯一键</span></span><br><span class="line"><span class="type">int</span> sysFlag;<span class="comment">//消息系统标记</span></span><br><span class="line"><span class="type">long</span> preparedTransactionOffset;<span class="comment">//消息预处理事务偏移量</span></span><br><span class="line">Map&lt;String, String&gt; propertiesMap;<span class="comment">//消息属性</span></span><br><span class="line"><span class="type">byte</span>[] bitMap;<span class="comment">//位图</span></span><br></pre></td></tr></table></figure><h4 id="1）转发到ConsumerQueue"><a href="#1）转发到ConsumerQueue" class="headerlink" title="1）转发到ConsumerQueue"></a>1）转发到ConsumerQueue</h4><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E5%88%B0%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97.png"                      alt="img"                ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommitLogDispatcherBuildConsumeQueue</span> <span class="keyword">implements</span> <span class="title class_">CommitLogDispatcher</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(DispatchRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tranType</span> <span class="operator">=</span> MessageSysFlag.getTransactionValue(request.getSysFlag());</span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                <span class="comment">//消息分发</span></span><br><span class="line">                DefaultMessageStore.<span class="built_in">this</span>.putMessagePositionInfo(request);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore#putMessagePositionInfo</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putMessagePositionInfo</span><span class="params">(DispatchRequest dispatchRequest)</span> &#123;</span><br><span class="line">    <span class="comment">//获得消费队列</span></span><br><span class="line">    <span class="type">ConsumeQueue</span> <span class="variable">cq</span> <span class="operator">=</span> <span class="built_in">this</span>.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());</span><br><span class="line">    <span class="comment">//消费队列分发消息</span></span><br><span class="line">    cq.putMessagePositionInfoWrapper(dispatchRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore#putMessagePositionInfo</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依次将消息偏移量、消息长度、tag写入到ByteBuffer中</span></span><br><span class="line"><span class="built_in">this</span>.byteBufferIndex.flip();</span><br><span class="line"><span class="built_in">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</span><br><span class="line"><span class="built_in">this</span>.byteBufferIndex.putLong(offset);</span><br><span class="line"><span class="built_in">this</span>.byteBufferIndex.putInt(size);</span><br><span class="line"><span class="built_in">this</span>.byteBufferIndex.putLong(tagsCode);</span><br><span class="line"><span class="comment">//获得内存映射文件</span></span><br><span class="line"><span class="type">MappedFile</span> <span class="variable">mappedFile</span> <span class="operator">=</span> <span class="built_in">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</span><br><span class="line"><span class="keyword">if</span> (mappedFile != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//将消息追加到内存映射文件,异步输盘</span></span><br><span class="line">    <span class="keyword">return</span> mappedFile.appendMessage(<span class="built_in">this</span>.byteBufferIndex.array());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）转发到Index"><a href="#2）转发到Index" class="headerlink" title="2）转发到Index"></a>2）转发到Index</h4><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E5%88%B0%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png"                      alt="img"                ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommitLogDispatcherBuildIndex</span> <span class="keyword">implements</span> <span class="title class_">CommitLogDispatcher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(DispatchRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DefaultMessageStore.<span class="built_in">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</span><br><span class="line">            DefaultMessageStore.<span class="built_in">this</span>.indexService.buildIndex(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore#buildIndex</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildIndex</span><span class="params">(DispatchRequest req)</span> &#123;</span><br><span class="line">    <span class="comment">//获得索引文件</span></span><br><span class="line">    <span class="type">IndexFile</span> <span class="variable">indexFile</span> <span class="operator">=</span> retryGetAndCreateIndexFile();</span><br><span class="line">    <span class="keyword">if</span> (indexFile != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获得文件最大物理偏移量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endPhyOffset</span> <span class="operator">=</span> indexFile.getEndPhyOffset();</span><br><span class="line">        <span class="type">DispatchRequest</span> <span class="variable">msg</span> <span class="operator">=</span> req;</span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> msg.getTopic();</span><br><span class="line">        <span class="type">String</span> <span class="variable">keys</span> <span class="operator">=</span> msg.getKeys();</span><br><span class="line">        <span class="comment">//如果该消息的物理偏移量小于索引文件中的最大物理偏移量,则说明是重复数据,忽略本次索引构建</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getCommitLogOffset() &lt; endPhyOffset) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tranType</span> <span class="operator">=</span> MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果消息ID不为空,则添加到Hash索引中</span></span><br><span class="line">        <span class="keyword">if</span> (req.getUniqKey() != <span class="literal">null</span>) &#123;</span><br><span class="line">            indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));</span><br><span class="line">            <span class="keyword">if</span> (indexFile == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//构建索引key,RocketMQ支持为同一个消息建立多个索引,多个索引键空格隔开.</span></span><br><span class="line">        <span class="keyword">if</span> (keys != <span class="literal">null</span> &amp;&amp; keys.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; keyset.length; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyset[i];</span><br><span class="line">                <span class="keyword">if</span> (key.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    indexFile = putKey(indexFile, msg, buildKey(topic, key));</span><br><span class="line">                    <span class="keyword">if</span> (indexFile == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;build index error, stop building index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-6-消息队列和索引文件恢复"><a href="#2-4-6-消息队列和索引文件恢复" class="headerlink" title="2.4.6 消息队列和索引文件恢复"></a>2.4.6 消息队列和索引文件恢复</h3><p>由于RocketMQ存储首先将消息全量存储在CommitLog文件中，然后异步生成转发任务更新ConsumerQueue和Index文件。如果消息成功存储到CommitLog文件中，转发任务未成功执行，此时消息服务器Broker由于某个愿意宕机，导致CommitLog、ConsumerQueue、IndexFile文件数据不一致。如果不加以人工修复的话，会有一部分消息即便在CommitLog中文件中存在，但由于没有转发到ConsumerQueue，这部分消息将永远复发被消费者消费。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B.png"                      alt="img"                ></p><p>####1）存储文件加载</p><p><em><strong>代码：DefaultMessageStore#load</strong></em></p><p>判断上一次是否异常退出。实现机制是Broker在启动时创建abort文件，在退出时通过JVM钩子函数删除abort文件。如果下次启动时存在abort文件。说明Broker时异常退出的，CommitLog与ConsumerQueue数据有可能不一致，需要进行修复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断临时文件是否存在</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">lastExitOK</span> <span class="operator">=</span> !<span class="built_in">this</span>.isTempFileExist();</span><br><span class="line"><span class="comment">//根据临时文件判断当前Broker是否异常退出</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isTempFileExist</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> StorePathConfigHelper</span><br><span class="line">        .getAbortFile(<span class="built_in">this</span>.messageStoreConfig.getStorePathRootDir());</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">    <span class="keyword">return</span> file.exists();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore#load</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载延时队列</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != scheduleMessageService) &#123;</span><br><span class="line">    result = result &amp;&amp; <span class="built_in">this</span>.scheduleMessageService.load();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载CommitLog文件</span></span><br><span class="line">result = result &amp;&amp; <span class="built_in">this</span>.commitLog.load();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载消费队列文件</span></span><br><span class="line">result = result &amp;&amp; <span class="built_in">this</span>.loadConsumeQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line"><span class="comment">//加载存储监测点,监测点主要记录CommitLog文件、ConsumerQueue文件、Index索引文件的刷盘点</span></span><br><span class="line">    <span class="built_in">this</span>.storeCheckpoint =<span class="keyword">new</span> <span class="title class_">StoreCheckpoint</span>(StorePathConfigHelper.getStoreCheckpoint(<span class="built_in">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class="line"><span class="comment">//加载index文件</span></span><br><span class="line">    <span class="built_in">this</span>.indexService.load(lastExitOK);</span><br><span class="line"><span class="comment">//根据Broker是否异常退出,执行不同的恢复策略</span></span><br><span class="line">    <span class="built_in">this</span>.recover(lastExitOK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：MappedFileQueue#load</strong></em></p><p>加载CommitLog到映射文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向CommitLog文件目录</span></span><br><span class="line"><span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.storePath);</span><br><span class="line"><span class="comment">//获得文件数组</span></span><br><span class="line">File[] files = dir.listFiles();</span><br><span class="line"><span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 文件排序</span></span><br><span class="line">    Arrays.sort(files);</span><br><span class="line">    <span class="comment">//遍历文件</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line"><span class="comment">//如果文件大小和配置文件不一致,退出</span></span><br><span class="line">        <span class="keyword">if</span> (file.length() != <span class="built_in">this</span>.mappedFileSize) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建映射文件</span></span><br><span class="line">            <span class="type">MappedFile</span> <span class="variable">mappedFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappedFile</span>(file.getPath(), mappedFileSize);</span><br><span class="line">            mappedFile.setWrotePosition(<span class="built_in">this</span>.mappedFileSize);</span><br><span class="line">            mappedFile.setFlushedPosition(<span class="built_in">this</span>.mappedFileSize);</span><br><span class="line">            mappedFile.setCommittedPosition(<span class="built_in">this</span>.mappedFileSize);</span><br><span class="line">            <span class="comment">//将映射文件添加到队列</span></span><br><span class="line">            <span class="built_in">this</span>.mappedFiles.add(mappedFile);</span><br><span class="line">            log.info(<span class="string">&quot;load &quot;</span> + file.getPath() + <span class="string">&quot; OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;load file &quot;</span> + file + <span class="string">&quot; error&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore#loadConsumeQueue</strong></em></p><p>加载消息消费队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行消费队列目录</span></span><br><span class="line"><span class="type">File</span> <span class="variable">dirLogic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(StorePathConfigHelper.getStorePathConsumeQueue(<span class="built_in">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class="line"><span class="comment">//遍历消费队列目录</span></span><br><span class="line">File[] fileTopicList = dirLogic.listFiles();</span><br><span class="line"><span class="keyword">if</span> (fileTopicList != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File fileTopic : fileTopicList) &#123;</span><br><span class="line">        <span class="comment">//获得子目录名称,即topic名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> fileTopic.getName();</span><br><span class="line"><span class="comment">//遍历子目录下的消费队列文件</span></span><br><span class="line">        File[] fileQueueIdList = fileTopic.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (fileQueueIdList != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历文件</span></span><br><span class="line">            <span class="keyword">for</span> (File fileQueueId : fileQueueIdList) &#123;</span><br><span class="line">                <span class="comment">//文件名称即队列ID</span></span><br><span class="line">                <span class="type">int</span> queueId;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queueId = Integer.parseInt(fileQueueId.getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//创建消费队列并加载到内存</span></span><br><span class="line">                <span class="type">ConsumeQueue</span> <span class="variable">logic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumeQueue</span>(</span><br><span class="line">                    topic,</span><br><span class="line">                    queueId,</span><br><span class="line">                    StorePathConfigHelper.getStorePathConsumeQueue(<span class="built_in">this</span>.messageStoreConfig.getStorePathRootDir()),</span><br><span class="line">            <span class="built_in">this</span>.getMessageStoreConfig().getMapedFileSizeConsumeQueue(),</span><br><span class="line">                    <span class="built_in">this</span>);</span><br><span class="line">                <span class="built_in">this</span>.putConsumeQueue(topic, queueId, logic);</span><br><span class="line">                <span class="keyword">if</span> (!logic.load()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;load logics queue all over, OK&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><em><strong>代码：IndexService#load</strong></em></p><p>加载索引文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">load</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> lastExitOK)</span> &#123;</span><br><span class="line">    <span class="comment">//索引文件目录</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.storePath);</span><br><span class="line">    <span class="comment">//遍历索引文件</span></span><br><span class="line">    File[] files = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//文件排序</span></span><br><span class="line">        Arrays.sort(files);</span><br><span class="line">        <span class="comment">//遍历文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//加载索引文件</span></span><br><span class="line">                <span class="type">IndexFile</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexFile</span>(file.getPath(), <span class="built_in">this</span>.hashSlotNum, <span class="built_in">this</span>.indexNum, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                f.load();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!lastExitOK) &#123;</span><br><span class="line">                    <span class="comment">//索引文件上次的刷盘时间小于该索引文件的消息时间戳,该文件将立即删除</span></span><br><span class="line">                    <span class="keyword">if</span> (f.getEndTimestamp() &gt; <span class="built_in">this</span>.defaultMessageStore.getStoreCheckpoint()</span><br><span class="line">                        .getIndexMsgTimestamp()) &#123;</span><br><span class="line">                        f.destroy(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//将索引文件添加到队列</span></span><br><span class="line">                log.info(<span class="string">&quot;load index file OK, &quot;</span> + f.getFileName());</span><br><span class="line">                <span class="built_in">this</span>.indexFileList.add(f);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;load file &#123;&#125; error&quot;</span>, file, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;load file &#123;&#125; error&quot;</span>, file, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore#recover</strong></em></p><p>文件恢复，根据Broker是否正常退出执行不同的恢复策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> lastExitOK)</span> &#123;</span><br><span class="line">    <span class="comment">//获得最大的物理便宜消费队列</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">maxPhyOffsetOfConsumeQueue</span> <span class="operator">=</span> <span class="built_in">this</span>.recoverConsumeQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastExitOK) &#123;</span><br><span class="line">        <span class="comment">//正常恢复</span></span><br><span class="line">        <span class="built_in">this</span>.commitLog.recoverNormally(maxPhyOffsetOfConsumeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//异常恢复</span></span><br><span class="line">        <span class="built_in">this</span>.commitLog.recoverAbnormally(maxPhyOffsetOfConsumeQueue);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在CommitLog中保存每个消息消费队列当前的存储逻辑偏移量</span></span><br><span class="line">    <span class="built_in">this</span>.recoverTopicQueueTable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore#recoverTopicQueueTable</strong></em></p><p>恢复ConsumerQueue后，将在CommitLog实例中保存每隔消息队列当前的存储逻辑偏移量，这也是消息中不仅存储主题、消息队列ID、还存储了消息队列的关键所在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverTopicQueueTable</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String<span class="comment">/* topic-queueid */</span>, Long<span class="comment">/* offset */</span>&gt; table = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Long&gt;(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//CommitLog最小偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">minPhyOffset</span> <span class="operator">=</span> <span class="built_in">this</span>.commitLog.getMinOffset();</span><br><span class="line">    <span class="comment">//遍历消费队列,将消费队列保存在CommitLog中</span></span><br><span class="line">    <span class="keyword">for</span> (ConcurrentMap&lt;Integer, ConsumeQueue&gt; maps : <span class="built_in">this</span>.consumeQueueTable.values()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ConsumeQueue logic : maps.values()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> logic.getTopic() + <span class="string">&quot;-&quot;</span> + logic.getQueueId();</span><br><span class="line">            table.put(key, logic.getMaxOffsetInQueue());</span><br><span class="line">            logic.correctMinOffset(minPhyOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.commitLog.setTopicQueueTable(table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####2）正常恢复</p><p><em><strong>代码：CommitLog#recoverNormally</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverNormally</span><span class="params">(<span class="type">long</span> maxPhyOffsetOfConsumeQueue)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;MappedFile&gt; mappedFiles = <span class="built_in">this</span>.mappedFileQueue.getMappedFiles();</span><br><span class="line">    <span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class="line">         <span class="comment">//Broker正常停止再重启时,从倒数第三个开始恢复,如果不足3个文件,则从第一个文件开始恢复。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> mappedFiles.size() - <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">MappedFile</span> <span class="variable">mappedFile</span> <span class="operator">=</span> mappedFiles.get(index);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> mappedFile.sliceByteBuffer();</span><br><span class="line">        <span class="type">long</span> <span class="variable">processOffset</span> <span class="operator">=</span> mappedFile.getFileFromOffset();</span><br><span class="line">        <span class="comment">//代表当前已校验通过的offset</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">mappedFileOffset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//查找消息</span></span><br><span class="line">            <span class="type">DispatchRequest</span> <span class="variable">dispatchRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.checkMessageAndReturnSize(byteBuffer, checkCRCOnRecover);</span><br><span class="line">            <span class="comment">//消息长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dispatchRequest.getMsgSize();</span><br><span class="line">           <span class="comment">//查找结果为true,并且消息长度大于0,表示消息正确.mappedFileOffset向前移动本消息长度</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mappedFileOffset += size;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果查找结果为true且消息长度等于0,表示已到该文件末尾,如果还有下一个文件,则重置processOffset和MappedFileOffset重复查找下一个文件,否则跳出循环。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size == <span class="number">0</span>) &#123;</span><br><span class="line">              index++;</span><br><span class="line">              <span class="keyword">if</span> (index &gt;= mappedFiles.size()) &#123;</span><br><span class="line">                  <span class="comment">// Current branch can not happen</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//取出每个文件</span></span><br><span class="line">                  mappedFile = mappedFiles.get(index);</span><br><span class="line">                  byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">                  processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">                  mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">                  </span><br><span class="line">          &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查找结果为false，表明该文件未填满所有消息，跳出循环，结束循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;recover physics file end, &quot;</span> + mappedFile.getFileName());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//更新MappedFileQueue的flushedWhere和committedWhere指针</span></span><br><span class="line">        processOffset += mappedFileOffset;</span><br><span class="line">        <span class="built_in">this</span>.mappedFileQueue.setFlushedWhere(processOffset);</span><br><span class="line">        <span class="built_in">this</span>.mappedFileQueue.setCommittedWhere(processOffset);</span><br><span class="line">        <span class="comment">//删除offset之后的所有文件</span></span><br><span class="line">        <span class="built_in">this</span>.mappedFileQueue.truncateDirtyFiles(processOffset);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (maxPhyOffsetOfConsumeQueue &gt;= processOffset) &#123;</span><br><span class="line">            <span class="built_in">this</span>.defaultMessageStore.truncateDirtyLogicFiles(processOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mappedFileQueue.setFlushedWhere(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.mappedFileQueue.setCommittedWhere(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.defaultMessageStore.destroyLogics();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：MappedFileQueue#truncateDirtyFiles</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">truncateDirtyFiles</span><span class="params">(<span class="type">long</span> offset)</span> &#123;</span><br><span class="line">    List&lt;MappedFile&gt; willRemoveFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MappedFile&gt;();</span><br><span class="line"><span class="comment">//遍历目录下文件</span></span><br><span class="line">    <span class="keyword">for</span> (MappedFile file : <span class="built_in">this</span>.mappedFiles) &#123;</span><br><span class="line">        <span class="comment">//文件尾部的偏移量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">fileTailOffset</span> <span class="operator">=</span> file.getFileFromOffset() + <span class="built_in">this</span>.mappedFileSize;</span><br><span class="line">        <span class="comment">//文件尾部的偏移量大于offset</span></span><br><span class="line">        <span class="keyword">if</span> (fileTailOffset &gt; offset) &#123;</span><br><span class="line">            <span class="comment">//offset大于文件的起始偏移量</span></span><br><span class="line">            <span class="keyword">if</span> (offset &gt;= file.getFileFromOffset()) &#123;</span><br><span class="line">                <span class="comment">//更新wrotePosition、committedPosition、flushedPosistion</span></span><br><span class="line">                file.setWrotePosition((<span class="type">int</span>) (offset % <span class="built_in">this</span>.mappedFileSize));</span><br><span class="line">                file.setCommittedPosition((<span class="type">int</span>) (offset % <span class="built_in">this</span>.mappedFileSize));</span><br><span class="line">                file.setFlushedPosition((<span class="type">int</span>) (offset % <span class="built_in">this</span>.mappedFileSize));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//offset小于文件的起始偏移量,说明该文件是有效文件后面创建的,释放mappedFile占用内存,删除文件</span></span><br><span class="line">                file.destroy(<span class="number">1000</span>);</span><br><span class="line">                willRemoveFiles.add(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.deleteExpiredFile(willRemoveFiles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####3）异常恢复</p><p>Broker异常停止文件恢复的实现为CommitLog#recoverAbnormally。异常文件恢复步骤与正常停止文件恢复流程基本相同，其主要差别有两个。首先，正常停止默认从倒数第三个文件开始进行恢复，而异常停止则需要从最后一个文件往前走，找到第一个消息存储正常的文件。其次，如果CommitLog目录没有消息文件，如果消息消费队列目录下存在文件，则需要销毁。</p><p><em><strong>代码：CommitLog#recoverAbnormally</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// Looking beginning to recover from which file</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> mappedFiles.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">MappedFile</span> <span class="variable">mappedFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">        mappedFile = mappedFiles.get(index);</span><br><span class="line">        <span class="comment">//判断消息文件是否是一个正确的文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isMappedFileMatchedRecover(mappedFile)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;recover from this mapped file &quot;</span> + mappedFile.getFileName());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//根据索引取出mappedFile文件</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        mappedFile = mappedFiles.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...验证消息的合法性,并将消息转发到消息消费队列和索引文件</span></span><br><span class="line">       </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//未找到mappedFile,重置flushWhere、committedWhere都为0，销毁消息队列文件</span></span><br><span class="line">    <span class="built_in">this</span>.mappedFileQueue.setFlushedWhere(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">this</span>.mappedFileQueue.setCommittedWhere(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">this</span>.defaultMessageStore.destroyLogics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-7-刷盘机制"><a href="#2-4-7-刷盘机制" class="headerlink" title="2.4.7 刷盘机制"></a>2.4.7 刷盘机制</h3><p>RocketMQ的存储是基于JDK NIO的内存映射机制（MappedByteBuffer）的，消息存储首先将消息追加到内存，再根据配置的刷盘策略在不同时间进行刷写磁盘。</p><h4 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h4><p>消息追加到内存后，立即将数据刷写到磁盘文件</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98%E6%B5%81%E7%A8%8B.png"                      alt="img"                ></p><p><em><strong>代码：CommitLog#handleDiskFlush</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刷盘服务</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">GroupCommitService</span> <span class="variable">service</span> <span class="operator">=</span> (GroupCommitService) <span class="built_in">this</span>.flushCommitLogService;</span><br><span class="line"><span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">    <span class="comment">//封装刷盘请求</span></span><br><span class="line">    <span class="type">GroupCommitRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupCommitRequest</span>(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">    <span class="comment">//提交刷盘请求</span></span><br><span class="line">    service.putRequest(request);</span><br><span class="line">    <span class="comment">//线程阻塞5秒，等待刷盘结束</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flushOK</span> <span class="operator">=</span> request.waitForFlush(<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line">    <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">        putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><em><strong>GroupCommitRequest</strong></em></p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/GroupCommitRequest.png"                      alt="img"                ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> nextOffset;<span class="comment">//刷盘点偏移量</span></span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);<span class="comment">//倒计树锁存器</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flushOK</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//刷盘结果;默认为false</span></span><br></pre></td></tr></table></figure><p><em><strong>代码：GroupCommitService#run</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    CommitLog.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//线程等待10ms</span></span><br><span class="line">            <span class="built_in">this</span>.waitForRunning(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//执行提交</span></span><br><span class="line">            <span class="built_in">this</span>.doCommit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            CommitLog.log.warn(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：GroupCommitService#doCommit</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doCommit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.requestsRead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//遍历requestsRead</span></span><br><span class="line">            <span class="keyword">for</span> (GroupCommitRequest req : <span class="built_in">this</span>.requestsRead) &#123;</span><br><span class="line">                <span class="comment">// There may be a message in the next file, so a maximum of</span></span><br><span class="line">                <span class="comment">// two times the flush</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flushOK</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; !flushOK; i++) &#123;</span><br><span class="line">                    flushOK = CommitLog.<span class="built_in">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line"><span class="comment">//刷盘</span></span><br><span class="line">                    <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">                        CommitLog.<span class="built_in">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//唤醒发送消息客户端</span></span><br><span class="line">                req.wakeupCustomer(flushOK);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新刷盘监测点</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">storeTimestamp</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">            <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;               CommitLog.<span class="built_in">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.requestsRead.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Because of individual messages is set to not sync flush, it</span></span><br><span class="line">            <span class="comment">// will come to this process</span></span><br><span class="line">            CommitLog.<span class="built_in">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><p>在消息追加到内存后，立即返回给消息发送端。如果开启transientStorePoolEnable，RocketMQ会单独申请一个与目标物理文件（commitLog）同样大小的堆外内存，该堆外内存将使用内存锁定，确保不会被置换到虚拟内存中去，消息首先追加到堆外内存，然后提交到物理文件的内存映射中，然后刷写到磁盘。如果未开启transientStorePoolEnable，消息直接追加到物理文件直接映射文件中，然后刷写到磁盘中。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98%E6%B5%81%E7%A8%8B.png"                      alt="img"                ></p><p>开启transientStorePoolEnable后异步刷盘步骤:</p><ol><li>将消息直接追加到ByteBuffer（堆外内存）</li><li>CommitRealTimeService线程每隔200ms将ByteBuffer新追加内容提交到MappedByteBuffer中</li><li>MappedByteBuffer在内存中追加提交的内容，wrotePosition指针向后移动</li><li>commit操作成功返回，将committedPosition位置恢复</li><li>FlushRealTimeService线程默认每500ms将MappedByteBuffer中新追加的内存刷写到磁盘</li></ol><p><em><strong>代码：CommitLog$CommitRealTimeService#run</strong></em></p><p>提交线程工作机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//间隔时间,默认200ms</span></span><br><span class="line"><span class="type">int</span> <span class="variable">interval</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次提交的至少页数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">commitDataLeastPages</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();</span><br><span class="line"></span><br><span class="line"><span class="comment">//两次真实提交的最大间隔,默认200ms</span></span><br><span class="line"><span class="type">int</span> <span class="variable">commitDataThoroughInterval</span> <span class="operator">=</span></span><br><span class="line">CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();</span><br><span class="line"></span><br><span class="line"><span class="comment">//上次提交间隔超过commitDataThoroughInterval,则忽略提交commitDataThoroughInterval参数,直接提交</span></span><br><span class="line"><span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">if</span> (begin &gt;= (<span class="built_in">this</span>.lastCommitTimestamp + commitDataThoroughInterval)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.lastCommitTimestamp = begin;</span><br><span class="line">    commitDataLeastPages = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行提交操作,将待提交数据提交到物理文件的内存映射区</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.mappedFileQueue.commit(commitDataLeastPages);</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">if</span> (!result) &#123;</span><br><span class="line">    <span class="built_in">this</span>.lastCommitTimestamp = end; <span class="comment">// result = false means some data committed.</span></span><br><span class="line">    <span class="comment">//now wake up flush thread.</span></span><br><span class="line">    <span class="comment">//唤醒刷盘线程</span></span><br><span class="line">    flushCommitLogService.wakeup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (end - begin &gt; <span class="number">500</span>) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;Commit data to file costs &#123;&#125; ms&quot;</span>, end - begin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.waitForRunning(interval);</span><br></pre></td></tr></table></figure><p><em><strong>代码：CommitLog$FlushRealTimeService#run</strong></em></p><p>刷盘线程工作机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示await方法等待,默认false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flushCommitLogTimed</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();</span><br><span class="line"><span class="comment">//线程执行时间间隔</span></span><br><span class="line"><span class="type">int</span> <span class="variable">interval</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();</span><br><span class="line"><span class="comment">//一次刷写任务至少包含页数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">flushPhysicQueueLeastPages</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();</span><br><span class="line"><span class="comment">//两次真实刷写任务最大间隔</span></span><br><span class="line"><span class="type">int</span> <span class="variable">flushPhysicQueueThoroughInterval</span> <span class="operator">=</span></span><br><span class="line">CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//距离上次提交间隔超过flushPhysicQueueThoroughInterval,则本次刷盘任务将忽略flushPhysicQueueLeastPages,直接提交</span></span><br><span class="line"><span class="type">long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">if</span> (currentTimeMillis &gt;= (<span class="built_in">this</span>.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.lastFlushTimestamp = currentTimeMillis;</span><br><span class="line">    flushPhysicQueueLeastPages = <span class="number">0</span>;</span><br><span class="line">    printFlushProgress = (printTimes++ % <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//执行一次刷盘前,先等待指定时间间隔</span></span><br><span class="line"><span class="keyword">if</span> (flushCommitLogTimed) &#123;</span><br><span class="line">    Thread.sleep(interval);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.waitForRunning(interval);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//刷写磁盘</span></span><br><span class="line">CommitLog.<span class="built_in">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br><span class="line"><span class="type">long</span> <span class="variable">storeTimestamp</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line"><span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//更新存储监测点文件的时间戳</span></span><br><span class="line">CommitLog.<span class="built_in">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br></pre></td></tr></table></figure><h3 id="2-4-8-过期文件删除机制"><a href="#2-4-8-过期文件删除机制" class="headerlink" title="2.4.8 过期文件删除机制"></a>2.4.8 过期文件删除机制</h3><p>由于RocketMQ操作CommitLog、ConsumerQueue文件是基于内存映射机制并在启动的时候回加载CommitLog、ConsumerQueue目录下的所有文件，为了避免内存与磁盘的浪费，不可能将消息永久存储在消息服务器上，所以要引入一种机制来删除已过期的文件。RocketMQ顺序写CommitLog、ConsumerQueue文件，所有写操作全部落在最后一个CommitLog或者ConsumerQueue文件上，之前的文件在下一个文件创建后将不会再被更新。RocketMQ清除过期文件的方法时：如果当前文件在在一定时间间隔内没有再次被消费，则认为是过期文件，可以被删除，RocketMQ不会关注这个文件上的消息是否全部被消费。默认每个文件的过期时间为72小时，通过在Broker配置文件中设置fileReservedTime来改变过期时间，单位为小时。</p><p><em><strong>代码：DefaultMessageStore#addScheduleTask</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addScheduleTask</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//每隔10s调度一次清除文件</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            DefaultMessageStore.<span class="built_in">this</span>.cleanFilesPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">60</span>, <span class="built_in">this</span>.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore#cleanFilesPeriodically</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanFilesPeriodically</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//清除存储文件</span></span><br><span class="line">    <span class="built_in">this</span>.cleanCommitLogService.run();</span><br><span class="line">    <span class="comment">//清除消息消费队列文件</span></span><br><span class="line">    <span class="built_in">this</span>.cleanConsumeQueueService.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore#deleteExpiredFiles</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteExpiredFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//删除的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">deleteCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//文件保留的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">fileReservedTime</span> <span class="operator">=</span> DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().getFileReservedTime();</span><br><span class="line">    <span class="comment">//删除物理文件的间隔</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">deletePhysicFilesInterval</span> <span class="operator">=</span> DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().getDeleteCommitLogFilesInterval();</span><br><span class="line">    <span class="comment">//线程被占用,第一次拒绝删除后能保留的最大时间,超过该时间,文件将被强制删除</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">destroyMapedFileIntervalForcibly</span> <span class="operator">=</span> DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().getDestroyMapedFileIntervalForcibly();</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">timeup</span> <span class="operator">=</span> <span class="built_in">this</span>.isTimeToDelete();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">spacefull</span> <span class="operator">=</span> <span class="built_in">this</span>.isSpaceToDelete();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">manualDelete</span> <span class="operator">=</span> <span class="built_in">this</span>.manualDeleteFileSeveralTimes &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (timeup || spacefull || manualDelete) &#123;</span><br><span class="line">...执行删除逻辑</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...无作为</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除文件操作的条件</p><ol><li>指定删除文件的时间点，RocketMQ通过deleteWhen设置一天的固定时间执行一次删除过期文件操作，默认4点</li><li>磁盘空间如果不充足，删除过期文件</li><li>预留，手工触发。</li></ol><p><em><strong>代码：CleanCommitLogService#isSpaceToDelete</strong></em></p><p>当磁盘空间不足时执行删除过期文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSpaceToDelete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//磁盘分区的最大使用量</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">ratio</span> <span class="operator">=</span> DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().getDiskMaxUsedSpaceRatio() / <span class="number">100.0</span>;</span><br><span class="line"><span class="comment">//是否需要立即执行删除过期文件操作</span></span><br><span class="line">    cleanImmediately = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">storePathPhysic</span> <span class="operator">=</span> DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().getStorePathCommitLog();</span><br><span class="line">        <span class="comment">//当前CommitLog目录所在的磁盘分区的磁盘使用率</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">physicRatio</span> <span class="operator">=</span> UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic);</span><br><span class="line">        <span class="comment">//diskSpaceWarningLevelRatio:磁盘使用率警告阈值,默认0.90</span></span><br><span class="line">        <span class="keyword">if</span> (physicRatio &gt; diskSpaceWarningLevelRatio) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">diskok</span> <span class="operator">=</span> DefaultMessageStore.<span class="built_in">this</span>.runningFlags.getAndMakeDiskFull();</span><br><span class="line">            <span class="keyword">if</span> (diskok) &#123;</span><br><span class="line">                DefaultMessageStore.log.error(<span class="string">&quot;physic disk maybe full soon &quot;</span> + physicRatio + <span class="string">&quot;, so mark disk full&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//diskSpaceCleanForciblyRatio:强制清除阈值,默认0.85</span></span><br><span class="line">            cleanImmediately = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (physicRatio &gt; diskSpaceCleanForciblyRatio) &#123;</span><br><span class="line">            cleanImmediately = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">diskok</span> <span class="operator">=</span> DefaultMessageStore.<span class="built_in">this</span>.runningFlags.getAndMakeDiskOK();</span><br><span class="line">            <span class="keyword">if</span> (!diskok) &#123;</span><br><span class="line">            DefaultMessageStore.log.info(<span class="string">&quot;physic disk space OK &quot;</span> + physicRatio + <span class="string">&quot;, so mark disk ok&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (physicRatio &lt; <span class="number">0</span> || physicRatio &gt; ratio) &#123;</span><br><span class="line">        DefaultMessageStore.log.info(<span class="string">&quot;physic disk maybe full soon, so reclaim space, &quot;</span> + physicRatio);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：MappedFileQueue#deleteExpiredFileByTime</strong></em></p><p>执行文件销毁和删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mfsLength; i++) &#123;</span><br><span class="line">    <span class="comment">//遍历每隔文件</span></span><br><span class="line">    <span class="type">MappedFile</span> <span class="variable">mappedFile</span> <span class="operator">=</span> (MappedFile) mfs[i];</span><br><span class="line">    <span class="comment">//计算文件存活时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">liveMaxTimestamp</span> <span class="operator">=</span> mappedFile.getLastModifiedTimestamp() + expiredTime;</span><br><span class="line">    <span class="comment">//如果超过72小时,执行文件删除</span></span><br><span class="line">    <span class="keyword">if</span> (System.currentTimeMillis() &gt;= liveMaxTimestamp || cleanImmediately) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappedFile.destroy(intervalForcibly)) &#123;</span><br><span class="line">            files.add(mappedFile);</span><br><span class="line">            deleteCount++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (files.size() &gt;= DELETE_FILES_BATCH_MAX) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (deleteFilesInterval &gt; <span class="number">0</span> &amp;&amp; (i + <span class="number">1</span>) &lt; mfsLength) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(deleteFilesInterval);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//avoid deleting files in the middle</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-9-小结"><a href="#2-4-9-小结" class="headerlink" title="2.4.9 小结"></a>2.4.9 小结</h3><p>RocketMQ的存储文件包括消息文件（Commitlog）、消息消费队列文件（ConsumerQueue）、Hash索引文件（IndexFile）、监测点文件（checkPoint）、abort（关闭异常文件）。单个消息存储文件、消息消费队列文件、Hash索引文件长度固定以便使用内存映射机制进行文件的读写操作。RocketMQ组织文件以文件的起始偏移量来命令文件，这样根据偏移量能快速定位到真实的物理文件。RocketMQ基于内存映射文件机制提供了同步刷盘和异步刷盘两种机制，异步刷盘是指在消息存储时先追加到内存映射文件，然后启动专门的刷盘线程定时将内存中的文件数据刷写到磁盘。</p><p>CommitLog，消息存储文件，RocketMQ为了保证消息发送的高吞吐量，采用单一文件存储所有主题消息，保证消息存储是完全的顺序写，但这样给文件读取带来了不便，为此RocketMQ为了方便消息消费构建了消息消费队列文件，基于主题与队列进行组织，同时RocketMQ为消息实现了Hash索引，可以为消息设置索引键，根据所以能够快速从CommitLog文件中检索消息。</p><p>当消息达到CommitLog后，会通过ReputMessageService线程接近实时地将消息转发给消息消费队列文件与索引文件。为了安全起见，RocketMQ引入abort文件，记录Broker的停机是否是正常关闭还是异常关闭，在重启Broker时为了保证CommitLog文件，消息消费队列文件与Hash索引文件的正确性，分别采用不同策略来恢复文件。</p><p>RocketMQ不会永久存储消息文件、消息消费队列文件，而是启动文件过期机制并在磁盘空间不足或者默认凌晨4点删除过期文件，文件保存72小时并且在删除文件时并不会判断该消息文件上的消息是否被消费。</p><h2 id="2-5-Consumer"><a href="#2-5-Consumer" class="headerlink" title="2.5 Consumer"></a>2.5 Consumer</h2><h3 id="2-5-1-消息消费概述"><a href="#2-5-1-消息消费概述" class="headerlink" title="2.5.1 消息消费概述"></a>2.5.1 消息消费概述</h3><p>消息消费以组的模式开展，一个消费组内可以包含多个消费者，每一个消费者组可订阅多个主题，消费组之间有ff式和广播模式两种消费模式。集群模式，主题下的同一条消息只允许被其中一个消费者消费。广播模式，主题下的同一条消息，将被集群内的所有消费者消费一次。消息服务器与消费者之间的消息传递也有两种模式：推模式、拉模式。所谓的拉模式，是消费端主动拉起拉消息请求，而推模式是消息达到消息服务器后，推送给消息消费者。RocketMQ消息推模式的实现基于拉模式，在拉模式上包装一层，一个拉取任务完成后开始下一个拉取任务。</p><p>集群模式下，多个消费者如何对消息队列进行负载呢？消息队列负载机制遵循一个通用思想：一个消息队列同一个时间只允许被一个消费者消费，一个消费者可以消费多个消息队列。</p><p>RocketMQ支持局部顺序消息消费，也就是保证同一个消息队列上的消息顺序消费。不支持消息全局顺序消费，如果要实现某一个主题的全局顺序消费，可以将该主题的队列数设置为1，牺牲高可用性。</p><p>###2.5.2 消息消费初探</p><p><strong>消息推送模式</strong></p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81.png"                      alt="img"                ></p><p><strong>消息消费重要方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> <span class="type">int</span> delayLevel, <span class="keyword">final</span> String brokerName)</span>：发送消息确认</span><br><span class="line">Set&lt;MessageQueue&gt; <span class="title function_">fetchSubscribeMessageQueues</span><span class="params">(<span class="keyword">final</span> String topic)</span> :获取消费者对主题分配了那些消息队列</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerMessageListener</span><span class="params">(<span class="keyword">final</span> MessageListenerConcurrently messageListener)</span>：注册并发事件监听器</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerMessageListener</span><span class="params">(<span class="keyword">final</span> MessageListenerOrderly messageListener)</span>：注册顺序消息事件监听器</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String subExpression)</span>：基于主题订阅消息，消息过滤使用表达式</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String fullClassName,<span class="keyword">final</span> String filterClassSource)</span>：基于主题订阅消息，消息过滤使用类模式</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> MessageSelector selector)</span> ：订阅消息，并指定队列选择器</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unsubscribe</span><span class="params">(<span class="keyword">final</span> String topic)</span>：取消消息订阅</span><br></pre></td></tr></table></figure><p><strong>DefaultMQPushConsumer</strong></p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/DefaultMQPushConsumer.png"                      alt="img"                ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者组</span></span><br><span class="line"><span class="keyword">private</span> String consumerGroup;</span><br><span class="line"><span class="comment">//消息消费模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">MessageModel</span> <span class="variable">messageModel</span> <span class="operator">=</span> MessageModel.CLUSTERING;</span><br><span class="line"><span class="comment">//指定消费开始偏移量（最大偏移量、最小偏移量、启动时间戳）开始消费</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ConsumeFromWhere</span> <span class="variable">consumeFromWhere</span> <span class="operator">=</span> ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span><br><span class="line"><span class="comment">//集群模式下的消息队列负载策略</span></span><br><span class="line"><span class="keyword">private</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy;</span><br><span class="line"><span class="comment">//订阅信息</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String <span class="comment">/* topic */</span>, String <span class="comment">/* sub expression */</span>&gt; subscription = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//消息业务监听器</span></span><br><span class="line"><span class="keyword">private</span> MessageListener messageListener;</span><br><span class="line"><span class="comment">//消息消费进度存储器</span></span><br><span class="line"><span class="keyword">private</span> OffsetStore offsetStore;</span><br><span class="line"><span class="comment">//消费者最小线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">consumeThreadMin</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//消费者最大线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">consumeThreadMax</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//并发消息消费时处理队列最大跨度</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">consumeConcurrentlyMaxSpan</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"><span class="comment">//每1000次流控后打印流控日志</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">pullThresholdForQueue</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//推模式下任务间隔时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">pullInterval</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//推模式下任务拉取的条数,默认32条</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">pullBatchSize</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"><span class="comment">//每次传入MessageListener#consumerMessage中消息的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">consumeMessageBatchMaxSize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//是否每次拉取消息都订阅消息</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">postSubscriptionWhenPull</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//消息重试次数,-1代表16次</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxReconsumeTimes</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//消息消费超时时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">consumeTimeout</span> <span class="operator">=</span> <span class="number">15</span>;</span><br></pre></td></tr></table></figure><h3 id="2-5-3-消费者启动流程"><a href="#2-5-3-消费者启动流程" class="headerlink" title="2.5.3 消费者启动流程"></a>2.5.3 消费者启动流程</h3><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png"                      alt="img"                ></p><p><em><strong>代码：DefaultMQPushConsumerImpl#start</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            </span><br><span class="line">                <span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="built_in">this</span>.defaultMQPushConsumer.isUnitMode());</span><br><span class="line">            <span class="built_in">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line"><span class="comment">//检查消息者是否合法</span></span><br><span class="line">            <span class="built_in">this</span>.checkConfig();</span><br><span class="line"><span class="comment">//构建主题订阅信息</span></span><br><span class="line">            <span class="built_in">this</span>.copySubscription();</span><br><span class="line"><span class="comment">//设置消费者客户端实例名称为进程ID</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//创建MQClient实例</span></span><br><span class="line">            <span class="built_in">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="built_in">this</span>.defaultMQPushConsumer, <span class="built_in">this</span>.rpcHook);</span><br><span class="line"><span class="comment">//构建rebalanceImpl</span></span><br><span class="line">            <span class="built_in">this</span>.rebalanceImpl.setConsumerGroup(<span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="built_in">this</span>.rebalanceImpl.setMessageModel(<span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">            <span class="built_in">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="built_in">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">            <span class="built_in">this</span>.rebalanceImpl.setmQClientFactory(<span class="built_in">this</span>.mQClientFactor</span><br><span class="line">            <span class="built_in">this</span>.pullAPIWrapper = <span class="keyword">new</span> <span class="title class_">PullAPIWrapper</span>(</span><br><span class="line">                mQClientFactory,</span><br><span class="line">                <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">            <span class="built_in">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookLis</span><br><span class="line">            <span class="title function_">if</span> <span class="params">(<span class="built_in">this</span>.defaultMQPushConsumer.getOffsetStore()</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.offsetStore = <span class="built_in">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">switch</span> (<span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">case</span> BROADCASTING: <span class="comment">//消息消费广播模式,将消费进度保存在本地</span></span><br><span class="line">                   <span class="built_in">this</span>.offsetStore = <span class="keyword">new</span> <span class="title class_">LocalFileOffsetStore</span>(<span class="built_in">this</span>.mQClientFactory, <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> CLUSTERING:<span class="comment">//消息消费集群模式,将消费进度保存在远端Broker</span></span><br><span class="line">                       <span class="built_in">this</span>.offsetStore = <span class="keyword">new</span> <span class="title class_">RemoteBrokerOffsetStore</span>(<span class="built_in">this</span>.mQClientFactory, <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="built_in">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="built_in">this</span>.offsetStore);</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="built_in">this</span>.offsetStore.load</span><br><span class="line">            <span class="comment">//创建顺序消息消费服务</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                <span class="built_in">this</span>.consumeOrderly = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConsumeMessageOrderlyService</span>(<span class="built_in">this</span>, (MessageListenerOrderly) <span class="built_in">this</span>.getMessageListenerInner());</span><br><span class="line">                <span class="comment">//创建并发消息消费服务</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                <span class="built_in">this</span>.consumeOrderly = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConsumeMessageConcurrentlyService</span>(<span class="built_in">this</span>, (MessageListenerConcurrently) <span class="built_in">this</span>.getMessageListenerInner());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//消息消费服务启动</span></span><br><span class="line">            <span class="built_in">this</span>.consumeMessageService.start();</span><br><span class="line">            <span class="comment">//注册消费者实例</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">registerOK</span> <span class="operator">=</span> mQClientFactory.registerConsumer(<span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="built_in">this</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="built_in">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="built_in">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;The consumer group[&quot;</span> + <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                    + <span class="string">&quot;] has been created before, specify another name please.&quot;</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//启动消费者客户端</span></span><br><span class="line">            mQClientFactory.start();</span><br><span class="line">            log.info(<span class="string">&quot;the consumer [&#123;&#125;] start OK.&quot;</span>, <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="built_in">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">            <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;The PushConsumer service state not OK, maybe started once, &quot;</span></span><br><span class="line">                + <span class="built_in">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-4-消息拉取"><a href="#2-5-4-消息拉取" class="headerlink" title="2.5.4 消息拉取"></a>2.5.4 消息拉取</h3><p>消息消费模式有两种模式：广播模式与集群模式。广播模式比较简单，每一个消费者需要拉取订阅主题下所有队列的消息。本文重点讲解集群模式。在集群模式下，同一个消费者组内有多个消息消费者，同一个主题存在多个消费队列，消费者通过负载均衡的方式消费消息。</p><p>消息队列负载均衡，通常的作法是一个消息队列在同一个时间只允许被一个消费消费者消费，一个消息消费者可以同时消费多个消息队列。</p><h4 id="1）PullMessageService实现机制"><a href="#1）PullMessageService实现机制" class="headerlink" title="1）PullMessageService实现机制"></a>1）PullMessageService实现机制</h4><p>从MQClientInstance的启动流程中可以看出，RocketMQ使用一个单独的线程PullMessageService来负责消息的拉取。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/pullMessageService%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6.png"                      alt="img"                ></p><p><em><strong>代码：PullMessageService#run</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>);</span><br><span class="line"><span class="comment">//循环拉取消息</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从请求队列中获取拉取消息请求</span></span><br><span class="line">            <span class="type">PullRequest</span> <span class="variable">pullRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.pullRequestQueue.take();</span><br><span class="line">            <span class="comment">//拉取消息</span></span><br><span class="line">            <span class="built_in">this</span>.pullMessage(pullRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Pull Message Service Run Method exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PullRequest</strong></p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/PullRequest.png"                      alt="img"                ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String consumerGroup;<span class="comment">//消费者组</span></span><br><span class="line"><span class="keyword">private</span> MessageQueue messageQueue;<span class="comment">//待拉取消息队列</span></span><br><span class="line"><span class="keyword">private</span> ProcessQueue processQueue;<span class="comment">//消息处理队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> nextOffset;<span class="comment">//待拉取的MessageQueue偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lockedFirst</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//是否被锁定</span></span><br></pre></td></tr></table></figure><p><em><strong>代码：PullMessageService#pullMessage</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> &#123;</span><br><span class="line">    <span class="comment">//获得消费者实例</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MQConsumerInner</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="built_in">this</span>.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</span><br><span class="line">    <span class="keyword">if</span> (consumer != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//强转为推送模式消费者</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumerImpl</span> <span class="variable">impl</span> <span class="operator">=</span> (DefaultMQPushConsumerImpl) consumer;</span><br><span class="line">        <span class="comment">//推送消息</span></span><br><span class="line">        impl.pullMessage(pullRequest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;No matched consumer for the PullRequest &#123;&#125;, drop it&quot;</span>, pullRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####2）ProcessQueue实现机制</p><p>ProcessQueue是MessageQueue在消费端的重现、快照。PullMessageService从消息服务器默认每次拉取32条消息，按照消息的队列偏移量顺序存放在ProcessQueue中，PullMessageService然后将消息提交到消费者消费线程池，消息成功消费后从ProcessQueue中移除。</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/ProcessQueue.png"                      alt="img"                ></p><p><strong>属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, MessageExt&gt;();</span><br><span class="line"><span class="comment">//读写锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lockTreeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="comment">//ProcessQueue总消息树</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">msgCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"><span class="comment">//ProcessQueue队列最大偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">queueOffsetMax</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"><span class="comment">//当前ProcessQueue是否被丢弃</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">dropped</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//上一次拉取时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastPullTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//上一次消费时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastConsumeTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br></pre></td></tr></table></figure><p><strong>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除消费超时消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanExpiredMsg</span><span class="params">(DefaultMQPushConsumer pushConsumer)</span></span><br><span class="line"><span class="comment">//添加消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span><br><span class="line"><span class="comment">//获取消息最大间隔</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getMaxSpan</span><span class="params">()</span></span><br><span class="line"><span class="comment">//移除消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">removeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span><br><span class="line"><span class="comment">//将consumingMsgOrderlyTreeMap中消息重新放在msgTreeMap,并清空consumingMsgOrderlyTreeMap   </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> </span><br><span class="line"><span class="comment">//将consumingMsgOrderlyTreeMap消息清除,表示成功处理该批消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">commit</span><span class="params">()</span></span><br><span class="line"><span class="comment">//重新处理该批消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeMessageToCosumeAgain</span><span class="params">(List&lt;MessageExt&gt; msgs)</span> </span><br><span class="line"><span class="comment">//从processQueue中取出batchSize条消息</span></span><br><span class="line"><span class="keyword">public</span> List&lt;MessageExt&gt; <span class="title function_">takeMessags</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> batchSize)</span></span><br></pre></td></tr></table></figure><h4 id="3）消息拉取基本流程"><a href="#3）消息拉取基本流程" class="headerlink" title="3）消息拉取基本流程"></a>3）消息拉取基本流程</h4><p>#####1.客户端发起拉取请求</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png"                      alt="img"                ></p><p><em><strong>代码：DefaultMQPushConsumerImpl#pullMessage</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> &#123;</span><br><span class="line">    <span class="comment">//从pullRequest获得ProcessQueue</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProcessQueue</span> <span class="variable">processQueue</span> <span class="operator">=</span> pullRequest.getProcessQueue();</span><br><span class="line">    <span class="comment">//如果处理队列被丢弃,直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (processQueue.isDropped()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;the pull request[&#123;&#125;] is dropped.&quot;</span>, pullRequest.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果处理队列未被丢弃,更新时间戳</span></span><br><span class="line">    pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.makeSureStateOK();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;pullMessage exception, consumer state not ok&quot;</span>, e);</span><br><span class="line">        <span class="built_in">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果处理队列被挂起,延迟1s后再执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isPause()) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;&quot;</span>, <span class="built_in">this</span>.defaultMQPushConsumer.getInstanceName(), <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">        <span class="built_in">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获得最大待处理消息数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">cachedMessageCount</span> <span class="operator">=</span> processQueue.getMsgCount().get();</span><br><span class="line">    <span class="comment">//获得最大待处理消息大小</span></span><br><span class="line"><span class="type">long</span> <span class="variable">cachedMessageSizeInMiB</span> <span class="operator">=</span> processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="comment">//从数量进行流控</span></span><br><span class="line"><span class="keyword">if</span> (cachedMessageCount &gt; <span class="built_in">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">    <span class="built_in">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">    <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        log.warn(</span><br><span class="line">            <span class="string">&quot;the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="built_in">this</span>.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从消息大小进行流控</span></span><br><span class="line"><span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="built_in">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">    <span class="built_in">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">    <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        log.warn(</span><br><span class="line">            <span class="string">&quot;the cached message size exceeds the threshold &#123;&#125; MiB, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="built_in">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得订阅信息</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">SubscriptionData</span> <span class="variable">subscriptionData</span> <span class="operator">=</span> <span class="built_in">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == subscriptionData) &#123;</span><br><span class="line">        <span class="built_in">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">        log.warn(<span class="string">&quot;find the consumer&#x27;s subscription failed, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//与服务端交互,获取消息</span></span><br><span class="line">    <span class="built_in">this</span>.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">    pullRequest.getMessageQueue(),</span><br><span class="line">    subExpression,</span><br><span class="line">    subscriptionData.getExpressionType(),</span><br><span class="line">    subscriptionData.getSubVersion(),</span><br><span class="line">    pullRequest.getNextOffset(),</span><br><span class="line">    <span class="built_in">this</span>.defaultMQPushConsumer.getPullBatchSize(),</span><br><span class="line">    sysFlag,</span><br><span class="line">    commitOffsetValue,</span><br><span class="line">    BROKER_SUSPEND_MAX_TIME_MILLIS,</span><br><span class="line">    CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,</span><br><span class="line">    CommunicationMode.ASYNC,</span><br><span class="line">    pullCallback</span><br><span class="line">);</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####2.消息服务端Broker组装消息</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%E7%AB%AFBroker%E7%BB%84%E8%A3%85%E6%B6%88%E6%81%AF.png"                      alt="img"                ></p><p><em><strong>代码：PullMessageProcessor#processRequest</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建消息过滤器</span></span><br><span class="line">MessageFilter messageFilter;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.brokerController.getBrokerConfig().isFilterSupportRetry()) &#123;</span><br><span class="line">    messageFilter = <span class="keyword">new</span> <span class="title class_">ExpressionForRetryMessageFilter</span>(subscriptionData, consumerFilterData,</span><br><span class="line">        <span class="built_in">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    messageFilter = <span class="keyword">new</span> <span class="title class_">ExpressionMessageFilter</span>(subscriptionData, consumerFilterData,</span><br><span class="line">        <span class="built_in">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用MessageStore.getMessage查找消息</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">GetMessageResult</span> <span class="variable">getMessageResult</span> <span class="operator">=</span></span><br><span class="line">    <span class="built_in">this</span>.brokerController.getMessageStore().getMessage(</span><br><span class="line">    requestHeader.getConsumerGroup(), <span class="comment">//消费组名称</span></span><br><span class="line">    requestHeader.getTopic(),<span class="comment">//主题名称</span></span><br><span class="line">        requestHeader.getQueueId(), <span class="comment">//队列ID</span></span><br><span class="line">    requestHeader.getQueueOffset(), <span class="comment">//待拉取偏移量</span></span><br><span class="line">    requestHeader.getMaxMsgNums(), <span class="comment">//最大拉取消息条数</span></span><br><span class="line">    messageFilter<span class="comment">//消息过滤器</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore#getMessage</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GetMessageStatus</span> <span class="variable">status</span> <span class="operator">=</span> GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line"><span class="type">long</span> <span class="variable">nextBeginOffset</span> <span class="operator">=</span> offset;<span class="comment">//查找下一次队列偏移量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">minOffset</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前消息队列最小偏移量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">maxOffset</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前消息队列最大偏移量</span></span><br><span class="line"><span class="type">GetMessageResult</span> <span class="variable">getResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetMessageResult</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxOffsetPy</span> <span class="operator">=</span> <span class="built_in">this</span>.commitLog.getMaxOffset();<span class="comment">//当前commitLog最大偏移量</span></span><br><span class="line"><span class="comment">//根据主题名称和队列编号获取消息消费队列</span></span><br><span class="line"><span class="type">ConsumeQueue</span> <span class="variable">consumeQueue</span> <span class="operator">=</span> findConsumeQueue(topic, queueId);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">minOffset = consumeQueue.getMinOffsetInQueue();</span><br><span class="line">maxOffset = consumeQueue.getMaxOffsetInQueue();</span><br><span class="line"><span class="comment">//消息偏移量异常情况校对下一次拉取偏移量</span></span><br><span class="line"><span class="keyword">if</span> (maxOffset == <span class="number">0</span>) &#123;<span class="comment">//表示当前消息队列中没有消息</span></span><br><span class="line">    status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line">    nextBeginOffset = nextOffsetCorrection(offset, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &lt; minOffset) &#123;<span class="comment">//待拉取消息的偏移量小于队列的其实偏移量</span></span><br><span class="line">    status = GetMessageStatus.OFFSET_TOO_SMALL;</span><br><span class="line">    nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset == maxOffset) &#123;<span class="comment">//待拉取偏移量为队列最大偏移量</span></span><br><span class="line">    status = GetMessageStatus.OFFSET_OVERFLOW_ONE;</span><br><span class="line">    nextBeginOffset = nextOffsetCorrection(offset, offset);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; maxOffset) &#123;<span class="comment">//偏移量越界</span></span><br><span class="line">    status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == minOffset) &#123;</span><br><span class="line">        nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextBeginOffset = nextOffsetCorrection(offset, maxOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//根据偏移量从CommitLog中拉取32条消息</span></span><br><span class="line"><span class="type">SelectMappedBufferResult</span> <span class="variable">selectResult</span> <span class="operator">=</span> <span class="built_in">this</span>.commitLog.getMessage(offsetPy, sizePy);</span><br></pre></td></tr></table></figure><p><em><strong>代码：PullMessageProcessor#processRequest</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据拉取结果填充responseHeader</span></span><br><span class="line">response.setRemark(getMessageResult.getStatus().name());</span><br><span class="line">responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());</span><br><span class="line">responseHeader.setMinOffset(getMessageResult.getMinOffset());</span><br><span class="line">responseHeader.setMaxOffset(getMessageResult.getMaxOffset());</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断如果存在主从同步慢,设置下一次拉取任务的ID为主节点</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">this</span>.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">    <span class="keyword">case</span> ASYNC_MASTER:</span><br><span class="line">    <span class="keyword">case</span> SYNC_MASTER:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SLAVE:</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//GetMessageResult与Response的Code转换</span></span><br><span class="line"><span class="keyword">switch</span> (getMessageResult.getStatus()) &#123;</span><br><span class="line">    <span class="keyword">case</span> FOUND:<span class="comment">//成功</span></span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MESSAGE_WAS_REMOVING:<span class="comment">//消息存放在下一个commitLog中</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);<span class="comment">//消息重试</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NO_MATCHED_LOGIC_QUEUE:<span class="comment">//未找到队列</span></span><br><span class="line">    <span class="keyword">case</span> NO_MESSAGE_IN_QUEUE:<span class="comment">//队列中未包含消息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != requestHeader.getQueueOffset()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">            requestHeader.getQueueOffset(),</span><br><span class="line">            getMessageResult.getNextBeginOffset(),</span><br><span class="line">            requestHeader.getTopic(),</span><br><span class="line">            requestHeader.getQueueId(),</span><br><span class="line">            requestHeader.getConsumerGroup()</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NO_MATCHED_MESSAGE:<span class="comment">//未找到消息</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_FOUND_NULL:<span class="comment">//消息物理偏移量为空</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_OVERFLOW_BADLY:<span class="comment">//offset越界</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">        <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">        log.info(<span class="string">&quot;the request offset: &#123;&#125; over flow badly, broker max offset: &#123;&#125;, consumer: &#123;&#125;&quot;</span>,</span><br><span class="line">                requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_OVERFLOW_ONE:<span class="comment">//offset在队列中未找到</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_TOO_SMALL:<span class="comment">//offset未在队列中</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">        requestHeader.getConsumerGroup(), </span><br><span class="line">        requestHeader.getTopic(), </span><br><span class="line">        requestHeader.getQueueOffset(),</span><br><span class="line">        getMessageResult.getMinOffset(), channel.remoteAddress());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果CommitLog标记可用,并且当前Broker为主节点,则更新消息消费进度</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">storeOffsetEnable</span> <span class="operator">=</span> brokerAllowSuspend;</span><br><span class="line">storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;</span><br><span class="line">storeOffsetEnable = storeOffsetEnable</span><br><span class="line">    &amp;&amp; <span class="built_in">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;</span><br><span class="line"><span class="keyword">if</span> (storeOffsetEnable) &#123;</span><br><span class="line">    <span class="built_in">this</span>.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</span><br><span class="line">        requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####3.消息拉取客户端处理消息</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF.png"                      alt="img"                ></p><p><em><strong>代码：MQClientAPIImpl#processPullResponse</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PullResult <span class="title function_">processPullResponse</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> RemotingCommand response)</span> <span class="keyword">throws</span> MQBrokerException, RemotingCommandException &#123;</span><br><span class="line">    <span class="type">PullStatus</span> <span class="variable">pullStatus</span> <span class="operator">=</span> PullStatus.NO_NEW_MSG;</span><br><span class="line">   <span class="comment">//判断响应结果</span></span><br><span class="line">    <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.SUCCESS:</span><br><span class="line">            pullStatus = PullStatus.FOUND;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line">            pullStatus = PullStatus.NO_NEW_MSG;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</span><br><span class="line">            pullStatus = PullStatus.NO_MATCHED_MSG;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_OFFSET_MOVED:</span><br><span class="line">            pullStatus = PullStatus.OFFSET_ILLEGAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQBrokerException</span>(response.getCode(), response.getRemark());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//解码响应头</span></span><br><span class="line">    <span class="type">PullMessageResponseHeader</span> <span class="variable">responseHeader</span> <span class="operator">=</span></span><br><span class="line">        (PullMessageResponseHeader) response.decodeCommandCustomHeader(PullMessageResponseHeader.class);</span><br><span class="line"><span class="comment">//封装PullResultExt返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PullResultExt</span>(pullStatus, responseHeader.getNextBeginOffset(), responseHeader.getMinOffset(),</span><br><span class="line">        responseHeader.getMaxOffset(), <span class="literal">null</span>, responseHeader.getSuggestWhichBrokerId(), response.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PullResult类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PullStatus pullStatus;<span class="comment">//拉取结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> nextBeginOffset;<span class="comment">//下次拉取偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> minOffset;<span class="comment">//消息队列最小偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> maxOffset;<span class="comment">//消息队列最大偏移量</span></span><br><span class="line"><span class="keyword">private</span> List&lt;MessageExt&gt; msgFoundList;<span class="comment">//拉取的消息列表</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/PullStatus.png"                      alt="img"                ></p><p><em><strong>代码：DefaultMQPushConsumerImpl$PullCallback#OnSuccess</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将拉取到的消息存入processQueue</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">dispatchToConsume</span> <span class="operator">=</span> processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line"><span class="comment">//将processQueue提交到consumeMessageService中供消费者消费</span></span><br><span class="line">DefaultMQPushConsumerImpl.<span class="built_in">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">    pullResult.getMsgFoundList(),</span><br><span class="line">    processQueue,</span><br><span class="line">    pullRequest.getMessageQueue(),</span><br><span class="line">    dispatchToConsume);</span><br><span class="line"><span class="comment">//如果pullInterval大于0,则等待pullInterval毫秒后将pullRequest对象放入到PullMessageService中的pullRequestQueue队列中</span></span><br><span class="line"><span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="built_in">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl.<span class="built_in">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">        DefaultMQPushConsumerImpl.<span class="built_in">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl.<span class="built_in">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-消息拉取总结"><a href="#4-消息拉取总结" class="headerlink" title="4.消息拉取总结"></a>4.消息拉取总结</h5><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93.png"                      alt="img"                ></p><h4 id="4）消息拉取长轮询机制分析"><a href="#4）消息拉取长轮询机制分析" class="headerlink" title="4）消息拉取长轮询机制分析"></a>4）消息拉取长轮询机制分析</h4><p>RocketMQ未真正实现消息推模式，而是消费者主动向消息服务器拉取消息，RocketMQ推模式是循环向消息服务端发起消息拉取请求，如果消息消费者向RocketMQ拉取消息时，消息未到达消费队列时，如果不启用长轮询机制，则会在服务端等待shortPollingTimeMills时间后（挂起）再去判断消息是否已经到达指定消息队列，如果消息仍未到达则提示拉取消息客户端PULL—NOT—FOUND（消息不存在）；如果开启长轮询模式，RocketMQ一方面会每隔5s轮询检查一次消息是否可达，同时一有消息达到后立马通知挂起线程再次验证消息是否是自己感兴趣的消息，如果是则从CommitLog文件中提取消息返回给消息拉取客户端，否则直到挂起超时，超时时间由消息拉取方在消息拉取是封装在请求参数中，PUSH模式为15s，PULL模式通过DefaultMQPullConsumer#setBrokerSuspendMaxTimeMillis设置。RocketMQ通过在Broker客户端配置longPollingEnable为true来开启长轮询模式。</p><p><em><strong>代码：PullMessageProcessor#processRequest</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当没有拉取到消息时，通过长轮询方式继续拉取消息</span></span><br><span class="line"><span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line">    <span class="keyword">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">pollingTimeMills</span> <span class="operator">=</span> suspendTimeoutMillisLong;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">            pollingTimeMills = <span class="built_in">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> requestHeader.getTopic();</span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> requestHeader.getQueueOffset();</span><br><span class="line">        <span class="type">int</span> <span class="variable">queueId</span> <span class="operator">=</span> requestHeader.getQueueId();</span><br><span class="line">        <span class="comment">//构建拉取请求对象</span></span><br><span class="line">        <span class="type">PullRequest</span> <span class="variable">pullRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PullRequest</span>(request, channel, pollingTimeMills,</span><br><span class="line">            <span class="built_in">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</span><br><span class="line">        <span class="comment">//处理拉取请求</span></span><br><span class="line">        <span class="built_in">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br><span class="line">        response = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>PullRequestHoldService方式实现长轮询</strong></p><p><em><strong>代码：PullRequestHoldService#suspendPullRequest</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将拉取消息请求，放置在ManyPullRequest集合中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">suspendPullRequest</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="type">int</span> queueId, <span class="keyword">final</span> PullRequest pullRequest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="built_in">this</span>.buildKey(topic, queueId);</span><br><span class="line">    <span class="type">ManyPullRequest</span> <span class="variable">mpr</span> <span class="operator">=</span> <span class="built_in">this</span>.pullRequestTable.get(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == mpr) &#123;</span><br><span class="line">        mpr = <span class="keyword">new</span> <span class="title class_">ManyPullRequest</span>();</span><br><span class="line">        <span class="type">ManyPullRequest</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="built_in">this</span>.pullRequestTable.putIfAbsent(key, mpr);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            mpr = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mpr.addPullRequest(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：PullRequestHoldService#run</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; service started&quot;</span>, <span class="built_in">this</span>.getServiceName());</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果开启长轮询每隔5秒判断消息是否到达</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有开启长轮询,每隔1s再次尝试</span></span><br><span class="line">              <span class="built_in">this</span>.waitForRunning(<span class="built_in">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">beginLockTimestamp</span> <span class="operator">=</span> <span class="built_in">this</span>.systemClock.now();</span><br><span class="line">            <span class="built_in">this</span>.checkHoldRequest();</span><br><span class="line">            <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> <span class="built_in">this</span>.systemClock.now() - beginLockTimestamp;</span><br><span class="line">            <span class="keyword">if</span> (costTime &gt; <span class="number">5</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;[NOTIFYME] check hold request cost &#123;&#125; ms.&quot;</span>, costTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.warn(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; service end&quot;</span>, <span class="built_in">this</span>.getServiceName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：PullRequestHoldService#checkHoldRequest</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历拉取任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkHoldRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String key : <span class="built_in">this</span>.pullRequestTable.keySet()) &#123;</span><br><span class="line">        String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> == kArray.length) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> kArray[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">queueId</span> <span class="operator">=</span> Integer.parseInt(kArray[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//获得消息偏移量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//通知有消息达到</span></span><br><span class="line">                <span class="built_in">this</span>.notifyMessageArriving(topic, queueId, offset);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;check hold request failed. topic=&#123;&#125;, queueId=&#123;&#125;&quot;</span>, topic, queueId, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：PullRequestHoldService#notifyMessageArriving</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果拉取消息偏移大于请求偏移量,如果消息匹配调用executeRequestWhenWakeup处理消息</span></span><br><span class="line"><span class="keyword">if</span> (newestOffset &gt; request.getPullFromThisOffset()) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConsumeQueueExt</span>.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));</span><br><span class="line">    <span class="comment">// match by bit map, need eval again when properties is not null.</span></span><br><span class="line">    <span class="keyword">if</span> (match &amp;&amp; properties != <span class="literal">null</span>) &#123;</span><br><span class="line">        match = request.getMessageFilter().isMatchedByCommitLog(<span class="literal">null</span>, properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                request.getRequestCommand());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;execute request when wakeup failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果过期时间超时,则不继续等待将直接返回给客户端消息未找到</span></span><br><span class="line"><span class="keyword">if</span> (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">            request.getRequestCommand());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;execute request when wakeup failed.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果开启了长轮询机制，PullRequestHoldService会每隔5s被唤醒去尝试检测是否有新的消息的到来才给客户端响应，或者直到超时才给客户端进行响应，消息实时性比较差，为了避免这种情况，RocketMQ引入另外一种机制：当消息到达时唤醒挂起线程触发一次检查。</p><p><strong>DefaultMessageStore$ReputMessageService机制</strong></p><p><em><strong>代码：DefaultMessageStore#start</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//长轮询入口</span></span><br><span class="line"><span class="built_in">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</span><br><span class="line"><span class="built_in">this</span>.reputMessageService.start();</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore$ReputMessageService#run</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    DefaultMessageStore.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//长轮询核心逻辑代码入口</span></span><br><span class="line">            <span class="built_in">this</span>.doReput();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            DefaultMessageStore.log.warn(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultMessageStore.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：DefaultMessageStore$ReputMessageService#deReput</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当新消息达到是,进行通知监听器进行处理</span></span><br><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">    &amp;&amp; DefaultMessageStore.<span class="built_in">this</span>.brokerConfig.isLongPollingEnable()) &#123;</span><br><span class="line">    DefaultMessageStore.<span class="built_in">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">        dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">        dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</span><br><span class="line">        dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：NotifyMessageArrivingListener#arriving</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">arriving</span><span class="params">(String topic, <span class="type">int</span> queueId, <span class="type">long</span> logicOffset, <span class="type">long</span> tagsCode,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> msgStoreTime, <span class="type">byte</span>[] filterBitMap, Map&lt;String, String&gt; properties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.pullRequestHoldService.notifyMessageArriving(topic, queueId, logicOffset, tagsCode,</span><br><span class="line">        msgStoreTime, filterBitMap, properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-5-消息队列负载与重新分布机制"><a href="#2-5-5-消息队列负载与重新分布机制" class="headerlink" title="2.5.5 消息队列负载与重新分布机制"></a>2.5.5 消息队列负载与重新分布机制</h3><p>RocketMQ消息队列重新分配是由RebalanceService线程来实现。一个MQClientInstance持有一个RebalanceService实现，并随着MQClientInstance的启动而启动。</p><p><em><strong>代码：RebalanceService#run</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>);</span><br><span class="line"><span class="comment">//RebalanceService线程默认每隔20s执行一次mqClientFactory.doRebalance方法</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.waitForRunning(waitInterval);</span><br><span class="line">        <span class="built_in">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：MQClientInstance#doRebalance</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRebalance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//MQClientInstance遍历以注册的消费者,对消费者执行doRebalance()方法</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class="built_in">this</span>.consumerTable.entrySet()) &#123;</span><br><span class="line">        <span class="type">MQConsumerInner</span> <span class="variable">impl</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                impl.doRebalance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;doRebalance exception&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：RebalanceImpl#doRebalance</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历订阅消息对每个主题的订阅的队列进行重新负载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> isOrder)</span> &#123;</span><br><span class="line">    Map&lt;String, SubscriptionData&gt; subTable = <span class="built_in">this</span>.getSubscriptionInner();</span><br><span class="line">    <span class="keyword">if</span> (subTable != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.rebalanceByTopic(topic, isOrder);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;rebalanceByTopic Exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.truncateMessageQueueNotMyTopic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：RebalanceImpl#rebalanceByTopic</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从主题订阅消息缓存表中获取主题的队列信息</span></span><br><span class="line">Set&lt;MessageQueue&gt; mqSet = <span class="built_in">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line"><span class="comment">//查找该主题订阅组所有的消费者ID</span></span><br><span class="line">List&lt;String&gt; cidAll = <span class="built_in">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给消费者重新分配队列</span></span><br><span class="line"><span class="keyword">if</span> (mqSet != <span class="literal">null</span> &amp;&amp; cidAll != <span class="literal">null</span>) &#123;</span><br><span class="line">    List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;();</span><br><span class="line">    mqAll.addAll(mqSet);</span><br><span class="line"></span><br><span class="line">    Collections.sort(mqAll);</span><br><span class="line">    Collections.sort(cidAll);</span><br><span class="line"></span><br><span class="line">    <span class="type">AllocateMessageQueueStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="built_in">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">    List&lt;MessageQueue&gt; allocateResult = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        allocateResult = strategy.allocate(</span><br><span class="line">            <span class="built_in">this</span>.consumerGroup,</span><br><span class="line">            <span class="built_in">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">            mqAll,</span><br><span class="line">            cidAll);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;&quot;</span>, strategy.getName(),</span><br><span class="line">            e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>RocketMQ默认提供5中负载均衡分配算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AllocateMessageQueueAveragely:平均分配</span><br><span class="line">举例:<span class="number">8</span>个队列q1,q2,q3,q4,q5,a6,q7,q8,消费者<span class="number">3</span>个:c1,c2,c3</span><br><span class="line">分配如下:</span><br><span class="line">c1:q1,q2,q3</span><br><span class="line">c2:q4,q5,a6</span><br><span class="line">c3:q7,q8</span><br><span class="line">AllocateMessageQueueAveragelyByCircle:平均轮询分配</span><br><span class="line">举例:<span class="number">8</span>个队列q1,q2,q3,q4,q5,a6,q7,q8,消费者<span class="number">3</span>个:c1,c2,c3</span><br><span class="line">分配如下:</span><br><span class="line">c1:q1,q4,q7</span><br><span class="line">c2:q2,q5,a8</span><br><span class="line">c3:q3,q6</span><br></pre></td></tr></table></figure><p>注意：消息队列的分配遵循一个消费者可以分配到多个队列，但同一个消息队列只会分配给一个消费者，故如果出现消费者个数大于消息队列数量，则有些消费者无法消费消息。</p><h3 id="2-5-6-消息消费过程"><a href="#2-5-6-消息消费过程" class="headerlink" title="2.5.6 消息消费过程"></a>2.5.6 消息消费过程</h3><p>PullMessageService负责对消息队列进行消息拉取，从远端服务器拉取消息后将消息存储ProcessQueue消息队列处理队列中，然后调用ConsumeMessageService#submitConsumeRequest方法进行消息消费，使用线程池来消费消息，确保了消息拉取与消息消费的解耦。ConsumeMessageService支持顺序消息和并发消息，核心类图如下：</p><p><img                       lazyload                     alt="image"                     data-src="https://pchaoo.gitee.io/blog/img/rocketmq/ConsumeMessageService.png"                      alt="img"                ></p><p><strong>并发消息消费</strong></p><p><em><strong>代码：ConsumeMessageConcurrentlyService#submitConsumeRequest</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息批次单次</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">consumeBatchSize</span> <span class="operator">=</span> <span class="built_in">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line"><span class="comment">//msgs.size()默认最多为32条。</span></span><br><span class="line"><span class="comment">//如果msgs.size()小于consumeBatchSize,则直接将拉取到的消息放入到consumeRequest,然后将consumeRequest提交到消费者线程池中</span></span><br><span class="line"><span class="keyword">if</span> (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">    <span class="type">ConsumeRequest</span> <span class="variable">consumeRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumeRequest</span>(msgs, processQueue, messageQueue);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        <span class="built_in">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//如果拉取的消息条数大于consumeBatchSize,则对拉取消息进行分页</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</span><br><span class="line">       List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</span><br><span class="line">               msgThis.add(msgs.get(total));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="type">ConsumeRequest</span> <span class="variable">consumeRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumeRequest</span>(msgThis, processQueue, messageQueue);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">           <span class="keyword">for</span> (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">               msgThis.add(msgs.get(total));</span><br><span class="line">    </span><br><span class="line">           <span class="built_in">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：ConsumeMessageConcurrentlyService$ConsumeRequest#run</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查processQueue的dropped,如果为true,则停止该队列消费。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;the message queue not be able to consume, because it&#x27;s dropped. group=&#123;&#125; &#123;&#125;&quot;</span>, ConsumeMessageConcurrentlyService.<span class="built_in">this</span>.consumerGroup, <span class="built_in">this</span>.messageQueue);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//执行消息处理的钩子函数</span></span><br><span class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="built_in">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext = <span class="keyword">new</span> <span class="title class_">ConsumeMessageContext</span>();</span><br><span class="line">    consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());</span><br><span class="line">    consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    consumeMessageContext.setProps(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;());</span><br><span class="line">    consumeMessageContext.setMq(messageQueue);</span><br><span class="line">    consumeMessageContext.setMsgList(msgs);</span><br><span class="line">    consumeMessageContext.setSuccess(<span class="literal">false</span>);</span><br><span class="line">    ConsumeMessageConcurrentlyService.<span class="built_in">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//调用应用程序消息监听器的consumeMessage方法,进入到具体的消息消费业务处理逻辑</span></span><br><span class="line">status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行消息处理后的钩子函数</span></span><br><span class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="built_in">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext.setStatus(status.toString());</span><br><span class="line">    consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);</span><br><span class="line">    ConsumeMessageConcurrentlyService.<span class="built_in">this</span>.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-7-定时消息机制"><a href="#2-5-7-定时消息机制" class="headerlink" title="2.5.7 定时消息机制"></a>2.5.7 定时消息机制</h3><p>定时消息是消息发送到Broker后，并不立即被消费者消费而是要等到特定的时间后才能被消费，RocketMQ并不支持任意的时间精度，如果要支持任意时间精度定时调度，不可避免地需要在Broker层做消息排序，再加上持久化方面的考量，将不可避免的带来巨大的性能消耗，所以RocketMQ只支持特定级别的延迟消息。消息延迟级别在Broker端通过messageDelayLevel配置，默认为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，delayLevel&#x3D;1表示延迟消息1s,delayLevel&#x3D;2表示延迟5s,依次类推。</p><p>RocketMQ定时消息实现类为ScheduleMessageService，该类在DefaultMessageStore中创建。通过在DefaultMessageStore中调用load方法加载该类并调用start方法启动。</p><p><em><strong>代码：ScheduleMessageService#load</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载延迟消息消费进度的加载与delayLevelTable的构造。延迟消息的进度默认存储路径为/store/config/delayOffset.json</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">load</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">super</span>.load();</span><br><span class="line">    result = result &amp;&amp; <span class="built_in">this</span>.parseDelayLevel();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：ScheduleMessageService#start</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历延迟队列创建定时任务,遍历延迟级别，根据延迟级别level从offsetTable中获取消费队列的消费进度。如果不存在，则使用0</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Long&gt; entry : <span class="built_in">this</span>.delayLevelTable.entrySet()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">level</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">timeDelay</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="built_in">this</span>.offsetTable.get(level);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == offset) &#123;</span><br><span class="line">        offset = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeDelay != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.timer.schedule(<span class="keyword">new</span> <span class="title class_">DeliverDelayedMessageTimerTask</span>(level, offset), FIRST_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每隔10s持久化一次延迟队列的消息消费进度</span></span><br><span class="line"><span class="built_in">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (started.get()) ScheduleMessageService.<span class="built_in">this</span>.persist();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;scheduleAtFixedRate flush exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">10000</span>, <span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</span><br></pre></td></tr></table></figure><p><strong>调度机制</strong></p><p>ScheduleMessageService的start方法启动后，会为每一个延迟级别创建一个调度任务，每一个延迟级别对应SCHEDULE_TOPIC_XXXX主题下的一个消息消费队列。定时调度任务的实现类为DeliverDelayedMessageTimerTask，核心实现方法为executeOnTimeup</p><p><em><strong>代码：ScheduleMessageService$DeliverDelayedMessageTimerTask#executeOnTimeup</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据队列ID与延迟主题查找消息消费队列</span></span><br><span class="line"><span class="type">ConsumeQueue</span> <span class="variable">cq</span> <span class="operator">=</span></span><br><span class="line">    ScheduleMessageService.<span class="built_in">this</span>.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,</span><br><span class="line">        delayLevel2QueueId(delayLevel));</span><br><span class="line">...</span><br><span class="line"><span class="comment">//根据偏移量从消息消费队列中获取当前队列中所有有效的消息</span></span><br><span class="line"><span class="type">SelectMappedBufferResult</span> <span class="variable">bufferCQ</span> <span class="operator">=</span> cq.getIndexBuffer(<span class="built_in">this</span>.offset);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//遍历ConsumeQueue,解析消息队列中消息</span></span><br><span class="line"><span class="keyword">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offsetPy</span> <span class="operator">=</span> bufferCQ.getByteBuffer().getLong();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sizePy</span> <span class="operator">=</span> bufferCQ.getByteBuffer().getInt();</span><br><span class="line">    <span class="type">long</span> <span class="variable">tagsCode</span> <span class="operator">=</span> bufferCQ.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cq.isExtAddr(tagsCode)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cq.getExt(tagsCode, cqExtUnit)) &#123;</span><br><span class="line">            tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//can&#x27;t find ext content.So re compute tags code.</span></span><br><span class="line">            log.error(<span class="string">&quot;[BUG] can&#x27;t find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;&quot;</span>,</span><br><span class="line">                tagsCode, offsetPy, sizePy);</span><br><span class="line">            <span class="type">long</span> <span class="variable">msgStoreTime</span> <span class="operator">=</span> defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);</span><br><span class="line">            tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">deliverTimestamp</span> <span class="operator">=</span> <span class="built_in">this</span>.correctDeliverTimestamp(now, tagsCode);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//根据消息偏移量与消息大小,从CommitLog中查找消息.</span></span><br><span class="line">  <span class="type">MessageExt</span> <span class="variable">msgExt</span> <span class="operator">=</span></span><br><span class="line">   ScheduleMessageService.<span class="built_in">this</span>.defaultMessageStore.lookMessageByOffset(</span><br><span class="line">       offsetPy, sizePy);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="2-5-8-顺序消息"><a href="#2-5-8-顺序消息" class="headerlink" title="2.5.8 顺序消息"></a>2.5.8 顺序消息</h3><p>顺序消息实现类是org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService</p><p><em><strong>代码：ConsumeMessageOrderlyService#start</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//如果消息模式为集群模式，启动定时任务，默认每隔20s执行一次锁定分配给自己的消息消费队列</span></span><br><span class="line">    <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="built_in">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</span><br><span class="line">        <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                ConsumeMessageOrderlyService.<span class="built_in">this</span>.lockMQPeriodically();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">1</span>, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：ConsumeMessageOrderlyService#submitConsumeRequest</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建消息任务,并提交消费线程池中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitConsumeRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> ProcessQueue processQueue,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> MessageQueue messageQueue,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> <span class="type">boolean</span> dispathToConsume)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dispathToConsume) &#123;</span><br><span class="line">        <span class="type">ConsumeRequest</span> <span class="variable">consumeRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumeRequest</span>(processQueue, messageQueue);</span><br><span class="line">        <span class="built_in">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>代码：ConsumeMessageOrderlyService$ConsumeRequest#run</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果消息队列为丢弃,则停止本次消费任务</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;run, the message queue not be able to consume, because it&#x27;s dropped. &#123;&#125;&quot;</span>, <span class="built_in">this</span>.messageQueue);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从消息队列中获取一个对象。然后消费消息时先申请独占objLock锁。顺序消息一个消息消费队列同一时刻只会被一个消费线程池处理</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objLock</span> <span class="operator">=</span> messageQueueLock.fetchLockObject(<span class="built_in">this</span>.messageQueue);</span><br><span class="line"><span class="keyword">synchronized</span> (objLock) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-9-小结"><a href="#2-5-9-小结" class="headerlink" title="2.5.9 小结"></a>2.5.9 小结</h3><p>RocketMQ消息消费方式分别为集群模式、广播模式。</p><p>消息队列负载由RebalanceService线程默认每隔20s进行一次消息队列负载，根据当前消费者组内消费者个数与主题队列数量按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消费队列，同一个消息消费队列同一个时间只会分配给一个消费者。</p><p>消息拉取由PullMessageService线程根据RebalanceService线程创建的拉取任务进行拉取，默认每次拉取32条消息，提交给消费者消费线程后继续下一次消息拉取。如果消息消费过慢产生消息堆积会触发消息消费拉取流控。</p><p>并发消息消费指消费线程池中的线程可以并发对同一个消息队列的消息进行消费，消费成功后，取出消息队列中最小的消息偏移量作为消息消费进度偏移量存储在于消息消费进度存储文件中，集群模式消息消费进度存储在Broker（消息服务器），广播模式消息消费进度存储在消费者端。</p><p>RocketMQ不支持任意精度的定时调度消息，只支持自定义的消息延迟级别，例如1s、2s、5s等，可通过在broker配置文件中设置messageDelayLevel。</p><p>顺序消息一般使用集群模式，是指对消息消费者内的线程池中的线程对消息消费队列只能串行消费。并并发消息消费最本质的区别是消息消费时必须成功锁定消息消费队列，在Broker端会存储消息消费队列的锁占用情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RocketMQ-03&quot;&gt;&lt;a href=&quot;#RocketMQ-03&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ-03&quot;&gt;&lt;/a&gt;RocketMQ-03&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.1 消息存储&lt;ul&gt;
&lt;li&gt;1.1.1 存储介质&lt;</summary>
      
    
    
    
    <category term="RocketMQ" scheme="http://example.com/categories/RocketMQ/"/>
    
    
    <category term="消息中间件" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发资源汇总</title>
    <link href="http://example.com/2023/02/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2023/02/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</id>
    <published>2023-02-18T23:00:21.610Z</published>
    <updated>2023-02-20T16:48:33.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序开发资源汇总"><a href="#微信小程序开发资源汇总" class="headerlink" title="微信小程序开发资源汇总"></a>微信小程序开发资源汇总</h1><p>本文收集了微信小程序开发过程中会使用到的资料、问题以及第三方组件库。本文不是一遍关于如何学习微信小程序的入门指南，也非参考手册，只是一些资料的整理。</p><p>本仓库中的资料整理自网络，也有一些来自网友的推荐。在<a class="link"   href="https://github.com/justjavac/awesome-wechat-weapp/graphs/contributors" >这里<i class="fas fa-external-link-alt"></i></a>可以看到项目贡献者的完整名单。</p><p>如果这个仓库对你有帮助，欢迎 star。如果这个仓库帮你提升了技能找到了工作，可以请我喝杯咖啡：</p><h2 id="QQ交流群"><a href="#QQ交流群" class="headerlink" title="QQ交流群"></a>QQ交流群</h2><ul><li><a class="link"   href="https://jq.qq.com/?_wv=1027&k=5vqgNd0" >微信小程序1号群<i class="fas fa-external-link-alt"></i></a>：593495800 （已满）</li><li><a class="link"   href="https://jq.qq.com/?_wv=1027&k=51d5Ckf" >微信小程序2号群<i class="fas fa-external-link-alt"></i></a>：578063690</li><li><a class="link"   href="https://jq.qq.com/?_wv=1027&k=5pNiKHt" >微信小程序3号群<i class="fas fa-external-link-alt"></i></a>：682463867</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-wechat.html#%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" >官方文档<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-wechat.html#%E5%B7%A5%E5%85%B7" >工具<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-wechat.html#%E6%8F%92%E4%BB%B6" >插件<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-wechat.html#%E7%BB%84%E4%BB%B6" >组件<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-wechat.html#demo" >Demo<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h2><ul><li><a class="link"   href="https://github.com/Tencent/wepy" >WePY：组件化的小程序开发框架<i class="fas fa-external-link-alt"></i></a> 💯</li><li><a class="link"   href="https://github.com/aben1188/awesome-wepy" >WePY 开发资源汇总<i class="fas fa-external-link-alt"></i></a> 💯</li></ul><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul><li><a class="link"   href="https://developers.weixin.qq.com/miniprogram/design/index.html" >小程序设计指南<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://developers.weixin.qq.com/miniprogram/dev/framework/" >小程序开发教程<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html" >小程序框架<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://developers.weixin.qq.com/miniprogram/dev/component/" >小程序组件<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://developers.weixin.qq.com/miniprogram/dev/api/" >小程序 API<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html" >小程序开发者工具<i class="fas fa-external-link-alt"></i></a></li></ul><p><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-wechat.html#%E7%9B%AE%E5%BD%95" >↑ 返回目录 ↑<i class="fas fa-external-link-alt"></i></a></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><a class="link"   href="https://github.com/NervJS/taro" >Taro ★24k+<i class="fas fa-external-link-alt"></i></a> - 使用 React 的方式开发小程序的框架，同时支持生成多端应用</li><li><a class="link"   href="https://github.com/Tencent/wepy" >WePY ★20k+<i class="fas fa-external-link-alt"></i></a> - 支持组件化的小程序开发框架</li><li><a class="link"   href="https://github.com/dcloudio/uni-app" >uni-app ★20k+<i class="fas fa-external-link-alt"></i></a> - 使用 Vue 语法开发小程序、H5、App的统一框架</li><li><a class="link"   href="https://github.com/Meituan-Dianping/mpvue" >mpvue ★19k+<i class="fas fa-external-link-alt"></i></a> - 基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系</li><li><a class="link"   href="https://github.com/didi/chameleon" >chameleon ★7k+<i class="fas fa-external-link-alt"></i></a> - 一套代码运行多端，一端所见即多端所见</li><li><a class="link"   href="https://github.com/wechat-miniprogram/kbone" >kbone ★2.8k+<i class="fas fa-external-link-alt"></i></a> - Web 与小程序同构解决方案</li><li><a class="link"   href="https://github.com/remaxjs/remax" >Remax ★2.4k+<i class="fas fa-external-link-alt"></i></a> - 使用真正的 React 构建小程序</li><li><a class="link"   href="https://github.com/chemzqm/wept" >wept ★2.3k<i class="fas fa-external-link-alt"></i></a> - 微信小程序实时运行环境</li><li><a class="link"   href="https://github.com/cytle/wechat_web_devtools" >wechat_web_devtools ★2.3k+<i class="fas fa-external-link-alt"></i></a> - Linux 下微信开发者工具</li><li><a class="link"   href="https://github.com/tencentyun/wafer" >wafer ★2.1k<i class="fas fa-external-link-alt"></i></a> - 快速构建具备弹性能力的微信小程序</li><li><a class="link"   href="https://github.com/didi/mpx" >MPX ★2.1k+<i class="fas fa-external-link-alt"></i></a> - 增强型小程序框架，深度性能优化，支持跨小程序平台开发，完全兼容原生小程序组件</li><li><a class="link"   href="https://github.com/maichong/labrador" >Labrador ★1.7k<i class="fas fa-external-link-alt"></i></a> - 支持 ES6&#x2F;7 的微信小程序组件化开发框架</li><li><a class="link"   href="https://github.com/liriliri/licia" >licia ★1.7k<i class="fas fa-external-link-alt"></i></a> - 支持小程序的 JS 工具库</li><li><a class="link"   href="https://github.com/kaola-fed/megalo" >megalo ★1.6k<i class="fas fa-external-link-alt"></i></a> - 基于 Vue 的小程序开发框架</li><li><a class="link"   href="https://github.com/tinajs/tina" >tina ★1k+<i class="fas fa-external-link-alt"></i></a> - 轻巧的渐进式微信小程序框架</li><li><a class="link"   href="https://github.com/qiu8310/minapp" >minapp ★800+<i class="fas fa-external-link-alt"></i></a> - TypeScript 版小程序开发框架（兼容原生小程序代码）</li><li><a class="link"   href="https://github.com/ecomfe/okam" >Okam ★300+<i class="fas fa-external-link-alt"></i></a> - 使用类 Vue 方式开发小程序的渐进增强框架，支持生成微信&#x2F;百度等主流平台的小程序</li><li><a class="link"   href="https://github.com/xpmjs/xpmjs" >xpmjs ★100+<i class="fas fa-external-link-alt"></i></a> - 微信小程序云端增强 SDK</li><li><a class="link"   href="https://github.com/Jeff2Ma/WeApp-Workflow" >WeApp-Workflow ★100+<i class="fas fa-external-link-alt"></i></a> - 基于 Gulp 的微信小程序前端开发工作流</li><li><a class="link"   href="https://github.com/mdsb100/gulp-wxa-copy-npm" >gulp-wxa-copy-npm<i class="fas fa-external-link-alt"></i></a> - 微信小程序 gulp 插件，解决 npm 包管理和 babel-runtime</li><li><a class="link"   href="https://github.com/haojy/weact" >weact<i class="fas fa-external-link-alt"></i></a> - 用 JSX 快速开发小程序</li><li><a class="link"   href="https://github.com/cytle/socket.io-mp-client" >socket.io-mp-client<i class="fas fa-external-link-alt"></i></a> - 微信小程序 socket.io 客户端</li><li><a class="link"   href="https://wxajs.github.io/wxa/" >@wxa<i class="fas fa-external-link-alt"></i></a> - AOP小程序开发框架</li><li><a class="link"   href="https://github.com/Genuifx/postcss-pxtorpx-pro" >postcss-pxtorpx-pro<i class="fas fa-external-link-alt"></i></a> - postcss px 转 rpx 插件</li><li><a class="link"   href="https://github.com/allanguys/px2rpx" >px2rpx<i class="fas fa-external-link-alt"></i></a> - Px 转 Rpx 在线工具</li><li><a class="link"   href="https://github.com/seanlong/wxml-parser" >wxml-parser<i class="fas fa-external-link-alt"></i></a> - JavaScript WXML parser</li><li><a class="link"   href="https://github.com/tolerance-go/weappx" >weappx<i class="fas fa-external-link-alt"></i></a> - 基于 redux 的数据层管理框架</li><li><a class="link"   href="https://github.com/tolerance-go/weapp-start" >weapp-start<i class="fas fa-external-link-alt"></i></a> - 基于插件机制的开发脚手架，改善原生小程序开发体验</li><li><a class="link"   href="http://developer.egret.com/cn/github/egret-docs/Wing/update/update320/index.html" >Egret Wing<i class="fas fa-external-link-alt"></i></a> - 支持微信小程序实时预览的 IDE</li><li><a class="link"   href="https://github.com/Authing/wxapp-graphql" >wxapp-graphql<i class="fas fa-external-link-alt"></i></a> - 小程序 GraphQL 客户端</li><li><a class="link"   href="https://github.com/ksky521/gulp-wxapp-boilerplate" >gulp-wxapp-boilerplate<i class="fas fa-external-link-alt"></i></a> - 小程序+小程序云 Gulp 开发脚手架，支持云函数 mock</li><li><a class="link"   href="https://github.com/cnyballk/wenaox" >wenaox<i class="fas fa-external-link-alt"></i></a> - 小程序数据层管理 ，轻量性能好，支持中间件</li><li><a class="link"   href="https://github.com/Authing/authing-wxapp-sdk" >authing-wxapp-sdk<i class="fas fa-external-link-alt"></i></a> - 身份认证 for 微信小程序</li><li><a class="link"   href="https://github.com/CoolRice/weapp-eslint-boilerplate" >weapp-eslint-boilerplate<i class="fas fa-external-link-alt"></i></a> - 微信小程序 Eslint 通用模板文件，节省自己配置的时间</li><li><a class="link"   href="https://iexception.github.io/anka-doc/book/index.html" >Anka<i class="fas fa-external-link-alt"></i></a> - 渐进式小程序开发工具集，提供通用的开发函数库及组件</li><li><a class="link"   href="https://github.com/BakerJQ/WeAppBunXin" >WeAppBunXin<i class="fas fa-external-link-alt"></i></a> - 微信小程序开发之影分身术，一套代码生成多个小程序</li><li><a class="link"   href="https://github.com/NewFuture/miniprogram-build" >miniprogram-build<i class="fas fa-external-link-alt"></i></a> - 小程序命令行编译工具(支持typescript,原生npm,资源文件压缩…)</li><li><a class="link"   href="https://github.com/caijw/wcc.js" >wcc.js<i class="fas fa-external-link-alt"></i></a> - wcc.js 是wxml文件和wxs文件编译器的nodejs实现</li><li><a class="link"   href="https://github.com/caijw/wcsc.js" >wcsc.js<i class="fas fa-external-link-alt"></i></a> - wcsc.js 是wxss文件编译器的nodejs实现</li><li><a class="link"   href="https://github.com/sunnie1992/weapp-gulp" >weapp-gulp<i class="fas fa-external-link-alt"></i></a> - Gulp高效构建微信小程序，让开发变得更简单</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li><a class="link"   href="https://github.com/chemzqm/wxapp.vim" >wxapp.vim<i class="fas fa-external-link-alt"></i></a> - 提供微信小程序开发全方位支持的 vim 插件</li><li><a class="link"   href="https://github.com/Abbotton/weapp-snippet-for-sublime-text-2-3" >weapp-snippet-for-sublime-text-2-3<i class="fas fa-external-link-alt"></i></a> - 为 sublime text 2&amp;3 准备的微信小程序 snippet(停更)</li><li><a class="link"   href="https://github.com/lypeer/Matchmaker" >Matchmaker<i class="fas fa-external-link-alt"></i></a> - IntelliJ IDEA 插件，注入方法</li><li><a class="link"   href="https://github.com/qbright/wechatCode-complete" >wechatCode-complete<i class="fas fa-external-link-alt"></i></a> - webstorm 插件（代码提示）</li><li><a class="link"   href="https://github.com/FloydaGithub/wxapp" >wxapp<i class="fas fa-external-link-alt"></i></a> - sublime plugin</li><li><a class="link"   href="https://github.com/qiu8310/minapp/blob/master/packages/minapp-vscode/README.md" >minapp<i class="fas fa-external-link-alt"></i></a> - vscode 插件（支持 原生&#x2F;mpvue&#x2F;wepy 框架）</li><li><a class="link"   href="https://segmentfault.com/a/1190000007132719" >vscode 插件(代码提示)<i class="fas fa-external-link-alt"></i></a>\</li><li><a class="link"   href="https://github.com/ritwickdey/vscode-live-sass-compiler" >vscode-live-sass-compiler<i class="fas fa-external-link-alt"></i></a> - vscode插件根据.scss文件自动生成wxss文件</li><li><a class="link"   href="http://wepy.iniself.com/" >WePY Plugin For IntelliJ Platform<i class="fas fa-external-link-alt"></i></a> - 让PhpStorm&#x2F;WebStorm全面支持WePY的开发，包括API(原生&#x2F;WePY)和组件(官方&#x2F;自定义)的自动完成&#x2F;错误检查&#x2F;高亮&#x2F;不依赖Vue&#x2F;…</li><li><a class="link"   href="https://github.com/cnyballk/wxml-vscode" >wxml<i class="fas fa-external-link-alt"></i></a> - vscode插件–微信小程序格式化以及高亮组件(高度自定义)</li><li><a class="link"   href="https://github.com/leafOfTree/vim-vue-plugin" >vim-vue-plugin<i class="fas fa-external-link-alt"></i></a> - vim 插件，.vue 和 .wpy 文件的语法高亮和缩进</li><li><a class="link"   href="https://github.com/wux-weapp/wux-weapp-snippets" >wux-weapp-snippets<i class="fas fa-external-link-alt"></i></a> - Wux Weapp Snippets for VS Code.</li><li><a class="link"   href="https://github.com/wux-weapp/wux-weapp-atom-snippets" >wux-weapp-atom-snippets<i class="fas fa-external-link-alt"></i></a> - Wux Weapp Snippets for Atom.</li><li><a class="link"   href="https://github.com/wux-weapp/wux-weapp-sublime-snippets" >wux-weapp-sublime-snippets<i class="fas fa-external-link-alt"></i></a> - Wux Weapp Snippets Plugin for Sublime Text 2&#x2F;3.</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li><a class="link"   href="https://github.com/Tencent/weui-wxss" >weui-wxss ★12.4K+<i class="fas fa-external-link-alt"></i></a> - 同微信原生视觉体验一致的基础样式库</li><li><a class="link"   href="https://github.com/youzan/vant-weapp" >vant-weapp ★12.3k+<i class="fas fa-external-link-alt"></i></a> - 高颜值、好用、易扩展的微信小程序 UI 库</li><li><a class="link"   href="https://github.com/icindy/wxParse" >wxParse ★7.2K+<i class="fas fa-external-link-alt"></i></a> - 微信小程序富文本解析自定义组件，支持 HTML 及 markdown 解析</li><li><a class="link"   href="https://github.com/TalkingData/iview-weapp" >iview-weapp ★5.5k+<i class="fas fa-external-link-alt"></i></a> - 一套高质量的微信小程序 UI 组件库</li><li><a class="link"   href="https://github.com/wux-weapp/wux-weapp" >wux-weapp ★4.2k+<i class="fas fa-external-link-alt"></i></a> - 一套组件化、可复用、易扩展的微信小程序 UI 组件库</li><li><a class="link"   href="https://github.com/xiaolin3303/wx-charts" >wx-charts ★4.1k+<i class="fas fa-external-link-alt"></i></a> - 微信小程序图表 charts 组件</li><li><a class="link"   href="https://github.com/TooBug/wemark" >wemark ★1.100+<i class="fas fa-external-link-alt"></i></a> - 微信小程序 Markdown 渲染库</li><li><a class="link"   href="https://github.com/o2team/wxapp-img-loader" >wxapp-img-loader ★400+<i class="fas fa-external-link-alt"></i></a> - 微信小程序图片预加载组件</li><li><a class="link"   href="https://github.com/we-plugin/we-cropper" >we-cropper ★400+<i class="fas fa-external-link-alt"></i></a> - 微信小程序图片裁剪工具</li><li><a class="link"   href="https://github.com/jasondu/wxa-plugin-canvas" >wxa-plugin-canvas ★300+<i class="fas fa-external-link-alt"></i></a> - 微信小程序朋友圈海报生成组件</li><li><a class="link"   href="https://github.com/guyoung/WeZRender" >WeZRender ★300+<i class="fas fa-external-link-alt"></i></a> - 微信小程序 Canvas 开发</li><li><a class="link"   href="https://github.com/treadpit/wx_calendar" >wx_calendar ★300+<i class="fas fa-external-link-alt"></i></a> - 小程序日历</li><li><a class="link"   href="https://github.com/youzouzou/wxapp" >wxapp ★300+<i class="fas fa-external-link-alt"></i></a> - 微信小程序组件</li><li><a class="link"   href="https://github.com/liujians/Wa-UI" >Wa-UI ★200+<i class="fas fa-external-link-alt"></i></a> - 针对微信小程序整合的一套 UI 库</li><li><a class="link"   href="https://github.com/icindy/wxSearch" >wxSearch ★200+<i class="fas fa-external-link-alt"></i></a> - 微信小程序优雅的搜索框</li><li><a class="link"   href="https://github.com/zhongjie-chen/wx-scrollable-tab-view" >wx-scrollable-tab-view ★200+<i class="fas fa-external-link-alt"></i></a> - 小程序可滑动得 tab-view</li><li><a class="link"   href="https://github.com/kiinlam/wetoast" >wetoast ★100+<i class="fas fa-external-link-alt"></i></a> - 微信小程序 toast 增强插件</li><li><a class="link"   href="https://github.com/zhongjie-chen/wx-alphabetical-listview" >wx-alphabetical-listview ★100+<i class="fas fa-external-link-alt"></i></a> - 微信小程序带字母滑动的 listview</li><li><a class="link"   href="https://github.com/zhongjie-chen/wx-drawer" >wx-drawer ★100+<i class="fas fa-external-link-alt"></i></a> - 小程序模仿 QQ6.0 侧滑菜单</li><li><a class="link"   href="https://github.com/hawx1993/wxapp-charts" >wxapp-charts ★100+<i class="fas fa-external-link-alt"></i></a> - 微信小程序图表 charts 组件</li><li><a class="link"   href="https://github.com/xiabingwu/chartjs-wechat-mini-app" >chartjs-wechat-mini-app ★100+<i class="fas fa-external-link-alt"></i></a> - chartjs 微信小程序适配</li><li><a class="link"   href="https://github.com/JoeZheng2015/wx-promise-request" >wx-promise-request ★100+<i class="fas fa-external-link-alt"></i></a> - 微信小程序请求队列管理库</li><li><a class="link"   href="https://github.com/we-plugin/we-swiper" >we-swiper ★100+<i class="fas fa-external-link-alt"></i></a> - 微信小程序触摸内容滑动解决方案</li><li><a class="link"   href="https://github.com/bobiscool/wxDraw" >wxDraw ★100+<i class="fas fa-external-link-alt"></i></a> - 微信小程序 2D 动画库</li><li><a class="link"   href="https://github.com/chenjinxinlove/citySelect" >citySelect ★100+<i class="fas fa-external-link-alt"></i></a> ★42 - 微信小程序城市选择器</li><li><a class="link"   href="https://github.com/charleslo1/weapp-cookie" >weapp-cookie ★100+<i class="fas fa-external-link-alt"></i></a> - 一行代码让微信小程序支持 cookie 🍪🚀</li><li><a class="link"   href="https://github.com/lidong1665/WeiXinProject" >WeiXinProject<i class="fas fa-external-link-alt"></i></a> - 微信小程序列表上拉刷新和上拉加载</li><li><a class="link"   href="https://github.com/CalvinHong/wepy-com-charts" >wepy-com-charts<i class="fas fa-external-link-alt"></i></a> - 微信小程序 wepy 图表控件</li><li><a class="link"   href="https://github.com/demi520/wxapp-lock" >wxapp-lock<i class="fas fa-external-link-alt"></i></a> - 微信小程序手势解锁</li><li><a class="link"   href="https://github.com/geminate/mini-gesture-lock" >mini-gesture-lock<i class="fas fa-external-link-alt"></i></a> - 微信小程序手势解锁(无Android Canvas卡顿问题)</li><li><a class="link"   href="https://github.com/weapp-socketio/weapp.socket.io" >weapp.socket.io<i class="fas fa-external-link-alt"></i></a> - socket.io 风格的 websocket 类库</li><li><a class="link"   href="https://github.com/leancloud/weapp-polyfill" >weapp-polyfill<i class="fas fa-external-link-alt"></i></a> - [w3c 标准 API polyfill</li><li><a class="link"   href="https://github.com/youngjuning/wxPromise" >wxPromise<i class="fas fa-external-link-alt"></i></a> - 微信小程序 Promise 库</li><li><a class="link"   href="https://github.com/youngjuning/wxMD5" >wxMD5<i class="fas fa-external-link-alt"></i></a> - 微信小程序 MD5 库</li><li><a class="link"   href="https://github.com/youngjuning/wxBase64" >wxBase64<i class="fas fa-external-link-alt"></i></a> - 微信小程序base64 库</li><li><a class="link"   href="https://github.com/ianho/xing-weapp-component" >xing-weapp-component<i class="fas fa-external-link-alt"></i></a> - 微信小程序基础组件扩展</li><li><a class="link"   href="https://github.com/ZzjBeatYou/wx-statuslayout" >wx-statuslayout<i class="fas fa-external-link-alt"></i></a> - 小程序页面状态切换组件</li><li><a class="link"   href="https://github.com/bigmeow/minapp-api-promise" >minapp-api-promise<i class="fas fa-external-link-alt"></i></a> - 微信小程序所有 API promise 化</li><li><a class="link"   href="https://github.com/bigmeow/minapp-slider-left" >minapp-slider-left<i class="fas fa-external-link-alt"></i></a> - 微信小程序左划删除组件</li><li><a class="link"   href="https://github.com/kuckboy1994/mp_canvas_drawer" >mp_canvas_drawer<i class="fas fa-external-link-alt"></i></a> - canvas绘制图片助手，一个json就制作分享朋友圈图片</li><li><a class="link"   href="https://github.com/ianho/xing-weapp-editor" >xing-weapp-editor<i class="fas fa-external-link-alt"></i></a> - 小程序图文编辑组件</li><li><a class="link"   href="https://github.com/WARJY/cue" >cue<i class="fas fa-external-link-alt"></i></a> - A WX Compontent Tools</li><li><a class="link"   href="https://github.com/phonycode/wuss-weapp" >wuss-weapp<i class="fas fa-external-link-alt"></i></a> - 一款高质量，组件齐全，高自定义的微信小程序UI组件库</li><li><a class="link"   href="https://github.com/pithyone/miniprogram-datepicker" >miniprogram-datepicker<i class="fas fa-external-link-alt"></i></a> - 小程序日期选择器（支持农历）</li><li><a class="link"   href="https://github.com/vv13/wx-api-promisify" >wx-api-promisify<i class="fas fa-external-link-alt"></i></a> - 优雅地将微信小程序API Promise化</li><li><a class="link"   href="https://github.com/iException/anka-brush" >anka-brush<i class="fas fa-external-link-alt"></i></a> - 一款为简化小程序里canvas画图操作而创建的工具库</li><li><a class="link"   href="https://github.com/iException/anka-tracker" >anka-tracker<i class="fas fa-external-link-alt"></i></a> - 小程序打点库，用于统计用户行为数据</li><li><a class="link"   href="https://github.com/Hzy0913/mpvue-calendar" >mpvue-calendar<i class="fas fa-external-link-alt"></i></a> - 微信小程序&#x2F;浏览器端的日历组件mpvue-calendar；基于mpvue平台 支持农历、按周切换、可自定义。</li><li><a class="link"   href="https://github.com/qizf7/mp-swipe-card" >mp-swipe-card<i class="fas fa-external-link-alt"></i></a> - 小程序卡片滑动组件,类似探探的效果，貌似现在只支持左右滑动</li><li><a class="link"   href="https://github.com/afishhhhh/weapp.request" >weapp.request<i class="fas fa-external-link-alt"></i></a> - 为微信小程序提供的网络请求组件，是 wx.request 的扩展，基于 Promise API，添加缓存控制。</li><li><a class="link"   href="https://github.com/NewFuture/miniprogram-network" >miniprogram-network<i class="fas fa-external-link-alt"></i></a> - Redefine the Network API of MiniProgram(小程序网络请求库)</li><li><a class="link"   href="https://github.com/ChanceYu/we-validator" >we-validator<i class="fas fa-external-link-alt"></i></a> - 简单灵活的表单验证插件，支持小程序、浏览器以及Nodejs端使用。</li><li><a class="link"   href="https://github.com/zhongxuqi/wx-pulltorefresh-view" >wx-pulltorefresh-view<i class="fas fa-external-link-alt"></i></a> - 简单灵活的下拉上拉刷新组件，支持微信小程序</li><li><a class="link"   href="https://github.com/sunniejs/sol-weapp/" >sol-weapp ★300+<i class="fas fa-external-link-alt"></i></a> -微信小程序营销组件:红包雨、大转盘等营销组件</li><li><a class="link"   href="https://github.com/xjh22222228/weapp-input-frame" >weapp-input-frame<i class="fas fa-external-link-alt"></i></a> - 微信小程序验证码输入框组件</li><li><a class="link"   href="https://github.com/dlhandsome/we-debug" >we-debug<i class="fas fa-external-link-alt"></i></a> - 一款灵活、易于拓展的微信小程序调试工具</li></ul><p>)</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><ul><li><a class="link"   href="https://github.com/EastWorld/wechat-app-mall" >EastWorld&#x2F;wechat-app-mall ★3000+<i class="fas fa-external-link-alt"></i></a> - 微信小程序商城</li><li><a class="link"   href="https://github.com/tumobi/nideshop-mini-program" >tumobi&#x2F;nideshop-mini-program ★2000+<i class="fas fa-external-link-alt"></i></a> - 基于 Node.js + MySQL 开发的开源微信小程序商城</li><li><a class="link"   href="https://github.com/RebeccaHanjw/weapp-wechat-zhihu" >RebeccaHanjw&#x2F;weapp-wechat-zhihu ★800+<i class="fas fa-external-link-alt"></i></a> - 仿知乎</li><li><a class="link"   href="https://github.com/huangjianke/Gitter" >huangjianke&#x2F;Gitter ★700+<i class="fas fa-external-link-alt"></i></a> - Gitter for GitHub - 可能是目前颜值最高的GitHub小程序客户端</li><li><a class="link"   href="https://github.com/lypeer/wechat-weapp-gank" >lypeer&#x2F;wechat-weapp-gank ★600+)<i class="fas fa-external-link-alt"></i></a> - Gank 客户端</li><li><a class="link"   href="https://github.com/wangmingjob/weapp-weipiao" >wangmingjob&#x2F;weapp-weipiao ★300+<i class="fas fa-external-link-alt"></i></a> - 微票</li><li><a class="link"   href="https://github.com/charleyw/wechat-weapp-redux" >charleyw&#x2F;wechat-weapp-redux ★300+<i class="fas fa-external-link-alt"></i></a> - Redux 绑定库</li><li><a class="link"   href="https://github.com/jectychen/wechat-v2ex" >jectychen&#x2F;wechat-v2ex ★300+)<i class="fas fa-external-link-alt"></i></a> - V2EX</li><li><a class="link"   href="https://github.com/18380435477/WeApp" >18380435477&#x2F;WeApp ★300+<i class="fas fa-external-link-alt"></i></a> - 仿微信</li><li><a class="link"   href="https://github.com/zce/weapp-boilerplate" >zce&#x2F;weapp-boilerplate ★300+<i class="fas fa-external-link-alt"></i></a> - 微信小程序快速开发骨架</li><li><a class="link"   href="https://github.com/bayetech/wechat_mall_applet" >bayetech&#x2F;wechat_mall_applet ★300+<i class="fas fa-external-link-alt"></i></a> - 电商平台</li><li><a class="link"   href="https://github.com/lanshan-studio/wecqupt" >lanshan-studio&#x2F;wecqupt ★300+<i class="fas fa-external-link-alt"></i></a> - We 重邮</li><li><a class="link"   href="https://github.com/imageslr/weapp-library" >imageslr&#x2F;weapp-library ★300+<i class="fas fa-external-link-alt"></i></a> - 在线借书平台（WeUI设计规范、前后端开源、RESTful API文档）</li><li><a class="link"   href="https://github.com/myronliu347/wechat-app-zhihudaily" >myronliu347&#x2F;wechat-app-zhihudaily ★200+<i class="fas fa-external-link-alt"></i></a> - 知乎日报</li><li><a class="link"   href="https://github.com/harveyqing/BearDiary" >harveyqing&#x2F;BearDiary ★200+<i class="fas fa-external-link-alt"></i></a> - 小熊の日记</li><li><a class="link"   href="https://github.com/leancloud/leantodo-weapp" >leancloud&#x2F;leantodo-weapp ★200+<i class="fas fa-external-link-alt"></i></a> - 集成 LeanCloud 实现的 Todo list</li><li><a class="link"   href="https://github.com/SuperKieran/weapp-artand" >SuperKieran&#x2F;weapp-artand ★200+<i class="fas fa-external-link-alt"></i></a> - Artand</li><li><a class="link"   href="https://github.com/dongweiming/weapp-zhihulive" >dongweiming&#x2F;weapp-zhihulive ★200+<i class="fas fa-external-link-alt"></i></a> - 知乎 Live</li><li><a class="link"   href="https://github.com/eyasliu/wechat-app-music" >eyasliu&#x2F;wechat-app-music ★200+<i class="fas fa-external-link-alt"></i></a> - 音乐播放器</li><li><a class="link"   href="https://github.com/ahonn/weapp-one" >ahonn&#x2F;weapp-one ★200+<i class="fas fa-external-link-alt"></i></a> - 仿 ONE</li><li><a class="link"   href="https://github.com/giscafer/wechat-weapp-mapdemo" >giscafer&#x2F;wechat-weapp-mapdemo ★200+<i class="fas fa-external-link-alt"></i></a> - 地图导航、marker标注 （不再维护）</li><li><a class="link"   href="https://github.com/yaoshanliang/weapp-ssha" >yaoshanliang&#x2F;weapp-ssha ★200+<i class="fas fa-external-link-alt"></i></a> - 企业宣传小程序</li><li><a class="link"   href="https://github.com/hilongjw/weapp-gold" >hilongjw&#x2F;weapp-gold ★100+<i class="fas fa-external-link-alt"></i></a> - 掘金主页信息流</li><li><a class="link"   href="https://github.com/zce/weapp-douban" >zce&#x2F;weapp-douban ★100+<i class="fas fa-external-link-alt"></i></a> - 豆瓣电影</li><li><a class="link"   href="https://github.com/hingsir/weapp-douban-film" >hingsir&#x2F;weapp-douban-film ★100+<i class="fas fa-external-link-alt"></i></a> - 豆瓣电影</li><li><a class="link"   href="https://github.com/kunkun12/weapp" >kunkun12&#x2F;weapp<i class="fas fa-external-link-alt"></i></a> - 小程序 hello world 尝鲜</li><li><a class="link"   href="https://github.com/natee/wxapp-2048" >natee&#x2F;wxapp-2048 ★100+<i class="fas fa-external-link-alt"></i></a> - 2048 小游戏</li><li><a class="link"   href="https://github.com/SeptemberMaples/wechat-weapp-demo" >SeptemberMaples&#x2F;wechat-weapp-demo ★100+<i class="fas fa-external-link-alt"></i></a> - 购物车</li><li><a class="link"   href="https://github.com/hijiangtao/weapp-newsapp" >hijiangtao&#x2F;weapp-newsapp<i class="fas fa-external-link-alt"></i></a> - 公众号热门文章信息流</li><li><a class="link"   href="https://github.com/charleyw/wechat-weapp-redux-todos" >charleyw&#x2F;wechat-weapp-redux-todos ★100+<i class="fas fa-external-link-alt"></i></a> - 集成 Redux 实现的Todo list</li><li><a class="link"   href="https://github.com/kraaas/timer" >kraaas&#x2F;timer ★100+<i class="fas fa-external-link-alt"></i></a> - 番茄时钟</li><li><a class="link"   href="https://github.com/ericzyh/wechat-chat" >ericzyh&#x2F;wechat-chat ★100+<i class="fas fa-external-link-alt"></i></a> - 聊天室</li><li><a class="link"   href="https://github.com/BelinChung/wxapp-hiapp" >BelinChung&#x2F;wxapp-hiapp ★100+<i class="fas fa-external-link-alt"></i></a> - HiApp</li><li><a class="link"   href="https://github.com/hardog/wechat-app-flexlayout" >hardog&#x2F;wechat-app-flexlayout ★100+<i class="fas fa-external-link-alt"></i></a> - flexlayout</li><li><a class="link"   href="https://github.com/dunizb/wxapp-sCalc" >dunizb&#x2F;wxapp-sCalc ★100+<i class="fas fa-external-link-alt"></i></a> - 简易计算器</li><li><a class="link"   href="https://github.com/litt1e-p/weapp-girls" >litt1e-p&#x2F;weapp-girls ★100+<i class="fas fa-external-link-alt"></i></a> - 豆瓣美女&#x2F;妹子图</li><li><a class="link"   href="https://github.com/liumulin614/BeautifulGirl" >liumulin614&#x2F;BeautifulGirl<i class="fas fa-external-link-alt"></i></a> - 美女模特</li><li><a class="link"   href="https://github.com/romoo/weapp-demo-breadtrip" >romoo&#x2F;weapp-demo-breadtrip ★100+<i class="fas fa-external-link-alt"></i></a> - 面包旅行</li><li><a class="link"   href="https://github.com/zhuweiyou/fetop100" >zhuweiyou&#x2F;fetop100 ★100+<i class="fas fa-external-link-alt"></i></a> - 前端TOP100</li><li><a class="link"   href="https://github.com/vace/wechatapp-news-reader" >vace&#x2F;wechatapp-news-reader ★100+<i class="fas fa-external-link-alt"></i></a> - 新闻阅读器</li><li><a class="link"   href="https://github.com/yaoshanliang/weapp-jump" >yaoshanliang&#x2F;weapp-jump ★100+<i class="fas fa-external-link-alt"></i></a> - 跳一跳</li><li><a class="link"   href="https://github.com/yaoshanliang/weapp-monument-valley" >yaoshanliang&#x2F;weapp-monument-valley ★100+<i class="fas fa-external-link-alt"></i></a> - 纪念碑谷</li><li><a class="link"   href="https://github.com/Symous/WechatApp-BaisiSister" >Symous&#x2F;WechatApp-BaisiSister<i class="fas fa-external-link-alt"></i></a> - 百思不得姐</li><li><a class="link"   href="https://github.com/githinkcn/Giteer" >githinkcn&#x2F;Giteer<i class="fas fa-external-link-alt"></i></a> - Giteer For 码云，基于Taro + Taro UI + Dva的小程序。</li><li><a class="link"   href="https://github.com/DengKe1994/weapp-calculator" >DengKe1994&#x2F;weapp-calculator<i class="fas fa-external-link-alt"></i></a> - IOS 计算器</li><li><a class="link"   href="https://github.com/monkindey/wx-github" >monkindey&#x2F;wx-github<i class="fas fa-external-link-alt"></i></a> - GitHub 简历</li><li><a class="link"   href="https://github.com/fluency03/weapp-500px" >fluency03&#x2F;weapp-500px<i class="fas fa-external-link-alt"></i></a> - 国外摄影社区 500px</li><li><a class="link"   href="https://github.com/luuman/weapp-film" >weapp-film<i class="fas fa-external-link-alt"></i></a> - 淘票票</li><li><a class="link"   href="https://github.com/xujinyang/CoderCalendar-WeApp" >xujinyang&#x2F;CoderCalendar-WeApp<i class="fas fa-external-link-alt"></i></a> - 程序员老黄历</li><li><a class="link"   href="https://github.com/zhengxiaowai/weapp-github" >zhengxiaowai&#x2F;weapp-github<i class="fas fa-external-link-alt"></i></a> - github</li><li><a class="link"   href="https://github.com/SeaHub/PigRaising" >Seahub&#x2F;PigRaising<i class="fas fa-external-link-alt"></i></a> - PigRaising</li><li><a class="link"   href="https://github.com/brucevanfdm/WeChatMeiZhi" >brucevanfdm&#x2F;WeChatMeiZhi<i class="fas fa-external-link-alt"></i></a> - 妹子图</li><li><a class="link"   href="https://github.com/zhijieeeeee/wechat-app-joke" >zhijieeeeee&#x2F;wechat-app-joke<i class="fas fa-external-link-alt"></i></a> - 开心一刻</li><li><a class="link"   href="https://github.com/uniquexiaobai/wechat-app-githubfeed" >uniquexiaobai&#x2F;wechat-app-githubfeed<i class="fas fa-external-link-alt"></i></a> - GitHubFeed</li><li><a class="link"   href="https://github.com/zce/weapp-todos" >zce&#x2F;weapp-todos<i class="fas fa-external-link-alt"></i></a> - TODOS 任务清单</li><li><a class="link"   href="https://github.com/bruintong/wechat-webapp-douban-movie" >bruintong&#x2F;wechat-webapp-douban-movie<i class="fas fa-external-link-alt"></i></a> - 豆瓣电影</li><li><a class="link"   href="https://github.com/bruintong/wechat-webapp-douban-location" >bruintong&#x2F;wechat-webapp-douban-location<i class="fas fa-external-link-alt"></i></a> - 豆瓣同城</li><li><a class="link"   href="https://github.com/arkilis/weapp-jandan" >arkilis&#x2F;weapp-jandan<i class="fas fa-external-link-alt"></i></a> - 煎蛋</li><li><a class="link"   href="https://github.com/bodekjan/wechat-weather" >bodekjan&#x2F;wechat-weather<i class="fas fa-external-link-alt"></i></a> - 微信天气</li><li><a class="link"   href="https://github.com/jasscia/ChristmasHat" >jasscia&#x2F;ChristmasHat<i class="fas fa-external-link-alt"></i></a> - 我要圣诞帽</li><li><a class="link"   href="https://github.com/nanwangjkl/sliding_puzzle" >nanwangjkl&#x2F;sliding_puzzle<i class="fas fa-external-link-alt"></i></a> - 滑块拼图</li><li><a class="link"   href="https://github.com/kaiwu/weui-scalajs" >kaiwu&#x2F;weui-scalajs<i class="fas fa-external-link-alt"></i></a> - 使用Scala.js开发</li><li><a class="link"   href="https://github.com/tinajs/tina-hackernews" >tinajs&#x2F;tina-hackernews<i class="fas fa-external-link-alt"></i></a> - Hacker News 热点</li><li><a class="link"   href="https://github.com/mohuishou/scuplus-wechat" >mohuishou&#x2F;scuplus-wechat<i class="fas fa-external-link-alt"></i></a> - We 川大</li><li><a class="link"   href="https://github.com/hankzhuo/wx-v2ex" >hankzhuo&#x2F;wx-v2ex<i class="fas fa-external-link-alt"></i></a> - v2ex</li><li><a class="link"   href="https://github.com/Hongye567/weapp-mark" >Hongye567&#x2F;weapp-mark<i class="fas fa-external-link-alt"></i></a> - 仿 Mark 影单的微信小程序</li><li><a class="link"   href="https://github.com/w1109790800/We-Todo" >w1109790800&#x2F;We-Todo<i class="fas fa-external-link-alt"></i></a> - 基于LeanCloud的Todo-List</li><li><a class="link"   href="https://github.com/jae-jae/weapp-github-trending" >jae-jae&#x2F;weapp-github-trending<i class="fas fa-external-link-alt"></i></a> - Github今日榜单</li><li><a class="link"   href="https://github.com/steedos/mini-vip" >steedos&#x2F;mini-vip<i class="fas fa-external-link-alt"></i></a> - 华炎微站、微商城</li><li><a class="link"   href="https://github.com/alex1504/wx-guita_tab" >alex1504&#x2F;wx-guita_tab<i class="fas fa-external-link-alt"></i></a> - 口袋吉他</li><li><a class="link"   href="https://github.com/lonnng/etym" >lonnng&#x2F;etym<i class="fas fa-external-link-alt"></i></a> - 芒果词源助手</li><li><a class="link"   href="https://github.com/wuhou123/wxxcx" >wuhou123&#x2F;wxxcx<i class="fas fa-external-link-alt"></i></a> - 武侯的猫，基于wepy构建,整合了n多查询工具（快递，天气，记账，搞笑视频等）</li><li><a class="link"   href="https://github.com/upupming/HITMers" >upupming&#x2F;HITMers<i class="fas fa-external-link-alt"></i></a> - 博物馆小助手（统计值班表、签到、值班日历及备忘录、国际化、Streamable.com 视频上传等）</li><li><a class="link"   href="https://github.com/LDouble/WeOUC" >LDouble&#x2F;WeOUC<i class="fas fa-external-link-alt"></i></a> - WeOUC(教务小程序)</li><li><a class="link"   href="https://github.com/Airmole/ShellBox" >Airmole&#x2F;ShellBox<i class="fas fa-external-link-alt"></i></a> - 贝壳小盒子（校园教务信息查询类工具，获2019高校小程序开发大赛华北区二等奖）</li><li><a class="link"   href="https://github.com/aquanlerou/WeHalo" >aquanlerou&#x2F;WeHalo ★200+<i class="fas fa-external-link-alt"></i></a> - 爱敲代码的猫（WeHalo 简约风 的微信小程序版博客✨）</li><li><a class="link"   href="https://github.com/WarpPrism/SubwayRoutineMP" >WarpPrism&#x2F;SubwayRoutineMP<i class="fas fa-external-link-alt"></i></a> - 【东京首尔曼谷新加坡巴黎地铁线路图🚄】</li><li><a class="link"   href="https://github.com/GoKu-gaga/today" >GoKu-gaga&#x2F;today<i class="fas fa-external-link-alt"></i></a> - 口袋工具（一个小工具的集合）</li><li><a class="link"   href="https://github.com/cy920820/weapp-motor-movies" >cy920820&#x2F;weapp-motor-movies<i class="fas fa-external-link-alt"></i></a> - 马达电影助手（一个院线电影小助手）</li><li><a class="link"   href="https://github.com/Gwokhov/chronus" >Gwokhov&#x2F;chronus<i class="fas fa-external-link-alt"></i></a> - Chronus 目标日记（一款能帮助你管理生活目标的云开发微信小程序）</li><li><a class="link"   href="https://github.com/imliubo/Wechat_MQTT_ESP8266_BaiduIoT" >imliubo&#x2F;Wechat_MQTT_ESP8266_BaiduIoT<i class="fas fa-external-link-alt"></i></a> - 微信智能小管家 (使用微信小程序控制你的硬件设备)</li><li><a class="link"   href="https://github.com/yuzexia/iw3cplus" >yuzexia&#x2F;iw3cplus<i class="fas fa-external-link-alt"></i></a> - 前端社区<a class="link"   href="https://www.w3cplus.com/" >www.w3cplus.com<i class="fas fa-external-link-alt"></i></a>的微信小程序</li><li><a class="link"   href="https://github.com/RAOE/show-videos" >RAOE&#x2F;show-videos<i class="fas fa-external-link-alt"></i></a> - 秀视频（微信小程序短视频社交软件，视频上传，音视频合成，评论，点赞，转发，分享等）</li><li><a class="link"   href="https://github.com/NewFuture/miniprogram-template" >NewFuture&#x2F;miniprogram-template<i class="fas fa-external-link-alt"></i></a> - 原生API纯TypeScript开发小程序(VSCode as IDE)与完整开发流程</li><li><a class="link"   href="https://github.com/ZhuPeng/mp-githubtrending" >ZhuPeng&#x2F;mp-githubtrending<i class="fas fa-external-link-alt"></i></a> - 以 Feed 流形式查看 GitHub Trending 仓库集合的工具</li><li><a class="link"   href="https://github.com/yociduo/scrum-planning-poker" >yociduo&#x2F;scrum-planning-poker<i class="fas fa-external-link-alt"></i></a> - Scrum敏捷估算,基于wepy构建</li><li><a class="link"   href="https://github.com/lsqy/taro-music" >lsqy&#x2F;taro-music<i class="fas fa-external-link-alt"></i></a> - 🎉基于taro + taro-ui + redux + typescript 开发的网易云音乐小程序</li><li><a class="link"   href="https://github.com/Notobey/Himalayan-lite" >仿喜马拉雅lite<i class="fas fa-external-link-alt"></i></a> - 微信小程序原生开发的仿喜马拉雅小程序（极度适合新手入门）</li><li><a class="link"   href="https://github.com/BranLiang/game-stop-app" >branliang&#x2F;game-stop-app<i class="fas fa-external-link-alt"></i></a> - PSN降价了（一个可以订阅PS4游戏价格的工具）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信小程序开发资源汇总&quot;&gt;&lt;a href=&quot;#微信小程序开发资源汇总&quot; class=&quot;headerlink&quot; title=&quot;微信小程序开发资源汇总&quot;&gt;&lt;/a&gt;微信小程序开发资源汇总&lt;/h1&gt;&lt;p&gt;本文收集了微信小程序开发过程中会使用到的资料、问题以及第三方组件库。</summary>
      
    
    
    
    <category term="微信小程序" scheme="http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="资源" scheme="http://example.com/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>CSS资源大全中文版</title>
    <link href="http://example.com/2023/02/19/CSS%20%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8%E4%B8%AD%E6%96%87%E7%89%88/"/>
    <id>http://example.com/2023/02/19/CSS%20%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8%E4%B8%AD%E6%96%87%E7%89%88/</id>
    <published>2023-02-18T23:00:21.608Z</published>
    <updated>2023-02-20T16:47:20.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-资源大全中文版"><a href="#CSS-资源大全中文版" class="headerlink" title="CSS 资源大全中文版"></a>CSS 资源大全中文版</h1><p>我想很多程序员应该记得 GitHub 上有一个 Awesome：XXX 系列的资源整理。[awesome-css] 是 sotayamashita 发起维护的 CSS 资源列表，内容包括：CSS预处理器、框架、CSS结构、代码风格指南、命名习惯、播客、演讲视频、大网站的 CSS 开发经验等等。</p><p>Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。</p><hr><h3 id="我们要做什么？"><a href="#我们要做什么？" class="headerlink" title="我们要做什么？"></a>我们要做什么？</h3><ul><li>基于 awesome-css 列表，我们将对其中的各个资源项进行编译整理。此外还将从其他来源补充好资源。</li><li>整理后的内容，将收录在<a class="link"   href="http://hao.importnew.com/" >伯乐在线资源频道<i class="fas fa-external-link-alt"></i></a>。可参考已整理的内容： ：《<a class="link"   href="http://hao.importnew.com/bem/" >BEM：前端命名方法论<i class="fas fa-external-link-alt"></i></a>》 ：《<a class="link"   href="http://hao.importnew.com/sass-css/" >Sass：CSS预处理器<i class="fas fa-external-link-alt"></i></a>》 ：《<a class="link"   href="http://hao.importnew.com/yui-compressor/" >YUI Compressor：JS&#x2F;CSS压缩工具<i class="fas fa-external-link-alt"></i></a>》</li></ul><hr><h3 id="如何参与本项目？"><a href="#如何参与本项目？" class="headerlink" title="如何参与本项目？"></a>如何参与本项目？</h3><hr><h3 id="如何为列表贡献新资源？"><a href="#如何为列表贡献新资源？" class="headerlink" title="如何为列表贡献新资源？"></a>如何为列表贡献新资源？</h3><p>欢迎大家为列表贡献高质量的新资源，提交PR时请参照以下要求：</p><ul><li>请确保推荐的资源自己使用过</li><li>提交PR时请注明推荐理由</li></ul><p>资源列表管理收到PR请求后，会定期（每周）在微博转发本周提交的PR列表，并在微博上面听取使用过这些资源的意见。确认通过后，会加入资源大全。</p><p>感谢您的贡献！</p><hr><h3 id="本项目的参与者"><a href="#本项目的参与者" class="headerlink" title="本项目的参与者"></a>本项目的参与者</h3><ul><li>维护者：<a class="link"   href="https://github.com/tangyouhua" >tangyouhua<i class="fas fa-external-link-alt"></i></a></li><li>贡献者：iLeo、<a class="link"   href="http://www.importnew.com/members/aoi/" >伯小乐<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/tzstone/" >tzstone<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/llhua2329" >llhua2329<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://hao.importnew.com/author/yangxy81118/" >凝枫<i class="fas fa-external-link-alt"></i></a></li></ul><p>注：名单不分排名，不定期补充更新</p><hr><p>sotayamashita 发起维护的 CSS 资源大全，包括：预处理器、框架、CSS结构、代码风格指南、命名习惯、播客、演讲视频、大网站的 CSS 开发经验等等。</p><ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-css.html#%E6%88%91%E4%BB%AC%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F" >我们要做什么？<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-css.html#%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E%E6%9C%AC%E9%A1%B9%E7%9B%AE%EF%BC%9F" >如何参与本项目？<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-css.html#%E5%A6%82%E4%BD%95%E4%B8%BA%E5%88%97%E8%A1%A8%E8%B4%A1%E7%8C%AE%E6%96%B0%E8%B5%84%E6%BA%90%EF%BC%9F" >如何为列表贡献新资源？<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-css.html#%E6%9C%AC%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8F%82%E4%B8%8E%E8%80%85" >本项目的参与者<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>更快地编译 CSS</p><ul><li>GCSS：一个用GO语言编写的CSS预处理器。<a class="link"   href="https://github.com/yosssi/gcss" >官网<i class="fas fa-external-link-alt"></i></a></li><li>LESS：向下兼容CSS并为当前的CSS增加额外的功能。<a class="link"   href="http://lesscss.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/myth/" >Myth<i class="fas fa-external-link-alt"></i></a>：只用写纯CSS而不用担心浏览器加载缓慢。<a class="link"   href="https://github.com/segmentio/myth" >官网<i class="fas fa-external-link-alt"></i></a></li><li>PCSS：一个用Python语言编写的CSS预处理器。<a class="link"   href="https://github.com/senko/pcss" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/postcss/" >PostCSS<i class="fas fa-external-link-alt"></i></a>：通过JS插件来转换CSS。<a class="link"   href="https://github.com/postcss/postcss" >PostCSS<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/sass/" >Sass<i class="fas fa-external-link-alt"></i></a>：成熟、稳定且强力的专业CSS扩展语言。<a class="link"   href="http://sass-lang.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/stylus/" >Stylus<i class="fas fa-external-link-alt"></i></a>：用于nodejs的直观、强健、极具特色的CSS语言。<a class="link"   href="http://learnboost.github.io/stylus/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/yacp/" >YACP<i class="fas fa-external-link-alt"></i></a>：另一种CSS预处理器。<a class="link"   href="https://github.com/morishitter/YACP" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><p>这里<a class="link"   href="https://github.com/showcases/css-preprocessors" >有一个 CSS 预处理器汇总<i class="fas fa-external-link-alt"></i></a>。</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ul><li><a class="link"   href="http://hao.importnew.com/960-grid-system/" >960 Grid System<i class="fas fa-external-link-alt"></i></a>：简化了web开发工作流程。<a class="link"   href="http://960.gs/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/blueprintcss/" >Blueprint<i class="fas fa-external-link-alt"></i></a>：这个CSS框架为你提供易用的栅格系统、符合直觉的排版功能、有用的插件以及可打印的样式 <a class="link"   href="http://www.blueprintcss.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/bootstrap/" >Bootstrap<i class="fas fa-external-link-alt"></i></a>：最流行的HTML、CSS、JS框架 <a class="link"   href="http://getbootstrap.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/inuit-css/" >inuit.css<i class="fas fa-external-link-alt"></i></a> ：强力的、可扩展的、基于Sass的、采用BEM命名的面向对象CSS框架 <a class="link"   href="http://inuitcss.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/foundation/" >Foundation<i class="fas fa-external-link-alt"></i></a>：一个高级响应式前端框架。<a class="link"   href="http://foundation.zurb.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/material-design-lite/" >Material Design Lite<i class="fas fa-external-link-alt"></i></a>：很好的用于制作Material Design风格网站的框架。<a class="link"   href="http://www.getmdl.io/started/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/materialize/" >Materialize<i class="fas fa-external-link-alt"></i></a>：基于Material Design的现代响应式前端框架。<a class="link"   href="http://materializecss.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/pure-css/" >Pure.css<i class="fas fa-external-link-alt"></i></a>：一套可用于所有web项目的小型响应式CSS模块。<a class="link"   href="http://purecss.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/semantic-ui/" >Semantic UI<i class="fas fa-external-link-alt"></i></a>：使用人性化html的强力框架。<a class="link"   href="http://semantic-ui.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/skeleton/" >Skeleton<i class="fas fa-external-link-alt"></i></a>：一个超简单的响应式模板。<a class="link"   href="http://getskeleton.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/uikit/" >UIkit<i class="fas fa-external-link-alt"></i></a>：适用于手机、平板以及电脑端的栅格系统。<a class="link"   href="http://getuikit.com/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><ul><li>Basscss：一个基本元素样式与不可修改工具轻量级集合。<a class="link"   href="http://www.basscss.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Bourbon：用于Sass的简单且轻量的混合库。<a class="link"   href="http://bourbon.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Corpus：另一个CSS工具集。<a class="link"   href="http://corpuscss.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Susy：用于Sass的响应式工具集。<a class="link"   href="http://susy.oddbird.net/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="CSS结构"><a href="#CSS结构" class="headerlink" title="CSS结构"></a>CSS结构</h2><ul><li>RSCSS：CSS样式结构的合理标准。<a class="link"   href="https://github.com/rstacruz/rscss" >官网<i class="fas fa-external-link-alt"></i></a></li><li>ITCSS：用于大型UI项目的稳定、可扩展、可控制的CSS架构。<a class="link"   href="https://twitter.com/itcss_io" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="CSS标准化"><a href="#CSS标准化" class="headerlink" title="CSS标准化"></a>CSS标准化</h2><ul><li>Normalize：一套提供较好的多浏览器默认样式一致性的CSS规范。<a class="link"   href="https://github.com/necolas/normalize.css" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Normalize OpenType：为Normalize.css添加了OpenType特性，如连字、字间距等等。<a class="link"   href="https://github.com/kennethormandy/normalize-opentype.css" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Reset：一套CSS标准，将全部的HTML元素调整到一致的基准线。<a class="link"   href="http://meyerweb.com/eric/tools/css/reset/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>sanitize.css：一套可立即使用的，符合当今最优实践的CSS规范。<a class="link"   href="https://10up.github.io/sanitize.css/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="大型网站的CSS开发"><a href="#大型网站的CSS开发" class="headerlink" title="大型网站的CSS开发"></a>大型网站的CSS开发</h2><ul><li>[Github的CSS方案](<a class="link"   href="http://hao.importnew.com/htmlcss-code-guide-by-mark-otto/%EF%BC%89" >http://hao.importnew.com/htmlcss-code-guide-by-mark-otto/）<i class="fas fa-external-link-alt"></i></a> by <a class="link"   href="https://twitter.com/mdo" >Mark Otto<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="http://markdotto.com/2014/07/23/githubs-css/" >英文<i class="fas fa-external-link-alt"></i></a></li><li>CodePen的CSS方案 by <a class="link"   href="https://twitter.com/chriscoyier" >Chris Coyier<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="http://codepen.io/chriscoyier/blog/codepens-css" >英文<i class="fas fa-external-link-alt"></i></a></li><li>Lonely Planet的CSS方案 by <a class="link"   href="https://twitter.com/ianfeather" >Ian Feather<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="http://ianfeather.co.uk/css-at-lonely-planet/" >英文<i class="fas fa-external-link-alt"></i></a></li><li>Groupon的CSS方案 by <a class="link"   href="https://twitter.com/peruvianidol" >Mike Aparicio<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="http://mikeaparicio.com/2014/08/10/css-at-groupon/" >英文<i class="fas fa-external-link-alt"></i></a></li><li>Buffer的CSS方案 by <a class="link"   href="https://twitter.com/brian_lovin" >Brian Lovin<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="http://blog.brianlovin.com/buffers-css/" >英文<i class="fas fa-external-link-alt"></i></a></li><li>HOOTSUITE的CSS方案 by Steve Mynett，<a class="link"   href="http://code.hootsuite.com/css-at-hootsuite/" >英文<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/refining-the-way-we-structure-our-css-at-trello/" >如何精简TrelloCSS架构<i class="fas fa-external-link-alt"></i></a> by <a class="link"   href="https://twitter.com/bobbygrace" >Bobby Grace<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="http://blog.trello.com/refining-the-way-we-structure-our-css-at-trello/" >英文<i class="fas fa-external-link-alt"></i></a></li><li>Bugsnag的CSS架构 by <a class="link"   href="https://twitter.com/maxluster" >Max Luster<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://bugsnag.com/blog/bugsnags-css-architecture" >英文<i class="fas fa-external-link-alt"></i></a></li><li>Ghost的CSS方案 by Paul Davis，<a class="link"   href="http://dev.ghost.org/css-at-ghost/" >英文<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/mediu-css/" >Medium的CSS方案<i class="fas fa-external-link-alt"></i></a> by <a class="link"   href="https://twitter.com/fat" >Jacob Thornton<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://medium.com/@fat/mediums-css-is-actually-pretty-fucking-good-b8e2a6c78b06" >英文<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="代码风格指导"><a href="#代码风格指导" class="headerlink" title="代码风格指导"></a>代码风格指导</h2><ul><li><a class="link"   href="https://github.com/necolas/idiomatic-css" >编写符合语言习惯的 CSS<i class="fas fa-external-link-alt"></i></a> by <a class="link"   href="https://twitter.com/necolas" >Nicolas Gallagher<i class="fas fa-external-link-alt"></i></a>.</li><li><a class="link"   href="http://cssguidelin.es/" >CSS 指南<i class="fas fa-external-link-alt"></i></a> by <a class="link"   href="https://twitter.com/csswizardry" >Harry Roberts<i class="fas fa-external-link-alt"></i></a>.</li><li><a class="link"   href="http://sass-guidelin.es/" >Sass 指南<i class="fas fa-external-link-alt"></i></a> by <a class="link"   href="https://twitter.com/HugoGiraudel" >Hugo Giraudel<i class="fas fa-external-link-alt"></i></a>.</li><li><a class="link"   href="http://codeguide.co/" >Mark Otto 编写的风格指南，受「GitHub 风格」和「编写符合语言习惯的 CSS」所激发<i class="fas fa-external-link-alt"></i></a> by <a class="link"   href="https://twitter.com/mdo" >Mark Otto<i class="fas fa-external-link-alt"></i></a>.</li><li><a class="link"   href="https://github.com/ThinkUpLLC/ThinkUp/wiki/Code-Style-Guide:-CSS" >ThinkUp 的 CSS 风格指导<i class="fas fa-external-link-alt"></i></a>，作者ThinkUp</li><li><a class="link"   href="http://google-styleguide.googlecode.com/svn/trunk/htmlcssguide.xml" >Google 的 HTML&#x2F;CSS 风格指导<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/wordpress-css-coding-standards/" >WordPress的CSS代码标准<i class="fas fa-external-link-alt"></i></a>：<a class="link"   href="https://make.wordpress.org/core/handbook/coding-standards/css/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="风格指导"><a href="#风格指导" class="headerlink" title="风格指导"></a>风格指导</h2><ul><li><a class="link"   href="https://docs.atlassian.com/aui/latest/" >Atlassian 官方 UI 文档<i class="fas fa-external-link-alt"></i></a>；</li><li><a class="link"   href="http://rizzo.lonelyplanet.com/styleguide/design-elements/colours" >设计元素<i class="fas fa-external-link-alt"></i></a> by <a class="link"   href="http://www.lonelyplanet.com/" >lonely planet<i class="fas fa-external-link-alt"></i></a>.</li><li><a class="link"   href="https://github.com/styleguide/css" >GitHub 的 CSS 风格指导<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://ux.mailchimp.com/patterns" >Patterns<i class="fas fa-external-link-alt"></i></a> by <a class="link"   href="http://mailchimp.com/" >MailChimp 的风格指南<i class="fas fa-external-link-alt"></i></a>.</li><li><a class="link"   href="https://www.lightningdesignsystem.com/" >Lighting Design System<i class="fas fa-external-link-alt"></i></a> by <a class="link"   href="http://www.salesforce.com/" >Salesforce 的风格指南<i class="fas fa-external-link-alt"></i></a>.</li><li><a class="link"   href="http://sass-lang.com/styleguide" >SASS 风格指南<i class="fas fa-external-link-alt"></i></a> by Sass team.</li><li><a class="link"   href="http://www.starbucks.com/static/reference/styleguide/" >星巴克的风格指南<i class="fas fa-external-link-alt"></i></a> by <a class="link"   href="http://www.starbucks.com/" >Starbucks<i class="fas fa-external-link-alt"></i></a>.</li><li><a class="link"   href="http://styleguides.io/examples.html" >关于网站风格指导的一些资源<i class="fas fa-external-link-alt"></i></a> by <a class="link"   href="https://github.com/maban/styleguides/graphs/contributors" >Awesome people<i class="fas fa-external-link-alt"></i></a>.</li></ul><h1 id="命名习惯和方式"><a href="#命名习惯和方式" class="headerlink" title="命名习惯和方式"></a>命名习惯和方式</h1><ul><li>Atomic OOBEMITSCSS：<a class="link"   href="http://www.sitepoint.com/atomic-oobemitscss/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hao.importnew.com/css-naming-bem/" >BEM<i class="fas fa-external-link-alt"></i></a>：<a class="link"   href="https://en.bem.info/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>SMACSS：<a class="link"   href="https://smacss.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Point North：<a class="link"   href="http://pointnorth.io/#base-browser-styling" >官网<i class="fas fa-external-link-alt"></i></a></li><li>ITCSS：<a class="link"   href="http://itcss.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>OOCSS：<a class="link"   href="http://www.smashingmagazine.com/2011/12/12/an-introduction-to-object-oriented-css-oocss/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Title CSS：<a class="link"   href="http://www.sitepoint.com/title-css-simple-approach-css-class-naming/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>idiomatic-css：<a class="link"   href="https://github.com/necolas/idiomatic-css" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Atomic Design：<a class="link"   href="http://patternlab.io/resources.html" >官网<i class="fas fa-external-link-alt"></i></a></li><li>SUIT CSS：<a class="link"   href="https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md#u-utilityname" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Kickoff CSS：<a class="link"   href="https://trykickoff.github.io/learn/css.html#namingscheme" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a class="link"   href="https://github.com/davidtheclark/scalable-css-reading-list" >可扩展CSS阅读清单<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h1><h2 id="播客"><a href="#播客" class="headerlink" title="播客"></a>播客</h2><p>编程时可以听的一些内容。</p><ul><li><a class="link"   href="http://shoptalkshow.com/" >Shop Talk Show<i class="fas fa-external-link-alt"></i></a>：Chris Coyier 和 Dave Rupert 的在线播客，涉及前端、UX的设计及开发。</li><li><a class="link"   href="http://styleguides.io/podcast/index.html" >Style Guide Podcast<i class="fas fa-external-link-alt"></i></a>：由 Anna Debenham 和 Brad Frost 主持的一些访谈。</li><li><a class="link"   href="http://5by5.tv/bigwebshow/" >The Big Web Show<i class="fas fa-external-link-alt"></i></a>：包含了几乎所有 Web 相关的话题，比如网络出版、艺术指导、内容策略、版面设计、Web技术等等。</li><li><a class="link"   href="http://5by5.tv/webahead/" >The Web Ahead<i class="fas fa-external-link-alt"></i></a>：与全世界的专家讨论 Web 技术的变化和发展。</li><li><a class="link"   href="http://goodstuff.fm/nbsp" >Non Breaking Space Show<i class="fas fa-external-link-alt"></i></a>：挖掘出那些在数字艺术、设计以及开发领域最好的、最知名的并且最聪明的创客们。</li><li><a class="link"   href="https://changelog.com/" >The Changelog<i class="fas fa-external-link-alt"></i></a>：这个播客的口号是：“开源发展很快，快跟上”，致力于让你跟上最新的开源技术。</li></ul><h2 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h2><p>值得关注的活跃用户</p><ul><li><a class="link"   href="https://twitter.com/cssanimation" >CSS Animation<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://twitter.com/andreysitnik" >Andrey Sitnik<i class="fas fa-external-link-alt"></i></a>：@Autoprefixer, <a class="link"   href="http://easings.net/" >http://easings.net<i class="fas fa-external-link-alt"></i></a> 和 @PostCSS 的作者</li><li><a class="link"   href="https://twitter.com/evaferreira92" >Evangelina Ferreira<i class="fas fa-external-link-alt"></i></a>：web设计师，@multimedial_utn 的教授，HTML5 &amp; CSS狂热爱好者，业余翻译者。</li><li><a class="link"   href="https://twitter.com/SaraSoueidan" >Sara Soueidan<i class="fas fa-external-link-alt"></i></a>：@Codrops CSS Reference的作者，Smashing Book #5的合著者。</li><li><a class="link"   href="https://twitter.com/HugoGiraudel" >Hugo Giraudel<i class="fas fa-external-link-alt"></i></a>：@edenspiekermann 的 CSS 怪才以及 Sass 黑客</li><li><a class="link"   href="https://twitter.com/guyroutledge" >Guy Routledge<i class="fas fa-external-link-alt"></i></a>：前端开发者、@GA_London 的教师，<a class="link"   href="http://www.atozcss.com/" >http://www.atozcss.com<i class="fas fa-external-link-alt"></i></a> 的视频作者，宅男，吃货。</li><li><a class="link"   href="https://twitter.com/heydonworks" >Heydon Pickering<i class="fas fa-external-link-alt"></i></a>：爱吃大米，同时也是一个UX设计师，作者，@smashingmag 编辑以及程序员。</li><li><a class="link"   href="https://twitter.com/mrmrs_" >Adam Morse<i class="fas fa-external-link-alt"></i></a>：开源的粉丝和支持者</li><li><a class="link"   href="https://twitter.com/donovanh" >Donovan Hutchinson<i class="fas fa-external-link-alt"></i></a>：设计师、开发者、作家。偶尔在<a class="link"   href="http://Hop.ie%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%8C%E7%9B%AE%E5%89%8D%E5%9C%A8%E5%BB%BA%E8%AE%BE@cssanimation/" >http://Hop.ie上写博客，目前在建设@cssanimation<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://twitter.com/CSScommits" >CSS Commits<i class="fas fa-external-link-alt"></i></a>：最近忙于 CSSWG 的公共 Mercurial 库</li><li><a class="link"   href="https://twitter.com/scottjehl" >Scott Jehl<i class="fas fa-external-link-alt"></i></a>：responsiblerwd 的作者，现在 abookapart上 面在打折</li><li><a class="link"   href="https://twitter.com/dudleystorey" >Dudley Storey<i class="fas fa-external-link-alt"></i></a>：Web开发者、作者、老师以及演说者。</li><li><a class="link"   href="https://twitter.com/zomigi" >Zoe M. Gillenwater<i class="fas fa-external-link-alt"></i></a>：Web设计师、开发者，专注于CSS、RWD、UX以及无障碍开发。</li><li><a class="link"   href="https://twitter.com/ben_eb" >Ben Briggs<i class="fas fa-external-link-alt"></i></a>：主要研究node.js、javascript、开源模块、客户端优化、web性能相关。</li><li><a class="link"   href="https://twitter.com/aerotwist" >Paul Lewis<i class="fas fa-external-link-alt"></i></a>：将代码与设计联系起来的谷歌员工。</li><li><a class="link"   href="https://twitter.com/thierrykoblentz" >Thierry Koblentz<i class="fas fa-external-link-alt"></i></a>：Yahoo 的 CSS 开发者</li><li><a class="link"   href="https://twitter.com/necolas" >Nicolas Gallagher<i class="fas fa-external-link-alt"></i></a>：Twitter的软件工程师</li><li><a class="link"   href="https://twitter.com/csswizardry" >Harry Roberts<i class="fas fa-external-link-alt"></i></a>- @google, @Etsy, @kickstarter, @BBC, @Deloitte, @FT等的前端设计顾问</li><li><a class="link"   href="https://twitter.com/philwalton" >Phil Walton<i class="fas fa-external-link-alt"></i></a> -谷歌工程师、开源拥护者、开发者、设计师、写手。</li><li><a class="link"   href="https://twitter.com/LeaVerou" >Lea Verou<i class="fas fa-external-link-alt"></i></a>：MIT_CSAIL, @CSSWG IE, @OReillyMedia作者的研究助理，前W3C员工</li><li><a class="link"   href="https://twitter.com/crnacura" >Manoela Ilic<i class="fas fa-external-link-alt"></i></a>：CSS和HTML是我的画笔，我对认知科学、AI、HCI、UI设计以及天体物理学很感兴趣，数码控。</li><li><a class="link"   href="https://twitter.com/Una" >Una Kravets<i class="fas fa-external-link-alt"></i></a>：BMDesign以及Sassvocate的前端工程师，团队建设者以及手工艺者。座右铭：所有东西都应该开源！</li><li><a class="link"   href="https://twitter.com/chriscoyier" >Chris Coyier<i class="fas fa-external-link-alt"></i></a>：CodePen的设计师，Real_CSS_Tricks作者</li><li><a class="link"   href="https://twitter.com/stubbornella" >Nicole Sullivan<i class="fas fa-external-link-alt"></i></a>：极客！</li><li><a class="link"   href="https://twitter.com/ebidel" >Eric Bidelman<i class="fas fa-external-link-alt"></i></a>：谷歌的工程师，参与项目有Chrome、web组件、Polymer</li><li><a class="link"   href="https://twitter.com/patrickhamann" >Patrick Hamann<i class="fas fa-external-link-alt"></i></a>：热爱爬山、啤酒以及美食。</li><li><a class="link"   href="https://twitter.com/davemcfarland" >Dave McFarland<i class="fas fa-external-link-alt"></i></a>：Web开发者，《CSS: The Missing Manual》和《JavaScript &amp; jQuery: The Missing Manual》的作者，</li><li><a class="link"   href="https://twitter.com/davidbaron" >L. David Baron<i class="fas fa-external-link-alt"></i></a>：Mozilla开发者，CSS以及W3C标准的「外交官」。</li><li><a class="link"   href="https://twitter.com/glazou" >Daniel Glazman<i class="fas fa-external-link-alt"></i></a>：W3C的CSS工作团队联合主席，企业家，软件工程师，极客，两个孩子的爸爸，通晓多国语言，喜欢鸭子。</li><li><a class="link"   href="https://twitter.com/chriseppstein" >The Chris Eppstein<i class="fas fa-external-link-alt"></i></a>：爱恨分明，家庭美满，写代码，主导 LinkedIn 的样式。</li><li><a class="link"   href="https://twitter.com/nex3" >Natalie Weizenbaum<i class="fas fa-external-link-alt"></i></a>：女程序员，SassCSS 的主设计师和开发者，在谷歌做 Dart 语言相关工作。</li><li><a class="link"   href="https://twitter.com/brad_frost" >Brad Frost<i class="fas fa-external-link-alt"></i></a>：Web设计师、演讲者、写手、顾问、音乐家。</li><li><a class="link"   href="https://twitter.com/MoOx" >Maxime Thirouin<i class="fas fa-external-link-alt"></i></a>：前端工程师，自由职业者，UI&#x2F;UX开发者。</li><li><a class="link"   href="https://twitter.com/mdo" >Mark Otto<i class="fas fa-external-link-alt"></i></a>：在GitHub和Bootstrap工作，曾就职于Twitter，超级书呆子。</li><li><a class="link"   href="https://twitter.com/simurai" >Simon<i class="fas fa-external-link-alt"></i></a>：UI设计师，CSS开发者</li><li><a class="link"   href="https://twitter.com/connors" >Connor Sears<i class="fas fa-external-link-alt"></i></a>：GitHub设计师</li><li><a class="link"   href="https://twitter.com/rem" >Remy Sharp<i class="fas fa-external-link-alt"></i></a>：他的推都是关于CSS尺寸单元的</li><li><a class="link"   href="https://twitter.com/snookca" >Jonathan Snook<i class="fas fa-external-link-alt"></i></a>：设计师、开发者、写手、演讲者。我在网上做些东西，我写的SMACSS。</li></ul><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>一个很有用的必看视频清单，这个清单是从 <a class="link"   href="https://github.com/AllThingsSmitty/must-watch-css/commit/908a28bf36517a5bac9a34e3174885ea57a62017" >908a28<i class="fas fa-external-link-alt"></i></a> 的 <a class="link"   href="https://github.com/AllThingsSmitty/must-watch-css" >AllThingsSmitty&#x2F;must-watch-css<i class="fas fa-external-link-alt"></i></a> 复制过来的，我已经在Twitter上跟他说了，非常感谢！</p><h3 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h3><ol><li><a class="link"   href="http://jqueryuk.com/2015/videos.php?s=mdo-ular-css" >mdo-ular CSS<i class="fas fa-external-link-alt"></i></a>: Mark Otto, jQuery UK <code>30:06</code>.</li><li><a class="link"   href="http://jqueryuk.com/2015/videos.php?s=mdo-ular-css" >CSS Architecture with SMACSS<i class="fas fa-external-link-alt"></i></a>: Caleb Meredith, DevTips channel <code>30:15</code>. 用SMACSS搭建CSS结构</li><li><a class="link"   href="https://www.youtube.com/watch?v=ZVk3GQHfkbU" >CSS Workflow from the Ground Up<i class="fas fa-external-link-alt"></i></a>: Jonathan Snook, Generate conf 2015 <code>46:06</code>. 从头开始学习CSS工作流</li></ol><h3 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h3><ol><li><a class="link"   href="https://vimeo.com/95734680" >What Is a CSS Framework Anyway? | 究竟什么是CSS框架？<i class="fas fa-external-link-alt"></i></a>: Harry Roberts, Industry Conf <code>48:48</code>.</li><li><a class="link"   href="https://vimeo.com/99877232" >CSS Is a Mess | 乱七八糟的CSS<i class="fas fa-external-link-alt"></i></a>: Jonathan Snook, Beyond Tellerand <code>53:49</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=FYcu-wWrNqo&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >10 Commandments for Efficient CSS Architecture | 高效CSS结构十诫<i class="fas fa-external-link-alt"></i></a>: Kushagra Gour, CSSConf.Asia <code>35:55</code>.</li><li><a class="link"   href="https://vimeo.com/100501790" >Slaying the Dragon: How to Refactor CSS for Maintainability | 杀掉巨龙：从可维护性方面考虑如何重构CSS<i class="fas fa-external-link-alt"></i></a>: Alicia Liu, Front-Trends <code>33:21</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=vBHt61yDO9U&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >CSS in Your Pocket：Mobile CSS Tips from the Trenches | 口袋中的CSS-移动端CSS开发要点<i class="fas fa-external-link-alt"></i></a>: Angelina Fabbro, CSSConf.US <code>34:19</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=lf7L8X6ZBu8&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >Styling and Animating Scalable Vector Graphics with CSS | 用CSS制作可扩展的矢量图动画<i class="fas fa-external-link-alt"></i></a>: Sara Soueidan, CSSConf.EU <code>29:16</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=-bZSTMLqf8Q&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >Play Nice With CSS Tools and Methodologies | 学会使用CSS工具和方法<i class="fas fa-external-link-alt"></i></a>: Brad Westfall, HTML5DevConf <code>42:47</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=_0Fk85to6hA&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >CSS and the Critical Path | CSS以及关键路径<i class="fas fa-external-link-alt"></i></a>: Patrick Hamann, CSSConf.EU <code>33:42</code>.</li><li><a class="link"   href="http://new.livestream.com/accounts/6779986/events/2928486/videos/51426837" >All the Right Moves: How to Put Your UI in Motion | 走好每一步：如何让你的UI动起来<i class="fas fa-external-link-alt"></i></a>: Val Head, Multi-Mania <code>45:49</code>.</li><li><a class="link"   href="https://vimeo.com/98746172" >Present and Future of CSS Layout | CSS布局的发展<i class="fas fa-external-link-alt"></i></a>: Tab Atkins, CSS Day <code>49:31</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=L8w3v9m6G04&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >Thinking Beyond “Scalable CSS” | 关于可扩展CSS的思考<i class="fas fa-external-link-alt"></i></a>: Nicolas Gallagher, dotCSS <code>28:46</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=QHxrr6Q82yI&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >Web Components &amp; the Future of CSS | WEB组件以及CSS的将来<i class="fas fa-external-link-alt"></i></a>: Philip Walton, SFHTML5 <code>40:02</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=FEs2jgZBaQA&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >CSS Performance Tooling | CSS性能工具<i class="fas fa-external-link-alt"></i></a>: Addy Osmani, CSSConf.EU <code>46:27</code>.</li><li><a class="link"   href="https://vimeo.com/100264064" >3.14 Things I Didn’t Know About CSS3 | 关于CSS，我所不知道的14件事<i class="fas fa-external-link-alt"></i></a>: Mathias Bynens, CSS Day <code>45:35</code>.</li><li><a class="link"   href="http://vimeo.com/101718785" >Effortless Style | 轻松的样式<i class="fas fa-external-link-alt"></i></a>: Heydon Pickering, CSS Day <code>49:51</code>.</li><li><a class="link"   href="https://vimeo.com/99916682" >CSS: Yawn to Yay! | CSS：从无聊到精彩<i class="fas fa-external-link-alt"></i></a> Kyle Simpson, Front-Trends <code>39:04</code>.</li></ol><h3 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h3><ol><li><a class="link"   href="https://www.youtube.com/watch?v=xbpnqbM6cRk&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >When Bootstrap Attacks | 当Bootstrap开始发力<i class="fas fa-external-link-alt"></i></a>: Pamela Fox, CSSConf.US <code>28:48</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=NTJUFQmHbvc&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >CSS in the 4th Dimension | CSS是第四维<i class="fas fa-external-link-alt"></i></a>: Lea Verou, JSConf.Asia <code>44:49</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=2PU6JX4S7zI&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >Automated CSS Testing | 自动化CSS测试<i class="fas fa-external-link-alt"></i></a>: Jakob Mattsson, JSConf.Asia <code>42:07</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=ue-Z_HxS3cc&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >CSSConf.EU Keynote | CSSConf.EU的基调<i class="fas fa-external-link-alt"></i></a>: Nicole Sullivan, CSSConf.EU <code>20:57</code>.</li><li><a class="link"   href="https://vimeo.com/74359951" >CSS Application Architecture | CSS的应用架构<i class="fas fa-external-link-alt"></i></a>: Nicolas Gallagher, SmashingConf <code>38:36</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=I82ytAWxzrI&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >Realigning &amp; Refactoring UI | UI的调整和重构<i class="fas fa-external-link-alt"></i></a>: Jina Bolton, SassConf <code>48:08</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=ldx4ZFxMEeo&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >Normalizing Designs for Better Quality CSS | 提高CSS质量的规范化设计<i class="fas fa-external-link-alt"></i></a>: Harry Roberts, CSSConf.EU <code>43:40</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=833xr1MyE30&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >Automating the Removal of Unused CSS | 自动清除无用的CSS<i class="fas fa-external-link-alt"></i></a>: Addy Osmani, Velocity Europe Conference <code>5:57</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=2iFw2GCOPj0&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >The Humble Border-Radius | 低调的Border-Radius<i class="fas fa-external-link-alt"></i></a>: Lea Verou, Future of Web Design <code>37:07</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=-ZJeOJGazgE&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >The Mind-blowing Power of Sass 3.3 | Sass那印象深刻的力量<i class="fas fa-external-link-alt"></i></a>: Chris Eppstein, CSSConf.EU <code>38:54</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=5_nt5qV15po&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >Front-End Tools for the Young Developer | 年轻开发者的前端工具<i class="fas fa-external-link-alt"></i></a>: Christian Vuerings, SF HTML5 User Group <code>14:16</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=w9HeWBH_kvg&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >Maths-Powered Transforms for Creating 3D Shapes | Maths-创建3D图形的强力转换器<i class="fas fa-external-link-alt"></i></a>: Ana-Maria Tudor, CSSConf.EU <code>30:27</code>.</li><li><a class="link"   href="https://vimeo.com/66039168" >Sass and OOCSS Sitting in a Tree K-I-S-S-I-N-G | Sass和面向对象CSS完美搭配<i class="fas fa-external-link-alt"></i></a>: Nicole Sullivan, TXJS <code>27:50</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=UpVj5azI-iI&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >CSS Levels Up | 提升CSS等级<i class="fas fa-external-link-alt"></i></a>: Angelina Fabbro, CSSConf.EU <code>31:38</code>.</li><li><a class="link"   href="https://vimeo.com/70041549" >Architecting Scalable CSS | 搭建可扩展的CSS<i class="fas fa-external-link-alt"></i></a>: Harry Roberts, Beyond Tellerand <code>41:57</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=3ikye7Qc7Ak&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >More CSS Secrets: Another 10 Things You May Not Know about CSS | 更多的CSS秘密：CSS不为人知的另外10件事<i class="fas fa-external-link-alt"></i></a>: Lea Verou, W3Conf <code>60:39</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=ojj_-6Xiud4" >Atomic Cascading Style Sheets<i class="fas fa-external-link-alt"></i></a>: Renato Iwashima, HTML5DevConf <code>52:33</code>.</li></ol><h3 id="2012"><a href="#2012" class="headerlink" title="#2012"></a><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-css.html#_2012" >#<i class="fas fa-external-link-alt"></i></a>2012</h3><ol><li><a class="link"   href="https://www.youtube.com/watch?v=hFdbE6T9QGc&list=PLUS3uVC08ZaqVEGFkl_dS_3FUzILkOIzA" >Open Source Tools and Libraries for Designers | 设计师的开源工具以及资源库<i class="fas fa-external-link-alt"></i></a>: Julie Ann Horvath, HTML5DevConf <code>29:39</code>.</li><li><a class="link"   href="https://vimeo.com/54990931" >GitHub’s CSS Performance | GitHub的CSS表现<i class="fas fa-external-link-alt"></i></a>: Jon Rohan, CSS Dev Conf <code>40:50</code>.</li></ol><h3 id="2010"><a href="#2010" class="headerlink" title="2010"></a>2010</h3><ol><li><a class="link"   href="https://vimeo.com/17091905" >Handcrafted CSS | 手写CSS<i class="fas fa-external-link-alt"></i></a>: Dan Cederholm, Build Conference <code>44:29</code>.</li><li><a class="link"   href="https://www.youtube.com/watch?v=j6sAm7CLoCQ" >The Top 5 Mistakes of Massive CSS | 大规模CSS中最容易出现的5个错误<i class="fas fa-external-link-alt"></i></a>: Nicole Sullivan, Build Conference <code>37:53</code>.</li></ol><h3 id="有影响力的书"><a href="#有影响力的书" class="headerlink" title="有影响力的书"></a>有影响力的书</h3><p><em>具有广泛影响且值得阅读的前端经典书籍。</em></p><ul><li>待补充</li></ul><h3 id="知名网站"><a href="#知名网站" class="headerlink" title="知名网站"></a>知名网站</h3><p><em>值得关注的前端技术站点。</em></p><h4 id="中文站点"><a href="#中文站点" class="headerlink" title="中文站点"></a>中文站点</h4><ul><li><a class="link"   href="http://web.importnew.com/" >伯乐在线前端频道<i class="fas fa-external-link-alt"></i></a>：伯乐前端分享 Web 前端开发，包括 JavaScript、CSS 和 HTML5 开发技术，前端相关的行业动态。</li></ul><h4 id="英文站点"><a href="#英文站点" class="headerlink" title="英文站点"></a>英文站点</h4><ul><li>待补充</li></ul><h3 id="微博、微信公众号"><a href="#微博、微信公众号" class="headerlink" title="微博、微信公众号"></a>微博、微信公众号</h3><p>* 前端大全 微博：<a class="link"   href="http://weibo.com/u/5261893910" >@前端大全<i class="fas fa-external-link-alt"></i></a> * 前端大全：专注分享Web前端相关的内容，包括 JavaScript、CSS 和 HTML5 技术文章、工具资源、精选课程和Web技术领域热点资讯。<br><img                       lazyload                     alt="image"                     data-src="http://ww4.sinaimg.cn/small/63918611gw1epb2c688tqj2046046mx8.jpg"                      alt="img"                > * UI设计达人：分享 UI 设计精选文章、案例、行业趋势、课程和书籍。<br><img                       lazyload                     alt="image"                     data-src="http://ww4.sinaimg.cn/mw690/bfdcef89gw1evuvyehtx4j2076076q3e.jpg"                      alt="img"                > * 网页设计精选：分享网页设计精选文章、案例、行业趋势、课程和书籍。<br><img                       lazyload                     alt="image"                     data-src="http://ww2.sinaimg.cn/mw690/bfdcef89gw1evuvyhsikmj2076076dgb.jpg"                      alt="img"                ></p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><h4 id="中文博客"><a href="#中文博客" class="headerlink" title="中文博客"></a>中文博客</h4><ul><li>待补充</li></ul><h4 id="英文博客"><a href="#英文博客" class="headerlink" title="英文博客"></a>英文博客</h4><ul><li>待补充</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS-资源大全中文版&quot;&gt;&lt;a href=&quot;#CSS-资源大全中文版&quot; class=&quot;headerlink&quot; title=&quot;CSS 资源大全中文版&quot;&gt;&lt;/a&gt;CSS 资源大全中文版&lt;/h1&gt;&lt;p&gt;我想很多程序员应该记得 GitHub 上有一个 Awesome：XX</summary>
      
    
    
    
    <category term="CSS资源大全" scheme="http://example.com/categories/CSS%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Java资源大全</title>
    <link href="http://example.com/2023/02/19/Java%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8/"/>
    <id>http://example.com/2023/02/19/Java%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8/</id>
    <published>2023-02-18T23:00:21.600Z</published>
    <updated>2023-02-20T09:02:52.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java资源大全"><a href="#Java资源大全" class="headerlink" title="Java资源大全"></a>Java资源大全</h1><hr><table><thead><tr><th align="center">算法</th><th align="center">操作系统</th><th align="center">网络</th><th align="center">面向对象</th><th align="center">数据库</th><th align="center">Java</th><th align="center">系统设计</th><th align="center">工具</th><th align="center">编码实践</th><th align="center">后记</th></tr></thead><tbody><tr><td align="center"><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-java2/#pencil2-%E7%AE%97%E6%B3%95" >✏️<i class="fas fa-external-link-alt"></i></a></td><td align="center"><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-java2/#computer-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" >💻<i class="fas fa-external-link-alt"></i></a></td><td align="center"><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-java2/#cloud-%E7%BD%91%E7%BB%9C" >☁️<i class="fas fa-external-link-alt"></i></a></td><td align="center"><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-java2/#art-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" >🎨<i class="fas fa-external-link-alt"></i></a></td><td align="center"><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-java2/#floppy_disk-%E6%95%B0%E6%8D%AE%E5%BA%93" >💾<i class="fas fa-external-link-alt"></i></a></td><td align="center"><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-java2/#coffee-java" >☕️<i class="fas fa-external-link-alt"></i></a></td><td align="center"><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-java2/#bulb-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1" >💡<i class="fas fa-external-link-alt"></i></a></td><td align="center"><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-java2/#wrench-%E5%B7%A5%E5%85%B7" >🔧<i class="fas fa-external-link-alt"></i></a></td><td align="center"><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-java2/#watermelon-%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5" >🍉<i class="fas fa-external-link-alt"></i></a></td><td align="center"><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-java2/#memo-%E5%90%8E%E8%AE%B0" >📝<i class="fas fa-external-link-alt"></i></a></td></tr></tbody></table><p>我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。<a class="link"   href="https://github.com/akullpp/awesome-java" >awesome-java<i class="fas fa-external-link-alt"></i></a> 就是 akullpp 发起维护的 Java 资源列表，内容包括：构建工具、数据库、框架、模板、安全、代码分析、日志、第三方库、书籍、Java 站点等等。伯乐在线已经把 awesome-java 资源列表翻成中文后发布于 <a class="link"   href="http://www.importnew.com/14429.html" >ImportNew<i class="fas fa-external-link-alt"></i></a>。</p><p>Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。</p><hr><h3 id="我们要做什么？"><a href="#我们要做什么？" class="headerlink" title="我们要做什么？"></a>我们要做什么？</h3><ul><li><p>基于 awesome-java 资源列表，我们将对各个资源项进行编译整理。</p></li><li><p>整理后的内容，将收录在</p><p>伯乐在线资源频道</p><p>。可参考已整理的内容：</p><ul><li>《<a class="link"   href="http://www.importnew.com/owner/" >OWNER：Java配置文件解决方案<i class="fas fa-external-link-alt"></i></a>》</li><li>《<a class="link"   href="http://www.importnew.com/spring-boot/" >Spring Boot：简化Spring应用初始搭建以及开发过程<i class="fas fa-external-link-alt"></i></a>》</li><li>《<a class="link"   href="http://www.importnew.com/sonarqube/" >SonarQube：开源的代码质量管理工具<i class="fas fa-external-link-alt"></i></a>》</li></ul></li></ul><hr><h3 id="如何参与本项目？"><a href="#如何参与本项目？" class="headerlink" title="如何参与本项目？"></a>如何参与本项目？</h3><hr><h3 id="如何为列表贡献新资源？"><a href="#如何为列表贡献新资源？" class="headerlink" title="如何为列表贡献新资源？"></a>如何为列表贡献新资源？</h3><p>欢迎大家为列表贡献高质量的新资源，提交PR时请参照以下要求：</p><ul><li>请确保推荐的资源自己使用过</li><li>提交PR时请注明推荐理由</li></ul><p>资源列表管理收到PR请求后，会定期（每周）在微博转发本周提交的PR列表，并在微博上面听取使用过这些资源的意见。确认通过后，会加入资源大全。</p><p>感谢您的贡献！</p><hr><h3 id="本项目的参与者"><a href="#本项目的参与者" class="headerlink" title="本项目的参与者"></a>本项目的参与者</h3><ul><li>维护者：<a class="link"   href="https://github.com/tangyouhua" >tangyouhua<i class="fas fa-external-link-alt"></i></a></li><li>贡献者：<a class="link"   href="https://github.com/tangyouhua" >tangyouhua<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/kingzone" >kingzone<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/llhua2329" >llhua2329<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/BadCoderChou" >BadCoderChou<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/anankun/" >anankun<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/jianghehe/" >贺贺<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/petra/" >大彭<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/wing00yf/" >superXiaoFan<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/3951356/" >javayrf<i class="fas fa-external-link-alt"></i></a>、[John Smith](<a class="link"   href="http://www.importnew.com/members/John" >http://www.importnew.com/members/John<i class="fas fa-external-link-alt"></i></a> Smith&#x2F;)、<a class="link"   href="http://www.importnew.com/members/jaler/" >Jaler<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/fdconan/" >JM<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/zy124348985/" >dreamkidd<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/cheenlie" >cheenlie<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/zhangQian1991" >zhangQian1991<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/wt726553124/" >王涛<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/xun_cui" >马<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/xuhf_1988/" >vvkee<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/yangxy81118" >凝枫<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/luhaixun" >haixunlu<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/milly/" >milly<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/xuhf_1988/" >Hodur<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/FakeHank" >FakeHank<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/%E8%BF%9E%E4%B9%90/" >连乐<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/UncleTim/" >UncleTim<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/sunbiaobiao" >sunbiaobiao<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/wx2702327993/" >zhiguo<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/zhongjianno1/" >光光头去打酱油<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/TonyAaron/" >云中游<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/zemo/" >Zemo<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/sdcuike" >sdcuike<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/danielwii" >danielwii<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/q1118024125/" >oneDay<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/dfghj44444" >邢敏<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/heikehuan" >heikehuan<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/fgcui1204" >fgcui1204<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/wenxueliu" >wenxueliu<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/node" >Gentle Yang<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/author/huangxiaofei/" >黄小非<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/wtgn1m1/" >wangtg<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/2937134480/" >百焱<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/2480130384/" >胡不GUI<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/mtHzm/" >Another_mt<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/adonis/" >Rainbow<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/menghuanqiqi" >super^糖<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/huangyuliang/" >黄余粮<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="http://www.importnew.com/members/sunbojian100/" >Sun<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/SoberChina" >李伟高<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/q977734161" >lixiaobao<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/XuZhongCN" >許中<i class="fas fa-external-link-alt"></i></a>、You</li></ul><p>注：名单不分排名，不定期补充更新</p><hr><ul><li>我们要做什么？</li><li>如何参与本项目？</li><li>如何为列表贡献新资源？</li><li>本项目的参与者</li></ul><h2 id="古董级工具"><a href="#古董级工具" class="headerlink" title="古董级工具"></a>古董级工具</h2><p><em>这些工具伴随着Java一起出现，在各自辉煌之后还在一直使用。</em></p><ul><li><a class="link"   href="http://www.importnew.com/apache-ant/" >Apache Ant<i class="fas fa-external-link-alt"></i></a>：基于XML的构建管理工具。<a class="link"   href="http://ant.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/cglib/" >cglib<i class="fas fa-external-link-alt"></i></a>：字节码生成库。<a class="link"   href="https://github.com/cglib/cglib" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/glassfish/" >GlassFish<i class="fas fa-external-link-alt"></i></a>：应用服务器，由Oracle赞助支持的Java EE参考实现。<a class="link"   href="https://glassfish.java.net/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/hudson/" >Hudson<i class="fas fa-external-link-alt"></i></a>：持续集成服务器，目前仍在活跃开发。<a class="link"   href="http://hudson-ci.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/javaserver-faces/" >JavaServer Faces<i class="fas fa-external-link-alt"></i></a>：Mojarra是JSF标准的一个开源实现，由Oracle开发。<a class="link"   href="https://javaserverfaces.java.net/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/javaserver-pages/" >JavaServer Pages<i class="fas fa-external-link-alt"></i></a>：支持自定义标签库的网站通用模板库。<a class="link"   href="https://jsp.java.net/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/liquibase/" >Liquibase<i class="fas fa-external-link-alt"></i></a>：与具体数据库独立的追踪、管理和应用数据库Scheme变化的工具。<a class="link"   href="http://www.liquibase.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><p><em>构建及应用依赖关系处理工具。</em></p><ul><li><a class="link"   href="http://www.importnew.com/maven/" >Apache Maven<i class="fas fa-external-link-alt"></i></a>：Maven是一款声明式构建及依赖管理工具，采用约定优于配置方式进行管理。相对Apache Ant更推荐使用Maven，前者采用了过程式管理，维护相对困难。<a class="link"   href="http://maven.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/bazel/" >Bazel<i class="fas fa-external-link-alt"></i></a>：来自Google的构建工具，可以快速、可靠地构建代码。<a class="link"   href="http://bazel.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/gradle/" >Gradle<i class="fas fa-external-link-alt"></i></a>：使用Groovy（非XML）进行增量构建，可以很好地与Maven依赖管理配合工作。<a class="link"   href="http://gradle.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/buck/" >Buck<i class="fas fa-external-link-alt"></i></a>：Facebook构建工具。<a class="link"   href="https://buckbuild.com/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="字节码操作"><a href="#字节码操作" class="headerlink" title="字节码操作"></a>字节码操作</h3><p><em>编程方式操作字节码的开发库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/asm/" >ASM<i class="fas fa-external-link-alt"></i></a>：通用底层字节码操作和分析开发库。<a class="link"   href="http://asm.ow2.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/byte-buddy/" >Byte Buddy<i class="fas fa-external-link-alt"></i></a>：使用流式API进一步简化字节码生成。<a class="link"   href="http://bytebuddy.net/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/byteman/" >Byteman<i class="fas fa-external-link-alt"></i></a>：在运行时通过DSL（规则）操作字节码进行测试和故障排除。<a class="link"   href="http://byteman.jboss.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/javassist/" >Javassist<i class="fas fa-external-link-alt"></i></a>：一个简化字节码编辑尝试。<a class="link"   href="http://jboss-javassist.github.io/javassist" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p><em>在集群内动态管理应用程序的框架。</em></p><ul><li><a class="link"   href="http://www.importnew.com/apache-aurora/" >Apache Aurora<i class="fas fa-external-link-alt"></i></a>：Apache Aurora是一个Mesos框架，用于长时间运行服务和定时任务（cron job）。<a class="link"   href="http://aurora.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/singularity/" >Singularity<i class="fas fa-external-link-alt"></i></a>：Singularity是一个Mesos框架，方便部署和操作。它支持Web Service、后台运行、调度作业和一次性任务。<a class="link"   href="http://getsingularity.com/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p><em>测量代码指标和质量工具。</em></p><ul><li><a class="link"   href="http://www.importnew.com/checkstyle/" >Checkstyle<i class="fas fa-external-link-alt"></i></a>：代码编写规范和标准静态分析工具。<a class="link"   href="https://github.com/checkstyle/checkstyle" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/error-prone/" >Error Prone<i class="fas fa-external-link-alt"></i></a>：将常见编程错误作为运行时错误报告。<a class="link"   href="https://github.com/google/error-prone" >官网<i class="fas fa-external-link-alt"></i></a></li><li>FindBugs：通过字节码静态分析查找隐藏bug。<a class="link"   href="http://findbugs.sourceforge.net/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jqassistant/" >jQAssistant<i class="fas fa-external-link-alt"></i></a>：使用基于Neo4J查询语言进行代码静态分析。<a class="link"   href="http://jqassistant.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/pmd/" >PMD<i class="fas fa-external-link-alt"></i></a>：对源代码分析查找不良的编程习惯。<a class="link"   href="https://github.com/pmd/pmd" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/sonarqube/" >SonarQube<i class="fas fa-external-link-alt"></i></a>：通过插件集成其它分析组件，对过去一段时间内的数据进行统计。<a class="link"   href="http://www.sonarqube.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="编译器生成工具"><a href="#编译器生成工具" class="headerlink" title="编译器生成工具"></a>编译器生成工具</h3><p><em>用来创建解析器、解释器或编译器的框架。</em></p><ul><li><a class="link"   href="http://www.importnew.com/antlr/" >ANTLR<i class="fas fa-external-link-alt"></i></a>：复杂的全功能自顶向下解析框架。<a class="link"   href="http://www.antlr.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/javacc/" >JavaCC<i class="fas fa-external-link-alt"></i></a>：JavaCC是更加专门的轻量级工具，易于上手且支持语法超前预测。<a class="link"   href="https://javacc.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="外部配置工具"><a href="#外部配置工具" class="headerlink" title="外部配置工具"></a>外部配置工具</h3><p><em>支持外部配置的开发库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/config/" >config<i class="fas fa-external-link-alt"></i></a>：针对JVM语言的配置库。<a class="link"   href="https://github.com/typesafehub/config" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/owner/" >owner<i class="fas fa-external-link-alt"></i></a>：减少冗余配置属性。<a class="link"   href="https://github.com/lviggiano/owner" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="约束满足问题求解程序"><a href="#约束满足问题求解程序" class="headerlink" title="约束满足问题求解程序"></a>约束满足问题求解程序</h3><p><em>帮助解决约束满足问题的开发库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/choco/" >Choco<i class="fas fa-external-link-alt"></i></a>：可直接使用的约束满足问题求解程序，使用了约束规划技术。<a class="link"   href="http://choco-solver.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jacop/" >JaCoP<i class="fas fa-external-link-alt"></i></a>：为FlatZinc语言提供了一个接口，可以执行MiniZinc模型。<a class="link"   href="https://github.com/radsz/jacop/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/optaplanner/" >OptaPlanner<i class="fas fa-external-link-alt"></i></a>：业务规划与资源调度优化求解程序。<a class="link"   href="http://www.optaplanner.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/sat4j/" >Sat4J<i class="fas fa-external-link-alt"></i></a>：逻辑代数与优化问题最先进的求解程序。<a class="link"   href="http://www.sat4j.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><ul><li><a class="link"   href="http://www.importnew.com/bamboo/" >Bamboo<i class="fas fa-external-link-alt"></i></a>：Atlassian解决方案，可以很好地集成Atlassian的其他产品。可以选择开源许可，也可以购买商业版。<a class="link"   href="https://www.atlassian.com/software/bamboo" >官网<i class="fas fa-external-link-alt"></i></a></li><li>CircleCI：提供托管服务，可以免费试用。<a class="link"   href="https://circleci.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/codeship/" >Codeship<i class="fas fa-external-link-alt"></i></a>：提供托管服务，提供有限的免费模式。<a class="link"   href="https://codeship.com/features" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/hao.importnew.com/fabric8/" >fabric8<i class="fas fa-external-link-alt"></i></a>：容器集成平台。<a class="link"   href="http://fabric8.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/go/" >Go<i class="fas fa-external-link-alt"></i></a>：ThoughtWork开源解决方案。<a class="link"   href="https://www.gocd.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jenkins/" >Jenkins<i class="fas fa-external-link-alt"></i></a>：支持基于服务器的部署服务。<a class="link"   href="http://jenkins-ci.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/teamcity/" >TeamCity<i class="fas fa-external-link-alt"></i></a>：JetBrain的持续集成解决方案，有免费版。<a class="link"   href="http://www.jetbrains.com/teamcity/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/travis/" >Travis<i class="fas fa-external-link-alt"></i></a>：通常用作开源项目的托管服务。<a class="link"   href="https://travis-ci.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/buildkite/" >Buildkite<i class="fas fa-external-link-alt"></i></a>: 持续集成工具，用简单的脚本就能设置pipeline，而且能快速构建，可以免费试用。<a class="link"   href="https://buildkite.com/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="CSV解析"><a href="#CSV解析" class="headerlink" title="CSV解析"></a>CSV解析</h3><p><em>简化CSV数据读写的框架与开发库</em></p><ul><li><a class="link"   href="http://www.importnew.com/univocity-parsers/" >uniVocity-parsers<i class="fas fa-external-link-alt"></i></a>：速度最快功能最全的CSV开发库之一，同时支持TSV与固定宽度记录的读写。<a class="link"   href="https://github.com/uniVocity/univocity-parsers" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><em>简化数据库交互的相关工具。</em></p><ul><li><a class="link"   href="http://www.importnew.com/apache-phoenix/" >Apache Phoenix<i class="fas fa-external-link-alt"></i></a>：HBase针对低延时应用程序的高性能关系数据库层。<a class="link"   href="http://phoenix.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/crate/" >Crate<i class="fas fa-external-link-alt"></i></a>：实现了数据同步、分片、缩放、复制的分布式数据存储。除此之外还可以使用基于SQL的语法跨集群查询。<a class="link"   href="https://crate.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/flyway/" >Flyway<i class="fas fa-external-link-alt"></i></a>：简单的数据库迁移工具。<a class="link"   href="http://flywaydb.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/h2/" >H2<i class="fas fa-external-link-alt"></i></a>：小型SQL数据库，以可以作为内存数据库使用著称。<a class="link"   href="http://h2database.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/hikaricp/" >HikariCP<i class="fas fa-external-link-alt"></i></a>：高性能JDBC连接工具。<a class="link"   href="https://github.com/brettwooldridge/HikariCP" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jdbi/" >JDBI<i class="fas fa-external-link-alt"></i></a>：便捷的JDBC抽象。<a class="link"   href="http://jdbi.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jooq/" >jOOQ<i class="fas fa-external-link-alt"></i></a>：为SQL schema生成typesafe代码。<a class="link"   href="http://www.jooq.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/mapdb/" >MapDB<i class="fas fa-external-link-alt"></i></a>：以磁盘或堆内存中并发集合为基础的嵌入式数据库引擎。<a class="link"   href="http://www.mapdb.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/presto/" >Presto<i class="fas fa-external-link-alt"></i></a>：针对大数据的分布式SQL查询引擎。<a class="link"   href="https://github.com/facebook/presto" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/querydsl/" >Querydsl<i class="fas fa-external-link-alt"></i></a>：Typesafe统一查询。<a class="link"   href="http://www.querydsl.com/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><a class="link"   href="http://www.importnew.com/apache-parquet/" >Apache Parquet<i class="fas fa-external-link-alt"></i></a>：Google Dremel论文中发布的基于组装算法的列式（Columnar）存储格式。<a class="link"   href="http://parquet.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/protobuf/" >Protobuf<i class="fas fa-external-link-alt"></i></a>：Google数据交换格式。<a class="link"   href="https://github.com/google/protobuf" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/sbe/" >SBE<i class="fas fa-external-link-alt"></i></a>：简单二进制编码，是最快速的消息格式之一。<a class="link"   href="https://github.com/real-logic/simple-binary-encoding" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/wire/" >Wire<i class="fas fa-external-link-alt"></i></a>：整洁轻量级协议缓存。<a class="link"   href="https://github.com/square/wire" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="时间日期工具库"><a href="#时间日期工具库" class="headerlink" title="时间日期工具库"></a>时间日期工具库</h3><p><em>处理时间和日期的开发库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/joda-time/" >Joda-Time<i class="fas fa-external-link-alt"></i></a>：在Java 8发布前，Joda-Time是实际使用的时间日期库标准。<a class="link"   href="http://www.joda.org/joda-time/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/time4j/" >Time4J<i class="fas fa-external-link-alt"></i></a>：高级时间和日期库。<a class="link"   href="https://github.com/MenoData/Time4J" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/ThreeTen/" >ThreeTen<i class="fas fa-external-link-alt"></i></a>：JSR-310实现，为JDK提供更具特点的时间和日期API。<a class="link"   href="http://www.threeten.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><em>帮实现依赖翻转范式的开发库。</em> <a class="link"   href="https://en.wikipedia.org/wiki/Inversion_of_control" >官网<i class="fas fa-external-link-alt"></i></a></p><ul><li><a class="link"   href="http://www.importnew.com/apache-deltaspike/" >Apache DeltaSpike<i class="fas fa-external-link-alt"></i></a>：CDI扩展框架。<a class="link"   href="https://deltaspike.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/dagger2/" >Dagger2<i class="fas fa-external-link-alt"></i></a>：编译时注入框架，不需要使用反射。<a class="link"   href="http://google.github.io/dagger/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/guice/" >Guice<i class="fas fa-external-link-alt"></i></a>：可以匹敌Dagger的轻量级注入框架。<a class="link"   href="https://github.com/google/guice" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/hk2/" >HK2<i class="fas fa-external-link-alt"></i></a>：轻量级动态依赖注入框架。<a class="link"   href="https://hk2.java.net/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="开发流程增强工具"><a href="#开发流程增强工具" class="headerlink" title="开发流程增强工具"></a>开发流程增强工具</h3><p><em>从最基本的层面增强开发流程。</em></p><ul><li><a class="link"   href="http://www.importnew.com/adt4j/" >ADT4J<i class="fas fa-external-link-alt"></i></a>：针对代数数据类型的JSR-269代码生成器。<a class="link"   href="https://github.com/sviperll/adt4j" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/aspectj/" >AspectJ<i class="fas fa-external-link-alt"></i></a>：面向切面编程（AOP）的无缝扩展。<a class="link"   href="https://eclipse.org/aspectj/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/auto/" >Auto<i class="fas fa-external-link-alt"></i></a>：源代码生成器集合。<a class="link"   href="https://github.com/google/auto" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/dcevm/" >DCEVM<i class="fas fa-external-link-alt"></i></a>：通过修改JVM在运行时支持对已加载的类进行无限次重定义。<a class="link"   href="http://dcevm.github.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>HotswapAgent：支持无限次重定义运行时类与资源。<a class="link"   href="https://github.com/HotswapProjects/HotswapAgent" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Immutables：类似Scala的条件类。<a class="link"   href="http://immutables.github.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>JHipster：基于Spring Boot与AngularJS应用程序的Yeoman源代码生成器。<a class="link"   href="https://github.com/jhipster/generator-jhipster" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jrebel/" >JRebel<i class="fas fa-external-link-alt"></i></a>：无需重新部署，可以即时重新加载代码与配置的商业软件。<a class="link"   href="http://zeroturnaround.com/software/jrebel/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Lombok：减少冗余的代码生成器。<a class="link"   href="https://projectlombok.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Spring Loaded：类重载代理。<a class="link"   href="https://github.com/spring-projects/spring-loaded" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/vert-x/" >vert.x<i class="fas fa-external-link-alt"></i></a>：多语言事件驱动应用框架。<a class="link"   href="http://vertx.io/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h3><p><em>用来编写分布式容错应用的开发库和框架。</em></p><ul><li><a class="link"   href="http://www.importnew.com/akka/" >Akka<i class="fas fa-external-link-alt"></i></a>：用来编写分布式容错并发事件驱动应用程序的工具和运行时。<a class="link"   href="http://akka.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/storm/" >Apache Storm<i class="fas fa-external-link-alt"></i></a>：实时计算系统。<a class="link"   href="http://storm.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/zookeeper/" >Apache ZooKeeper<i class="fas fa-external-link-alt"></i></a>：针对大型分布式系统的协调服务，支持分布式配置、同步和名称注册。<a class="link"   href="http://zookeeper.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/Hazelcast/" >Hazelcast<i class="fas fa-external-link-alt"></i></a>：高可扩展内存数据网格。<a class="link"   href="http://hazelcast.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/hystrix/" >Hystrix<i class="fas fa-external-link-alt"></i></a>：提供延迟和容错。<a class="link"   href="https://github.com/Netflix/Hystrix" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jgroups/" >JGroups<i class="fas fa-external-link-alt"></i></a>：提供可靠的消息传递和集群创建的工具。<a class="link"   href="http://www.jgroups.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/orbit/" >Orbit<i class="fas fa-external-link-alt"></i></a>：支持虚拟角色（Actor），在传统角色的基础上增加了另外一层抽象。<a class="link"   href="http://orbit.bioware.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/quasar/" >Quasar<i class="fas fa-external-link-alt"></i></a>：为JVM提供轻量级线程和角色。<a class="link"   href="http://www.paralleluniverse.co/quasar/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p><em>对应用程序而言，在分布式系统中的数据库看起来就像是只有一个数据源。</em></p><ul><li><a class="link"   href="http://www.importnew.com/cassandra/" >Apache Cassandra<i class="fas fa-external-link-alt"></i></a>：列式数据库，可用性高且没有单点故障。<a class="link"   href="http://cassandra.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/hbase/" >Apache HBase<i class="fas fa-external-link-alt"></i></a>：针对大数据的Hadoop数据库。<a class="link"   href="http://hbase.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/druid/" >Druid<i class="fas fa-external-link-alt"></i></a>：实时和历史OLAP数据存储，在聚集查询和近似查询方面表现不俗。<a class="link"   href="http://druid.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/infinispan/" >Infinispan<i class="fas fa-external-link-alt"></i></a>：针对缓存的高并发键值对数据存储。<a class="link"   href="http://infinispan.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-java.html" >TiDB<i class="fas fa-external-link-alt"></i></a>：开源分布式HTAP数据库，结合了传统的RDBMS和NoSQL的最佳特性。<a class="link"   href="https://pingcap.com/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p><em>以本机格式发布应用程序的工具。</em></p><ul><li>Bintray：发布二进制文件版本控制工具。可以于Maven或Gradle一起配合使用。提供开源免费版本和几种商业收费版本。<a class="link"   href="https://bintray.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/central-repository/" >Central Repository<i class="fas fa-external-link-alt"></i></a>：最大的二进制组件仓库，面向开源社区提供免费服务。Apache Maven默认使用Central <a class="link"   href="http://search.maven.org/" >官网<i class="fas fa-external-link-alt"></i></a>Repository，也可以在所有其他构建工具中使用。</li><li>IzPack：为跨平台部署建立创作工具（Authoring Tool）。<a class="link"   href="http://izpack.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>JitPack：打包GitHub仓库的便捷工具。可根据需要构建Maven、Gradle项目，发布可立即使用的组件。<a class="link"   href="https://jitpack.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Launch4j：将JAR包装为轻量级本机Windows可执行程序。<a class="link"   href="http://launch4j.sourceforge.net/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Nexus：支持代理和缓存功能的二进制管理工具。<a class="link"   href="http://www.sonatype.com/nexus" >官网<i class="fas fa-external-link-alt"></i></a></li><li>packr：将JAR、资源和JVM打包成Windows、Linux和Mac OS X本地发布文件。<a class="link"   href="https://github.com/libgdx/packr/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="文档处理工具"><a href="#文档处理工具" class="headerlink" title="文档处理工具"></a>文档处理工具</h3><p><em>处理Office文档的开发库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/poi/" >Apache POI<i class="fas fa-external-link-alt"></i></a>：支持OOXML规范（XLSX、DOCX、PPTX）以及OLE2规范（XLS、DOC、PPT）。<a class="link"   href="http://poi.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/documents4j/" >documents4j<i class="fas fa-external-link-alt"></i></a>：使用第三方转换器进行文档格式转换，转成类似MS Word这样的格式。<a class="link"   href="http://documents4j.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jopendocument/" >jOpenDocument<i class="fas fa-external-link-alt"></i></a>：处理OpenDocument格式（由Sun公司提出基于XML的文档格式）。<a class="link"   href="http://www.jopendocument.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p><em>函数式编程支持库。</em></p><ul><li>Cyclops：支持一元（Monad）操作和流操作工具类、comprehension（List语法）、模式匹配、trampoline等特性。<a class="link"   href="https://github.com/aol/cyclops" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Fugue：Guava的函数式编程扩展。<a class="link"   href="https://bitbucket.org/atlassian/fugue" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Functional Java：实现了多种基础和高级编程抽象，用来辅助面向组合开发（composition-oriented development）。<a class="link"   href="http://www.functionaljava.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Javaslang：一个函数式组件库，提供持久化数据类型和函数式控制结构。<a class="link"   href="http://javaslang.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>jOOλ：旨在填补Java 8 lambda差距的扩展，提供了众多缺失的类型和一组丰富的顺序流API。<a class="link"   href="https://github.com/jOOQ/jOOL" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h3><p><em>游戏开发框架。</em></p><ul><li><a class="link"   href="http://www.importnew.com/jmonkeyengine/" >jMonkeyEngine<i class="fas fa-external-link-alt"></i></a>：现代3D游戏开发引擎。<a class="link"   href="http://jmonkeyengine.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/libgdx/" >libGDX<i class="fas fa-external-link-alt"></i></a>：全面的跨平台高级框架。<a class="link"   href="https://libgdx.badlogicgames.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/lwjgl/" >LWJGL<i class="fas fa-external-link-alt"></i></a>：对OpenGL&#x2F;CL&#x2F;AL等技术进行抽象的健壮框架。<a class="link"   href="https://www.lwjgl.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>jPCT：基于OpenGL技术开发的3D图形引擎。纯Java的3D引擎。<a class="link"   href="http://www.jpct.net/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p><em>现代图形化用户界面开发库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/javafx/" >JavaFX<i class="fas fa-external-link-alt"></i></a>：Swing的后继者。<a class="link"   href="http://www.oracle.com/technetwork/java/javase/overview/javafx-overview-2158620.html" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/scene_builder/" >Scene Builder<i class="fas fa-external-link-alt"></i></a>：开发JavaFX应用的可视化布局工具。<a class="link"   href="http://docs.oracle.com/javase/8/scene-builder-2/get-started-tutorial/overview.htm#JSBGS164" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="高性能计算"><a href="#高性能计算" class="headerlink" title="高性能计算"></a>高性能计算</h3><p><em>涵盖了从集合到特定开发库的高性能计算相关工具。</em></p><ul><li>Agrona：高性能应用中常见的数据结构和工具方法。<a class="link"   href="https://github.com/real-logic/Agrona" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Disruptor：线程间消息传递开发库。<a class="link"   href="http://lmax-exchange.github.io/disruptor/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>fastutil：快速紧凑的特定类型集合（Collection）。<a class="link"   href="http://fastutil.di.unimi.it/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>GS Collections：受Smalltalk启发的集合框架。<a class="link"   href="https://github.com/goldmansachs/gs-collections" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/hppc/" >HPPC<i class="fas fa-external-link-alt"></i></a>：基础类型集合。<a class="link"   href="http://labs.carrotsearch.com/hppc.html" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Javolution：实时和嵌入式系统的开发库。<a class="link"   href="http://javolution.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jctools/" >JCTools<i class="fas fa-external-link-alt"></i></a>：JDK中缺失的并发工具。<a class="link"   href="https://github.com/JCTools/JCTools" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/koloboke/" >Koloboke<i class="fas fa-external-link-alt"></i></a>：Hash set和hash map。<a class="link"   href="https://github.com/OpenHFT/Koloboke" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Trove：基础类型集合。<a class="link"   href="http://trove.starlight-systems.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>High-scale-lib:Cliff Click 个人开发的高性能并发库<a class="link"   href="https://github.com/stephenc/high-scale-lib" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p><em>简化开发的集成开发环境。</em></p><ul><li><a class="link"   href="http://www.importnew.com/eclipse/" >Eclipse<i class="fas fa-external-link-alt"></i></a>：老牌开源项目，支持多种插件和编程语言。<a class="link"   href="http://www.eclipse.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/intellij-idea/" >IntelliJ IDEA<i class="fas fa-external-link-alt"></i></a>：支持众多JVM语言，是安卓开发者好的选择。商业版主要针对企业客户。<a class="link"   href="http://www.jetbrains.com/idea/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/netbeans/" >NetBeans<i class="fas fa-external-link-alt"></i></a>：为多种技术提供集成化支持，包括Java SE、Java EE、数据库访问、HTML5等。<a class="link"   href="https://netbeans.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/scala-ide/" >Scala IDE<i class="fas fa-external-link-alt"></i></a>：一款基于Eclipse开源平台打造的Scala集成开发环境。<a class="link"   href="http://scala-ide.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/springsource-tool-suite/" >SpringSource Tool Suite（STS）<i class="fas fa-external-link-alt"></i></a>:一款基于Eclipse开源平台打造的Spring应用开发环境。<a class="link"   href="http://spring.io/tools/sts/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><p><em>创建、评价和操作图片的支持库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/imgscalr/" >Imgscalr<i class="fas fa-external-link-alt"></i></a>：纯Java 2D实现，简单、高效、支持硬件加速的图像缩放开发库。<a class="link"   href="https://github.com/thebuzzmedia/imgscalr" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/picasso/" >Picasso<i class="fas fa-external-link-alt"></i></a>：安卓图片下载和图片缓存开发库。<a class="link"   href="http://square.github.io/picasso/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/thumbnailator/" >Thumbnailator<i class="fas fa-external-link-alt"></i></a>：Thumbnailator是一个高质量Java缩略图开发库。<a class="link"   href="https://github.com/coobird/thumbnailator" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/zxing/" >ZXing<i class="fas fa-external-link-alt"></i></a>：支持多种格式的一维、二维条形码图片处理开发库。<a class="link"   href="https://github.com/zxing/zxing" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/im4java/" >im4java<i class="fas fa-external-link-alt"></i></a>: 基于ImageMagick或GraphicsMagick命令行的图片处理开发库，基本上ImageMagick能够支持的图片格式和处理方式都能够处理。<a class="link"   href="http://im4java.sourceforge.net/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Apache Batik：在Java应用中程序以SVG格式显示、生成及处理图像的工具集，包括SVG解析器、SVG生成器、SVG DOM等模块，可以集成使用也可以单独使用，还可以扩展自定义的SVG标签。<a class="link"   href="http://xmlgraphics.apache.org/batik/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p><em>简化JSON处理的开发库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/genson/" >Genson<i class="fas fa-external-link-alt"></i></a>：强大且易于使用的Java到JSON转换开发库。<a class="link"   href="http://owlike.github.io/genson" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/gson/" >Gson<i class="fas fa-external-link-alt"></i></a>：谷歌官方推出的JSON处理库，支持在对象与JSON之间双向序列化，性能良好且可以实时调用。<a class="link"   href="https://github.com/google/gson" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jackson/" >Jackson<i class="fas fa-external-link-alt"></i></a>：与GSON类似，在频繁使用时性能更佳。<a class="link"   href="http://wiki.fasterxml.com/JacksonHome" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/logansquare/" >LoganSquare<i class="fas fa-external-link-alt"></i></a>：基于Jackson流式API，提供对JSON解析和序列化。比GSON与Jackson组合方式效果更好。<a class="link"   href="https://github.com/bluelinelabs/LoganSquare" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/fastjson/" >Fastjson<i class="fas fa-external-link-alt"></i></a>：一个Java语言编写的高性能功能完善的JSON库。<a class="link"   href="https://github.com/Alibaba/fastjson" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Kyro：快速、高效、自动化的Java对象序列化和克隆库。<a class="link"   href="https://github.com/EsotericSoftware/kryo" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="JVM与JDK"><a href="#JVM与JDK" class="headerlink" title="JVM与JDK"></a>JVM与JDK</h3><p><em>目前的JVM和JDK实现。</em></p><ul><li><a class="link"   href="http://www.importnew.com/jdk-9/" >JDK 9<i class="fas fa-external-link-alt"></i></a>：JDK 9的早期访问版本。<a class="link"   href="https://jdk9.java.net/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/openjdk/" >OpenJDK<i class="fas fa-external-link-alt"></i></a>：JDK开源实现。<a class="link"   href="http://openjdk.java.net/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="基于JVM的语言"><a href="#基于JVM的语言" class="headerlink" title="基于JVM的语言"></a>基于JVM的语言</h3><p><em>除Java外，可以用来编写JVM应用程序的编程语言。</em></p><ul><li>Scala：融合了面向对象和函数式编程思想的静态类型编程语言。<a class="link"   href="http://www.scala-lang.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/groovy/" >Groovy<i class="fas fa-external-link-alt"></i></a>：类型可选（Optionally typed）的动态语言，支持静态类型和静态编译。目前是一个Apache孵化器项目。<a class="link"   href="http://www.groovy-lang.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Clojure：可看做现代版Lisp的动态类型语言。<a class="link"   href="http://clojure.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Ceylon：RedHat开发的面向对象静态类型编程语言。<a class="link"   href="http://ceylon-lang.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Kotlin：JetBrain针对JVM、安卓和浏览器提供的静态类型编程语言。<a class="link"   href="http://kotlinlang.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/xtend/" >Xtend<i class="fas fa-external-link-alt"></i></a>：一种静态编程语言，能够将其代码转换为简洁高效的Java代码，并基于JVM运行。<a class="link"   href="http://www.eclipse.org/xtend/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p><em>记录应用程序行为日志的开发库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/log4j2/" >Apache Log4j 2<i class="fas fa-external-link-alt"></i></a>：使用强大的插件和配置架构进行完全重写。<a class="link"   href="http://logging.apache.org/log4j/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/kibana/" >kibana<i class="fas fa-external-link-alt"></i></a>：分析及可视化日志文件。<a class="link"   href="https://www.elastic.co/products/kibana" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/logback/" >Logback<i class="fas fa-external-link-alt"></i></a>：强健的日期开发库，通过Groovy提供很多有趣的选项。<a class="link"   href="http://logback.qos.ch/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/logstash/" >logstash<i class="fas fa-external-link-alt"></i></a>：日志文件管理工具。<a class="link"   href="https://www.elastic.co/products/logstash" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/metrics/" >Metrics<i class="fas fa-external-link-alt"></i></a>：通过JMX或HTTP发布参数，并且支持存储到数据库。<a class="link"   href="https://github.com/dropwizard/metrics" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/slf4j/" >SLF4J<i class="fas fa-external-link-alt"></i></a>：日志抽象层，需要与具体的实现配合使用。<a class="link"   href="http://www.slf4j.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p><em>提供具体统计算法的工具。其算法可从数据中学习。</em></p><ul><li><a class="link"   href="http://www.importnew.com/apache-flink/" >Apache Flink<i class="fas fa-external-link-alt"></i></a>：快速、可靠的大规模数据处理引擎。<a class="link"   href="https://flink.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/apache-hadoop/" >Apache Hadoop<i class="fas fa-external-link-alt"></i></a>：在商用硬件集群上用来进行大规模数据存储的开源软件框架。<a class="link"   href="http://hadoop.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/apache-mahout/" >Apache Mahout<i class="fas fa-external-link-alt"></i></a>：专注协同过滤、聚类和分类的可扩展算法。<a class="link"   href="https://mahout.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/apache-spark/" >Apache Spark<i class="fas fa-external-link-alt"></i></a>：开源数据分析集群计算框架。<a class="link"   href="http://spark.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/deepdive/" >DeepDive<i class="fas fa-external-link-alt"></i></a>：从非结构化数据建立结构化信息并集成到已有数据库的工具。<a class="link"   href="http://deepdive.stanford.edu/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/deeplearning4j/" >Deeplearning4j<i class="fas fa-external-link-alt"></i></a>：分布式多线程深度学习开发库。<a class="link"   href="http://deeplearning4j.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/h2o/" >H2O<i class="fas fa-external-link-alt"></i></a>：用作大数据统计的分析引擎。<a class="link"   href="http://h2o.ai/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/weka/" >Weka<i class="fas fa-external-link-alt"></i></a>：用作数据挖掘的算法集合，包括从预处理到可视化的各个层次。<a class="link"   href="http://www.cs.waikato.ac.nz/ml/weka/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/quickml/" >QuickML<i class="fas fa-external-link-alt"></i></a>：高效机器学习库。<a class="link"   href="http://quickml.org/" >官网<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://github.com/sanity/quickml" >GitHub<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><em>在客户端之间进行消息传递，确保协议独立性的工具。</em></p><ul><li><a class="link"   href="http://www.importnew.com/aeron/" >Aeron<i class="fas fa-external-link-alt"></i></a>：高效可扩展的单播、多播消息传递工具。<a class="link"   href="https://github.com/real-logic/Aeron" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/activemq/" >Apache ActiveMQ<i class="fas fa-external-link-alt"></i></a>：实现JMS的开源消息代理（broker），可将同步通讯转为异步通讯。<a class="link"   href="http://activemq.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/apache-camel/" >Apache Camel<i class="fas fa-external-link-alt"></i></a>：通过企业级整合模式（Enterprise Integration Pattern EIP）将不同的消息传输API整合在一起。<a class="link"   href="http://camel.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/kafka/" >Apache Kafka<i class="fas fa-external-link-alt"></i></a>：高吞吐量分布式消息系统。<a class="link"   href="http://kafka.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/hermes/" >Hermes<i class="fas fa-external-link-alt"></i></a>：快速、可靠的消息代理（Broker），基于Kafka构建。<a class="link"   href="http://hermes.allegro.tech/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>JBoss HornetQ：清晰、准确、模块化，可以方便嵌入的消息工具。<a class="link"   href="http://hornetq.jboss.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jeromq/" >JeroMQ<i class="fas fa-external-link-alt"></i></a>：ZeroMQ的纯Java实现。<a class="link"   href="https://github.com/zeromq/jeromq" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/smack/" >Smack<i class="fas fa-external-link-alt"></i></a>：跨平台XMPP客户端函数库。<a class="link"   href="https://github.com/igniterealtime/Smack/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Openfire：是开源的、基于XMPP、采用Java编程语言开发的实时协作服务器。 Openfire安装和使用都非常简单，并可利用Web界面进行管理。 <a class="link"   href="http://www.igniterealtime.org/projects/openfire/index.jsp" >官网<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://github.com/igniterealtime/Openfire" >GitHub<i class="fas fa-external-link-alt"></i></a></li><li>Spark：是一个开源，跨平台IM客户端。它的特性支持集组聊天，电话集成和强大安全性能。如果企业内部部署IM使用Openfire+Spark是最佳的组合。 <a class="link"   href="http://www.igniterealtime.org/projects/spark/index.jsp" >官网<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://github.com/igniterealtime/Spark" >GitHub<i class="fas fa-external-link-alt"></i></a></li><li>Tigase： 是一个轻量级的可伸缩的 Jabber&#x2F;XMPP 服务器。无需其他第三方库支持，可以处理非常高的复杂和大量的用户数，可以根据需要进行水平扩展。 <a class="link"   href="http://www.tigase.net/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p><em>未分类其它资源。</em></p><ul><li>Design Patterns：实现并解释了最常见的设计模式。<a class="link"   href="https://github.com/iluwatar/java-design-patterns" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Jimfs：内存文件系统。<a class="link"   href="https://github.com/google/jimfs" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Lanterna：类似curses的简单console文本GUI函数库。<a class="link"   href="https://code.google.com/p/lanterna/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>LightAdmin：可插入式CRUD UI函数库，可用来快速应用开发。<a class="link"   href="http://lightadmin.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>OpenRefine：用来处理混乱数据的工具，包括清理、转换、使用Web Service进行扩展并将其关联到数据库。<a class="link"   href="http://openrefine.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>RoboVM：Java编写原生iOS应用。<a class="link"   href="https://robovm.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/quartz/" >Quartz<i class="fas fa-external-link-alt"></i></a>：强大的任务调度库.<a class="link"   href="http://www.quartz-scheduler.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="应用监控工具"><a href="#应用监控工具" class="headerlink" title="应用监控工具"></a>应用监控工具</h3><p><em>监控生产环境中应用程序的工具。</em></p><ul><li><a class="link"   href="http://www.importnew.com/appdynamics/" >AppDynamics<i class="fas fa-external-link-alt"></i></a>：性能监测商业工具。<a class="link"   href="http://www.appdynamics.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/javamelody/" >JavaMelody<i class="fas fa-external-link-alt"></i></a>：性能监测和分析工具。<a class="link"   href="https://github.com/javamelody/javamelody" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/Kamon/" >Kamon<i class="fas fa-external-link-alt"></i></a>：Kamon用来监测在JVM上运行的应用程序。<a class="link"   href="http://www.kamon.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/new-relic/" >New Relic<i class="fas fa-external-link-alt"></i></a>：性能监测商业工具。<a class="link"   href="http://newrelic.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>SPM：支持对JVM应用程序进行分布式事务追踪的性能监测商业工具。<a class="link"   href="https://sematext.com/spm/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/overops_takipi/" >OverOps(Takipi)<i class="fas fa-external-link-alt"></i></a>：产品运行时错误监测及调试商业工具。<a class="link"   href="https://www.takipi.com/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="原生开发库"><a href="#原生开发库" class="headerlink" title="原生开发库"></a>原生开发库</h3><p><em>用来进行特定平台开发的原生开发库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/jna/" >JNA<i class="fas fa-external-link-alt"></i></a>：不使用JNI就可以使用原生开发库。此外，还为常见系统函数提供了接口。<a class="link"   href="https://github.com/java-native-access/jna" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><p><em>用来专门处理文本的函数库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/apache-opennlp/" >Apache OpenNLP<i class="fas fa-external-link-alt"></i></a>：处理类似分词等常见任务的工具。<a class="link"   href="https://opennlp.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/stanford_corenlp/" >CoreNLP<i class="fas fa-external-link-alt"></i></a>：斯坦佛CoreNLP提供了一组基础工具，可以处理类似标签、实体名识别和情感分析这样的任务。<a class="link"   href="http://nlp.stanford.edu/software/coenlp.shtml" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/lingpipe/" >LingPipe<i class="fas fa-external-link-alt"></i></a>：一组可以处理各种任务的工具集，支持POS标签、情感分析等。<a class="link"   href="http://alias-i.com/lingpipe/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/mallet/" >Mallet<i class="fas fa-external-link-alt"></i></a>：统计学自然语言处理、文档分类、聚类、主题建模等。<a class="link"   href="http://mallet.cs.umass.edu/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p><em>网络编程函数库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/async-http-client/" >Async Http Client<i class="fas fa-external-link-alt"></i></a>：异步HTTP和WebSocket客户端函数库。<a class="link"   href="https://github.com/AsyncHttpClient/async-http-client" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/grizzly/" >Grizzly<i class="fas fa-external-link-alt"></i></a>：NIO框架，在Glassfish中作为网络层使用。<a class="link"   href="https://grizzly.java.net/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/netty/" >Netty<i class="fas fa-external-link-alt"></i></a>：构建高性能网络应用程序开发框架。<a class="link"   href="http://netty.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/okhttp/" >OkHttp<i class="fas fa-external-link-alt"></i></a>：一个Android和Java应用的HTTP+SPDY客户端。<a class="link"   href="http://square.github.io/okhttp/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Undertow：基于NIO实现了阻塞和非阻塞API的Web服务器，在WildFly中作为网络层使用。<a class="link"   href="http://undertow.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>unirest-java: Unirest 是一个轻量级的 HTTP 请求库，涵盖 Node、Ruby、Java、PHP、Python、Objective-C、.NET 等多种语言。可发起 GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS 请求。<a class="link"   href="http://unirest.io/java" >官网<i class="fas fa-external-link-alt"></i></a></li><li>brpc-java: java版baidu rpc框架，高性能、多协议、易扩展、低耦合。<a class="link"   href="https://github.com/baidu/brpc-java" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p><em>处理对象持久化的API。</em></p><ul><li><a class="link"   href="http://www.importnew.com/ebean/" >Ebean<i class="fas fa-external-link-alt"></i></a>：支持快速数据访问和编码的ORM框架。<a class="link"   href="http://ebean-orm.github.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/eclipselink/" >EclipseLink<i class="fas fa-external-link-alt"></i></a>：支持许多持久化标准，JPA、JAXB、JCA和SDO。<a class="link"   href="https://www.eclipse.org/eclipselink/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/hibernate/" >Hibernate<i class="fas fa-external-link-alt"></i></a>：广泛使用、强健的持久化框架。Hibernate的技术社区非常活跃。<a class="link"   href="http://hibernate.org/orm/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/mybatis/" >MyBatis<i class="fas fa-external-link-alt"></i></a>：带有存储过程或者SQL语句的耦合对象（Couples object）。<a class="link"   href="http://mybatis.github.io/mybatis-3/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/ormlite/" >OrmLite<i class="fas fa-external-link-alt"></i></a>：轻量级开发包，免除了其它ORM产品中的复杂性和开销。<a class="link"   href="http://ormlite.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Nutz：另一个SSH。<a class="link"   href="http://nutzam.com/" >官网<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://github.com/nutzam/nutz" >Github<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://nutz.cn/" >论坛<i class="fas fa-external-link-alt"></i></a></li><li>JFinal：JAVA WEB + ORM框架。<a class="link"   href="http://www.jfinal.com/" >官网<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://github.com/jfinal/jfinal" >Github<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://openjpa.apache.org/" >Apache OpenJPA<i class="fas fa-external-link-alt"></i></a>: 实现了 EJB 3.0 中的 JPA 标准,为开发者提供功能强大、使用简单的持久化数据管理框架。 <a class="link"   href="http://openjpa.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h3><p><em>用来帮助创建PDF文件的资源。</em></p><ul><li><a class="link"   href="http://www.importnew.com/apache_fop/" >Apache FOP<i class="fas fa-external-link-alt"></i></a>：从XSL-FO创建PDF。<a class="link"   href="http://xmlgraphics.apache.org/fop/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/apache-pdfbox/" >Apache PDFBox<i class="fas fa-external-link-alt"></i></a>：用来创建和操作PDF的工具集。<a class="link"   href="http://pdfbox.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/dynamicreports/" >DynamicReports<i class="fas fa-external-link-alt"></i></a>：JasperReports的精简版。<a class="link"   href="http://dynamicreports.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/flyingsaucer/" >flyingsaucer<i class="fas fa-external-link-alt"></i></a>：XML&#x2F;XHTML和CSS 2.1渲染器。<a class="link"   href="https://github.com/flyingsaucerproject/flyingsaucer" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/itext/" >iText<i class="fas fa-external-link-alt"></i></a>：一个易于使用的PDF函数库，用来编程创建PDF文件。注意，用于商业用途时需要许可证。<a class="link"   href="http://itextpdf.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jasperreports/" >JasperReports<i class="fas fa-external-link-alt"></i></a>：一个复杂的报表引擎。<a class="link"   href="http://community.jaspersoft.com/project/jasperreports-library" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p><em>性能分析、性能剖析及基准测试工具。</em></p><ul><li><a class="link"   href="http://www.importnew.com/jhiccup/" >jHiccup<i class="fas fa-external-link-alt"></i></a>：提供平台中JVM暂停的日志和记录。<a class="link"   href="https://github.com/giltene/jHiccup" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jmh/" >JMH<i class="fas fa-external-link-alt"></i></a>：JVM基准测试工具。<a class="link"   href="http://openjdk.java.net/projects/code-tools/jmh/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jprofiler/" >JProfiler<i class="fas fa-external-link-alt"></i></a>：商业分析器。<a class="link"   href="https://www.ej-technologies.com/products/jprofiler/overview.html" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/latencyutils/" >LatencyUtils<i class="fas fa-external-link-alt"></i></a>：测量和报告延迟的工具。<a class="link"   href="https://github.com/LatencyUtils/LatencyUtils" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/visualvm/" >VisualVM<i class="fas fa-external-link-alt"></i></a>：对运行中的应用程序信息提供了可视化界面。<a class="link"   href="http://visualvm.java.net/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/yourkit-java-profiler/" >YourKit Java Profiler<i class="fas fa-external-link-alt"></i></a>：商业分析器。<a class="link"   href="https://www.yourkit.com/features/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="响应式开发库"><a href="#响应式开发库" class="headerlink" title="响应式开发库"></a>响应式开发库</h3><p><em>用来开发响应式应用程序的开发库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/reactive-streams/" >Reactive Streams<i class="fas fa-external-link-alt"></i></a>：异步流处理标准，支持非阻塞式反向压力（backpressure）。<a class="link"   href="https://github.com/reactive-streams/reactive-streams-jv/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/reactor/" >Reactor<i class="fas fa-external-link-alt"></i></a>：构建响应式快速数据（fast-data）应用程序的开发库。<a class="link"   href="http://projectreactor.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/rxjava/" >RxJava<i class="fas fa-external-link-alt"></i></a>：通过JVM可观察序列（observable sequence）构建异步和基于事件的程序。<a class="link"   href="https://github.com/ReactiveX/RxJava" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="REST框架"><a href="#REST框架" class="headerlink" title="REST框架"></a>REST框架</h3><p><em>用来创建RESTful 服务的框架。</em></p><ul><li><a class="link"   href="http://www.importnew.com/dropwizard/" >Dropwizard<i class="fas fa-external-link-alt"></i></a>：偏向于自己使用的Web框架。用来构建Web应用程序，使用了Jetty、Jackson、Jersey和Metrics。<a class="link"   href="https://dropwizard.github.io/drpwizard/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/feign/" >Feign<i class="fas fa-external-link-alt"></i></a>：受Retrofit、JAXRS-2.0和WebSocket启发的HTTP客户端连接器（binder）。<a class="link"   href="https://github.com/Netflix/feign" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Jersey：JAX-RS参考实现。<a class="link"   href="https://jersey.java.net/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/resteasy/" >RESTEasy<i class="fas fa-external-link-alt"></i></a>：经过JAX-RS规范完全认证的可移植实现。<a class="link"   href="http://resteasy.jboss.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/restexpress/" >RestExpress<i class="fas fa-external-link-alt"></i></a>：一个Java类型安全的REST客户端。<a class="link"   href="https://github.com/RestExpress/RestExpress" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/restx/" >RestX<i class="fas fa-external-link-alt"></i></a>：基于注解处理和编译时源码生成的框架。<a class="link"   href="http://restx.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/retrofit/" >Retrofit<i class="fas fa-external-link-alt"></i></a>：类型安全的REST客户端。<a class="link"   href="http://square.github.io/retrofit/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/sparkjava/" >Spark<i class="fas fa-external-link-alt"></i></a>：受到Sinatra启发的Java REST框架。<a class="link"   href="http://sparkjava.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/swagger/" >Swagger<i class="fas fa-external-link-alt"></i></a>：Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTful Web Service。<a class="link"   href="http://swagger.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/bladejava/" >Blade<i class="fas fa-external-link-alt"></i></a>：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。<a class="link"   href="https://lets-blade.com/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="科学计算与分析"><a href="#科学计算与分析" class="headerlink" title="科学计算与分析"></a>科学计算与分析</h3><p><em>用于科学计算和分析的函数库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/datamelt/" >DataMelt<i class="fas fa-external-link-alt"></i></a>：用于科学计算、数据分析及数据可视化的开发环境。<a class="link"   href="http://jwork.org/dmelt/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jgrapht/" >JGraphT<i class="fas fa-external-link-alt"></i></a>：支持数学图论对象和算法的图形库。<a class="link"   href="https://github.com/jgrapht/jgrapht" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jscience/" >JScience<i class="fas fa-external-link-alt"></i></a>：用来进行科学测量和单位的一组类。<a class="link"   href="http://jscience.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p><em>文档索引引擎，用于搜索和分析。</em></p><ul><li><a class="link"   href="http://www.importnew.com/solr/" >Apache Solr<i class="fas fa-external-link-alt"></i></a>：一个完全的企业搜索引擎。为高吞吐量通信进行了优化。<a class="link"   href="http://lucene.apache.org/solr/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Elasticsearch：一个分布式、支持多租户（multitenant）全文本搜索引擎。提供了RESTful Web接口和无schema的JSON文档。<a class="link"   href="http://www.elsticsearch.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Apache Lucene：是一个开放源代码的全文检索引擎工具包，是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。<a class="link"   href="http://lucene.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p><em>用于处理安全、认证、授权或会话管理的函数库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/shiro/" >Apache Shiro<i class="fas fa-external-link-alt"></i></a>：执行认证、授权、加密和会话管理。<a class="link"   href="http://shiro.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/bouncy-castle/" >Bouncy Castle<i class="fas fa-external-link-alt"></i></a>，涵盖了从基础的帮助函数到PGP&#x2F;SMIME操作。<a class="link"   href="https://www.bouncycastle.org/java.html" >官网<i class="fas fa-external-link-alt"></i></a>：多途加密开发库。支持JCA提供者（JCA provider)</li><li><a class="link"   href="http://www.importnew.com/cryptomator/" >Cryptomator<i class="fas fa-external-link-alt"></i></a>：在云上进行客户端跨平台透明加密。<a class="link"   href="https://cryptomator.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/keycloak/" >Keycloak<i class="fas fa-external-link-alt"></i></a>：为浏览器应用和RESTful Web Service集成SSO和IDM。目前还处于beta版本，但是看起来非常有前途。<a class="link"   href="http://keycloak.jboss.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/picketlink/" >PicketLink<i class="fas fa-external-link-alt"></i></a>：PicketLink是一个针对Java应用进行安全和身份认证管理的大型项目（Umbrella Project）。<a class="link"   href="http://picketlink.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p><em>用来高效处理序列化的函数库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/flatbuffers/" >FlatBuffers<i class="fas fa-external-link-alt"></i></a>：高效利用内存的序列化函数库，无需解包和解析即可高效访问序列化数据。<a class="link"   href="https://github.com/google/flatbuffers" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/kryo/" >Kryo<i class="fas fa-external-link-alt"></i></a>：快速、高效的对象图形序列化框架。<a class="link"   href="https://github.com/EsotericSoftware/kryo" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/fst/" >FST<i class="fas fa-external-link-alt"></i></a>：提供兼容JDK的高性能对象图形序列化。<a class="link"   href="https://github.com/RuedigerMoeller/fast-serialization" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/messagepack/" >MessagePack<i class="fas fa-external-link-alt"></i></a>：一种高效的二进制序列化格式。<a class="link"   href="https://github.com/msgpack/msgpack-java" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a>应用服务器</h3><p><em>用来部署应用程序的服务器。</em></p><ul><li><a class="link"   href="http://www.importnew.com/apache-tomcat/" >Apache Tomcat<i class="fas fa-external-link-alt"></i></a>：针对Servlet和JSP的应用服务器，健壮性好且适用性强。<a class="link"   href="http://tomcat.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/tomee/" >Apache TomEE<i class="fas fa-external-link-alt"></i></a>：Tomcat加Java EE。<a class="link"   href="http://tomee.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jetty/" >Jetty<i class="fas fa-external-link-alt"></i></a>：轻量级、小巧的应用服务器，通常会嵌入到项目中。<a class="link"   href="http://www.eclipse.org/jetty/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/websphere-liberty/" >WebSphere Liberty<i class="fas fa-external-link-alt"></i></a>：轻量级、模块化应用服务器，由IBM开发。<a class="link"   href="https://developer.ibm.com/wasdev/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/wildfly/" >WildFly<i class="fas fa-external-link-alt"></i></a>：之前被称作JBoss，由Red Hat开发。支持很多Java EE功能。<a class="link"   href="http://www.wildfly.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p><em>在模板中替换表达式的工具。</em></p><ul><li><a class="link"   href="http://www.importnew.com/velocity/" >Apache Velocity<i class="fas fa-external-link-alt"></i></a>：提供HTML页面模板、email模板和通用开源代码生成器模板。<a class="link"   href="http://velocity.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/freemarker/" >FreeMarker<i class="fas fa-external-link-alt"></i></a>：通用模板引擎，不需要任何重量级或自己使用的依赖关系。<a class="link"   href="http://freemarker.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/handlebars-java/" >Handlebars.java<i class="fas fa-external-link-alt"></i></a>：使用Java编写的模板引擎，逻辑简单，支持语义扩展（semantic Mustache）。<a class="link"   href="http://jknack.github.io/handlebars.java/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/thymeleaf/" >Thymeleaf<i class="fas fa-external-link-alt"></i></a>：旨在替换JSP，支持XML文件的工具。<a class="link"   href="http://www.thymeleaf.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://ibeetl.com/" >Beetl<i class="fas fa-external-link-alt"></i></a>：新一代的模板引擎，功能强大，性能良好，超过当前流行的模板引擎。而且还易学易用。<a class="link"   href="http://ibeetl.com/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><em>测试内容从对象到接口，涵盖性能测试和基准测试工具。</em></p><ul><li><a class="link"   href="http://www.importnew.com/jmeter/" >Apache JMeter<i class="fas fa-external-link-alt"></i></a>：功能性测试和性能评测。<a class="link"   href="http://jmeter.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/arquillian/" >Arquillian<i class="fas fa-external-link-alt"></i></a>：集成测试和功能行测试平台，集成Java EE容器。<a class="link"   href="http://arquillian.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/assertj/" >AssertJ<i class="fas fa-external-link-alt"></i></a>：支持流式断言提高测试的可读性。<a class="link"   href="http://joel-costigliola.github.io/assertj/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/awaitility/" >Awaitility<i class="fas fa-external-link-alt"></i></a>：用来同步异步操作的DSL。<a class="link"   href="https://github.com/jayway/awaitility" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/cucumber-jvm/" >Cucumber<i class="fas fa-external-link-alt"></i></a>：BDD测试框架。<a class="link"   href="https://github.com/cucumber/cucumber-jvm" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Gatling：设计为易于使用、可维护的和高性能负载测试工具。<a class="link"   href="http://gatling.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/hamcrest/" >Hamcrest<i class="fas fa-external-link-alt"></i></a>：可用来灵活创建意图（intent）表达式的匹配器。<a class="link"   href="http://hamcrest.org/JavaHamcrest/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>JMockit：用来模拟静态、final方法等。<a class="link"   href="http://jmockit.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/junit/" >JUnit<i class="fas fa-external-link-alt"></i></a>：通用测试框架。<a class="link"   href="http://junit.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/mockito/" >Mockito<i class="fas fa-external-link-alt"></i></a>：在自动化单元测试中创建测试对象，为TDD或BDD提供支持。<a class="link"   href="https://github.com/mockito/mockito" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/powermock/" >PowerMock<i class="fas fa-external-link-alt"></i></a>： 支持模拟静态方法、构造函数、final类和方法、私有方法以及移除静态初始化器的模拟工具。<a class="link"   href="https://github.com/jayway/powermock" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/rest-assured/" >REST Assured<i class="fas fa-external-link-alt"></i></a>：为REST&#x2F;HTTP服务提供方便测试的Java DSL。<a class="link"   href="https://github.com/jayway/rest-assured" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/selenide/" >Selenide<i class="fas fa-external-link-alt"></i></a>：为Selenium提供精准的周边API，用来编写稳定且可读的UI测试。<a class="link"   href="http://selenide.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/selenium/" >Selenium<i class="fas fa-external-link-alt"></i></a>：为Web应用程序提供可移植软件测试框架。<a class="link"   href="http://docs.seleniumhq.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/spock/" >Spock<i class="fas fa-external-link-alt"></i></a>：JUnit-compatible framework featuring an expressive Groovy-derived specification language.<a class="link"   href="http://docs.spockframework.org/" >官网<i class="fas fa-external-link-alt"></i></a>兼容JUnit框架，支持衍生的Groovy范的语言。</li><li><a class="link"   href="http://www.importnew.com/testng/" >TestNG<i class="fas fa-external-link-alt"></i></a>：测试框架。<a class="link"   href="http://testng.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/truth/" >Truth<i class="fas fa-external-link-alt"></i></a>：Google的断言和命题（proposition）框架。<a class="link"   href="https://github.com/google/truth" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/unitils/" >Unitils<i class="fas fa-external-link-alt"></i></a>：模块化测试函数库，支持单元测试和集成测试。<a class="link"   href="http://www.unitils.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/wiremock/" >WireMock<i class="fas fa-external-link-alt"></i></a>：Web Service测试桩（Stub）和模拟函数。<a class="link"   href="http://wiremock.org/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="通用工具库"><a href="#通用工具库" class="headerlink" title="通用工具库"></a>通用工具库</h3><p><em>通用工具类函数库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/apache-commons/" >Apache Commons<i class="fas fa-external-link-alt"></i></a>：提供各种用途的函数，比如配置、验证、集合、文件上传或XML处理等。<a class="link"   href="http://commons.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/args4j/" >args4j<i class="fas fa-external-link-alt"></i></a>：命令行参数解析器。<a class="link"   href="http://args4j.kohsuke.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/crash/" >CRaSH<i class="fas fa-external-link-alt"></i></a>：为运行进行提供CLI。<a class="link"   href="http://www.crashub.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/gephi/" >Gephi<i class="fas fa-external-link-alt"></i></a>：可视化跨平台网络图形化操作程序。<a class="link"   href="https://github.com/gephi/gephi/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/guava/" >Guava<i class="fas fa-external-link-alt"></i></a>：集合、缓存、支持基本类型、并发函数库、通用注解、字符串处理、I&#x2F;O等。<a class="link"   href="https://github.com/google/guava" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jade/" >JADE<i class="fas fa-external-link-alt"></i></a>：构建、调试多租户系统的框架和环境。<a class="link"   href="http://jade.tilab.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/javatuples/" >javatuples<i class="fas fa-external-link-alt"></i></a>：正如名字表示的那样，提供tuple支持。尽管目前tuple的概念还有留有争议。<a class="link"   href="http://www.javatuples.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jcommander/" >JCommander<i class="fas fa-external-link-alt"></i></a>：命令行参数解析器。<a class="link"   href="http://jcommander.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/protege/" >Protégé<i class="fas fa-external-link-alt"></i></a>：提供存在论（ontology）编辑器以及构建知识系统的框架。<a class="link"   href="http://protege.stanford.edu/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/looly/hutool" >Hutool<i class="fas fa-external-link-alt"></i></a>：一个Java工具集，缓存、HTTP、加密解密、DFA、JSON、分组配置文件、数据库操作、图片验证码、Excel读写、定时任务、模板引擎、邮件、Servlet、二维码、Emoji、分词等一系列工具类。<a class="link"   href="https://hutool.cn/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h3><p><em>用于分析网站内容的函数库。</em></p><ul><li><a class="link"   href="http://www.importnew.com/nutch/" >Apache Nutch<i class="fas fa-external-link-alt"></i></a>：可用于生产环境的高度可扩展、可伸缩的网络爬虫。<a class="link"   href="http://nutch.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/crawler4j/" >Crawler4j<i class="fas fa-external-link-alt"></i></a>：简单的轻量级网络爬虫。<a class="link"   href="https://github.com/yasserg/crawler4j" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jsoup/" >JSoup<i class="fas fa-external-link-alt"></i></a>：刮取、解析、操作和清理HTML。<a class="link"   href="http://jsoup.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/code4craft/webmagic/" >webmagic<i class="fas fa-external-link-alt"></i></a>：一个可扩展的Java爬虫框架，架构类似Python的Scrapy。</li></ul><h3 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a>Web框架</h3><p><em>用于处理Web应用程序不同层次间通讯的框架。</em></p><ul><li><a class="link"   href="http://www.importnew.com/apache-tapestry/" >Apache Tapestry<i class="fas fa-external-link-alt"></i></a>：基于组件的框架，使用Java创建动态、强健的、高度可扩展的Web应用程序。<a class="link"   href="http://tapestry.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/apache-wicket/" >Apache Wicket<i class="fas fa-external-link-alt"></i></a>：基于组件的Web应用框架，与Tapestry类似带有状态显示GUI。<a class="link"   href="http://wicket.apache.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/gwt/" >Google Web Toolkit<i class="fas fa-external-link-alt"></i></a>：一组Web开发工具集，包含在客户端将Java代码转为JavaScript的编译器、XML解析器、RCP <a class="link"   href="http://www.gwtproject.org/" >官网<i class="fas fa-external-link-alt"></i></a>API、JUnit集成、国际化支持和GUI控件。</li><li><a class="link"   href="http://www.importnew.com/grails/" >Grails<i class="fas fa-external-link-alt"></i></a>：Groovy框架，旨在提供一个高效开发环境，使用约定而非配置、没有XML并支持混入（mixin）。<a class="link"   href="https://grails.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/ninja/" >Ninja<i class="fas fa-external-link-alt"></i></a>：Java全栈Web开发框架。非常稳固、快速和高效。<a class="link"   href="http://www.ninjaframework.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/pippo/" >Pippo<i class="fas fa-external-link-alt"></i></a>：小型、高度模块化的类Sinatra框架。<a class="link"   href="http://www.pippo.ro/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/play-framework/" >Play<i class="fas fa-external-link-alt"></i></a>：使用约定而非配置，支持代码热加载并在浏览器中显示错误。<a class="link"   href="https://www.playframework.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/primefaces/" >PrimeFaces<i class="fas fa-external-link-alt"></i></a>：JSF框架，提供免费和带支持的商业版本。包括若干前端组件。<a class="link"   href="http://primefaces.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/ratpack/" >Ratpack<i class="fas fa-external-link-alt"></i></a>：一组Java开发函数库，用于构建快速、高效、可扩展且测试完备的HTTP应用程序。<a class="link"   href="https://ratpack.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/spring-boot/" >Spring Boot<i class="fas fa-external-link-alt"></i></a>：微框架，简化了Spring新程序的开发过程。<a class="link"   href="http://projects.spring.io/spring-boot/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/spring-framework/" >Spring<i class="fas fa-external-link-alt"></i></a>：旨在简化Java EE的开发过程，提供依赖注入相关组件并支持面向切面编程。<a class="link"   href="http://projects.spring.io/spring-framework/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/vaadin/" >Vaadin<i class="fas fa-external-link-alt"></i></a>：基于GWT构建的事件驱动框架。使用服务端架构，客户端使用Ajax。<a class="link"   href="https://vaadin.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/bladejava/" >Blade<i class="fas fa-external-link-alt"></i></a>：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。<a class="link"   href="https://lets-blade.com/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="业务流程管理套件"><a href="#业务流程管理套件" class="headerlink" title="业务流程管理套件"></a>业务流程管理套件</h3><p><em>流程驱动的软件系统构建。</em></p><ul><li><a class="link"   href="http://www.importnew.com/jbpm/" >jBPM<i class="fas fa-external-link-alt"></i></a>：非常灵活的业务流程管理框架，致力于构建开发与业务分析人员之间的桥梁。<a class="link"   href="http://www.jbpm.org/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Activity：轻量级工作流和业务流程管理框架。<a class="link"   href="http://www.activiti.org/" >官网<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://github.com/Activiti/Activiti" >github<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><ul><li>r&#x2F;java：Reddit的Java子社区。<a class="link"   href="https://www.reddit.com/r/java" >官网<i class="fas fa-external-link-alt"></i></a></li><li>stackoverflow：问答平台。<a class="link"   href="http://stackoverflow.com/questions/tagged/java" >官网<i class="fas fa-external-link-alt"></i></a></li><li>vJUG：虚拟Java用户组。<a class="link"   href="http://virtualjug.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>java8 新特性教程例子。<a class="link"   href="https://github.com/winterbe/java8-tutorial" >github<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="有影响力的书"><a href="#有影响力的书" class="headerlink" title="有影响力的书"></a>有影响力的书</h3><p><em>具有广泛影响且值得阅读的Java经典书籍。</em></p><ul><li><a class="link"   href="http://www.importnew.com/effective-java/" >Effective Java (2nd Edition)<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/java-8-in-action/" >Java 8 in Action<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/java-concurrency-in-practice/" >Java Concurrency in Practice | Java并发编程实战<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/thinking-in-java/" >Thinking in Java | Java编程思想<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/java-puzzlers/" >Java Puzzlers | Java解惑<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="播客"><a href="#播客" class="headerlink" title="播客"></a>播客</h3><p><em>可以一边编程一边听的东西。</em></p><ul><li>Java Council：<a class="link"   href="http://virtualjug.com/#podcast/" >官网<i class="fas fa-external-link-alt"></i></a></li><li>Java Posse：Discontinued as of 02&#x2F;2015.<a class="link"   href="http://www.javaposse.com/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="微博、微信公众号"><a href="#微博、微信公众号" class="headerlink" title="微博、微信公众号"></a>微博、微信公众号</h3><ul><li>ImportNew：是最受欢迎的、专注Java技术分享的微信公众号。专注Java技术分享，包括Java基础技术、进阶技能、架构设计和Java技术领域动态等。<br><img                       lazyload                     alt="image"                     data-src="http://ww2.sinaimg.cn/small/63918611gw1epb2c7rv2uj20460463ym.jpg"                      alt="img"                ></li><li>ImportNew 微博：<a class="link"   href="http://weibo.com/importnew" >@ImportNew<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h3><ul><li><a class="link"   href="https://twitter.com/AdamBien/" >Adam Bien<i class="fas fa-external-link-alt"></i></a>：自由职业者、作家、JavaONE明星演讲者、顾问、Java Champion。</li><li><a class="link"   href="https://twitter.com/agoncal/" >Antonio Goncalves<i class="fas fa-external-link-alt"></i></a>：Java Champion、JUG Leader、Devoxx France、Java EE 6&#x2F;7、JCP、作家。</li><li><a class="link"   href="https://twitter.com/arungupta/" >Arun Gupta<i class="fas fa-external-link-alt"></i></a>：Java Champion、JavaONE明星演讲者、JUG Leader、Devoxx4Kids成员、Red Hatter。</li><li><a class="link"   href="https://twitter.com/brunoborges" >Bruno Borges<i class="fas fa-external-link-alt"></i></a>：Oracle产品经理、Java Jock。</li><li><a class="link"   href="https://twitter.com/edburns" >Ed Burns<i class="fas fa-external-link-alt"></i></a>：Oracle技术团队顾问。</li><li><a class="link"   href="https://twitter.com/baeldung" >Eugen Paraschiv<i class="fas fa-external-link-alt"></i></a>：Spring安全课程作者。</li><li><a class="link"   href="https://twitter.com/JavaFXpert" >James Weaver<i class="fas fa-external-link-alt"></i></a>：Java、JavaFX、IoT开发者、作者和演讲者。</li><li><a class="link"   href="https://twitter.com/Java_EE/" >Java EE<i class="fas fa-external-link-alt"></i></a>：Java EE Twitter官方账号。</li><li><a class="link"   href="https://twitter.com/Oraclejavamag" >Java Magazine<i class="fas fa-external-link-alt"></i></a>：Java杂志官方账号。</li><li><a class="link"   href="https://twitter.com/javanetbuzz/" >Java.net<i class="fas fa-external-link-alt"></i></a>：Java.net官方账号。</li><li><a class="link"   href="https://twitter.com/java/" >Java<i class="fas fa-external-link-alt"></i></a>：Java Twitter官方账号。</li><li><a class="link"   href="https://twitter.com/javinpaul" >Javin Paul<i class="fas fa-external-link-alt"></i></a>：知名Java博客作者。</li><li><a class="link"   href="https://twitter.com/lukaseder" >Lukas Eder<i class="fas fa-external-link-alt"></i></a>：Data Geekery（jOOQ）创始人兼CEO。</li><li><a class="link"   href="https://twitter.com/mariofusco" >Mario Fusco<i class="fas fa-external-link-alt"></i></a>：RedHatter、JUG协调、活跃讲师和作者。</li><li><a class="link"   href="https://twitter.com/mreinhold" >Mark Reinhold<i class="fas fa-external-link-alt"></i></a>：Oracle首席架构师、Java平台开发组。</li><li><a class="link"   href="https://twitter.com/karianna" >Martijn Verburg<i class="fas fa-external-link-alt"></i></a>：London JUG co-leader、演讲者、作家、Java Champion等。</li><li><a class="link"   href="https://twitter.com/OpenJDK" >OpenJDK<i class="fas fa-external-link-alt"></i></a>：OpenJDK官方账号。</li><li><a class="link"   href="https://twitter.com/reza_rahman" >Reza Rahman<i class="fas fa-external-link-alt"></i></a>：Java EE、GlassFish、WebLogic传道者、作家、演讲者、开源黑客。</li><li><a class="link"   href="https://twitter.com/sjmaple" >Simon Maple<i class="fas fa-external-link-alt"></i></a>：Java Champion、virtualJUG创始人、LJC leader、RebelLabs作者。</li><li><a class="link"   href="https://twitter.com/jodastephen" >Stephen Colebourne<i class="fas fa-external-link-alt"></i></a>： Java Champion、演讲者。</li><li><a class="link"   href="https://twitter.com/kablosna" >Tim Boudreau<i class="fas fa-external-link-alt"></i></a>：作家、NetBeans大牛。</li><li><a class="link"   href="https://twitter.com/trisha_gee" >Trisha Gee<i class="fas fa-external-link-alt"></i></a>：Java Champion、演讲者。</li></ul><h3 id="微博、微信公众号-1"><a href="#微博、微信公众号-1" class="headerlink" title="微博、微信公众号"></a>微博、微信公众号</h3><ul><li>ImportNew 微博：<a class="link"   href="http://weibo.com/importnew" >@ImportNew<i class="fas fa-external-link-alt"></i></a></li><li>ImportNew：最受欢迎的、专注Java技术分享的微信公众号。专注Java技术分享，包括Java基础技术、进阶技能、架构设计和Java技术领域动态等。<br><img                       lazyload                     alt="image"                     data-src="http://ww2.sinaimg.cn/small/63918611gw1epb2c7rv2uj20460463ym.jpg"                      alt="img"                ></li></ul><h3 id="知名网站"><a href="#知名网站" class="headerlink" title="知名网站"></a>知名网站</h3><p><em>值得关注的Java技术站点。</em></p><h4 id="中文站点"><a href="#中文站点" class="headerlink" title="中文站点"></a>中文站点</h4><ul><li><a class="link"   href="http://www.importnew.com/" >ImportNew<i class="fas fa-external-link-alt"></i></a>（ImportNew 专注 Java 技术）</li></ul><h4 id="英文站点"><a href="#英文站点" class="headerlink" title="英文站点"></a>英文站点</h4><ul><li><a class="link"   href="https://android-arsenal.com/" >Android Arsenal<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/google-java-style/" >Google Java Style<i class="fas fa-external-link-alt"></i></a>：<a class="link"   href="https://google.github.io/styleguide/javaguide.html" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/infoq/" >InfoQ<i class="fas fa-external-link-alt"></i></a>：<a class="link"   href="http://www.infoq.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.javacodegeeks.com/" >Java Code Geeks<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://blog.jooq.org/" >Java, SQL, and jOOQ<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://java.net/" >Java.net<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://java.dzone.com/" >Javalobby<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/javaworld/" >JavaWorld<i class="fas fa-external-link-alt"></i></a>：<a class="link"   href="http://www.javaworld.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/jaxenter/" >JAXenter<i class="fas fa-external-link-alt"></i></a>：<a class="link"   href="https://jaxenter.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://zeroturnaround.com/rebellabs/" >RebelLabs<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/javaspecialists/" >The Java Specialist’ Newsletter<i class="fas fa-external-link-alt"></i></a>：<a class="link"   href="http://www.javaspecialists.eu/archive/archive.jsp" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://blog.takipi.com/" >The Takipi Blog<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/theserverside/" >TheServerSide.com<i class="fas fa-external-link-alt"></i></a>：服务器编程交流平台是一个老牌的IT信息网站，关注服务器端编程的，以Java和.Net周边信息为主。<a class="link"   href="http://www.theserverside.com/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.thoughts-on-java.org/" >Thoughts On Java<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://vanillajava.blogspot.ch/" >Vanilla Java<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://vladmihalcea.com/" >Vlad Mihalcea on Hibernate<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.voxxed.com/" >Voxxed<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.importnew.com/onjava/" >OnJava<i class="fas fa-external-link-alt"></i></a>：O’Reilly Java包含最新的Java技术资讯，优质代码，完全的实例和详解。<a class="link"   href="http://www.onjava.com/" >官网<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java资源大全&quot;&gt;&lt;a href=&quot;#Java资源大全&quot; class=&quot;headerlink&quot; title=&quot;Java资源大全&quot;&gt;&lt;/a&gt;Java资源大全&lt;/h1&gt;&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;算法&lt;/</summary>
      
    
    
    
    <category term="Java资源大全" scheme="http://example.com/categories/Java%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8/"/>
    
    
    <category term="Java资源" scheme="http://example.com/tags/Java%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>后端架构师技术图谱</title>
    <link href="http://example.com/2023/02/19/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
    <id>http://example.com/2023/02/19/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/</id>
    <published>2023-02-18T23:00:21.597Z</published>
    <updated>2023-02-20T08:27:14.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后端架构师技术图谱"><a href="#后端架构师技术图谱" class="headerlink" title="后端架构师技术图谱"></a>后端架构师技术图谱</h1><p>👍 👍 👍 推荐一个在线搜课程的神器，“<a class="link"   href="https://www.kcsou.com/" >课程搜<i class="fas fa-external-link-alt"></i></a>”：<a class="link"   href="https://www.kcsou.com/s_%E6%9E%B6%E6%9E%84%E5%B8%88/" >https://www.kcsou.com/s_架构师/<i class="fas fa-external-link-alt"></i></a></p><hr><ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E9%98%9F%E5%88%97" >队列<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E9%9B%86%E5%90%88" >集合<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E9%93%BE%E8%A1%A8%E3%80%81%E6%95%B0%E7%BB%84" >链表、数组<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%AD%97%E5%85%B8%E3%80%81%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84" >字典、关联数组<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%A0%88" >栈<i class="fas fa-external-link-alt"></i></a></li><li>树<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%BA%8C%E5%8F%89%E6%A0%91" >二叉树<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" >完全二叉树<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" >平衡二叉树<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88bst%EF%BC%89" >二叉查找树（BST）<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%BA%A2%E9%BB%91%E6%A0%91" >红黑树<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#b%EF%BC%8Cb-%EF%BC%8Cb-%E6%A0%91" >B，B+，B*树<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#lsm-%E6%A0%91" >LSM 树<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#bitset" >BitSet<i class="fas fa-external-link-alt"></i></a></li><li>排序、查找算法<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" >选择排序<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" >冒泡排序<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" >插入排序<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" >快速排序<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" >归并排序<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" >希尔排序<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%A0%86%E6%8E%92%E5%BA%8F" >堆排序<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" >计数排序<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%A1%B6%E6%8E%92%E5%BA%8F" >桶排序<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" >基数排序<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE" >二分查找<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#java-%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%E5%B7%A5%E5%85%B7" >Java 中的排序工具<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8" >布隆过滤器<i class="fas fa-external-link-alt"></i></a></li><li>字符串比较<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#kmp-%E7%AE%97%E6%B3%95" >KMP 算法<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E3%80%81%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88" >深度优先、广度优先<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95" >贪心算法<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95" >回溯算法<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%89%AA%E6%9E%9D%E7%AE%97%E6%B3%95" >剪枝算法<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" >动态规划<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF" >朴素贝叶斯<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95" >推荐算法<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95" >最小生成树算法<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95" >最短路径算法<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#java-%E5%B9%B6%E5%8F%91" >Java 并发<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B" >多线程<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8" >线程安全<i class="fas fa-external-link-alt"></i></a></li><li>一致性、事务<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%BA%8B%E5%8A%A1-acid-%E7%89%B9%E6%80%A7" >事务 ACID 特性<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" >事务的隔离级别<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#mvcc" >MVCC<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>锁<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#java%E4%B8%AD%E7%9A%84%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E7%B1%BB" >Java中的锁和同步类<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81" >公平锁 &amp; 非公平锁<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%82%B2%E8%A7%82%E9%94%81" >悲观锁<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%B9%90%E8%A7%82%E9%94%81-cas" >乐观锁 &amp; CAS<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#aba-%E9%97%AE%E9%A2%98" >ABA 问题<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#copyonwrite%E5%AE%B9%E5%99%A8" >CopyOnWrite容器<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#ringbuffer" >RingBuffer<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81" >可重入锁 &amp; 不可重入锁<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%BA%92%E6%96%A5%E9%94%81-%E5%85%B1%E4%BA%AB%E9%94%81" >互斥锁 &amp; 共享锁<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%AD%BB%E9%94%81" >死锁<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86" >计算机原理<i class="fas fa-external-link-alt"></i></a></li><li>CPU<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98" >多级缓存<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%BF%9B%E7%A8%8B" >进程<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%BA%BF%E7%A8%8B" >线程<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%8D%8F%E7%A8%8B" >协程<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#linux" >Linux<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99" >设计模式的六大原则<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#_23%E7%A7%8D%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" >23种常见设计模式<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" >应用场景<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" >单例模式<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F" >责任链模式<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#mvc" >MVC<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#ioc" >IOC<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#aop" >AOP<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#uml" >UML<i class="fas fa-external-link-alt"></i></a></li><li>微服务思想<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B" >康威定律<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%B8%B8%E8%A7%84%E7%9B%91%E6%8E%A7" >常规监控<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#apm" >APM<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90" >统计分析<i class="fas fa-external-link-alt"></i></a></li><li>持续集成(CI&#x2F;CD)<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#jenkins" >Jenkins<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%8E%AF%E5%A2%83%E5%88%86%E7%A6%BB" >环境分离<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>自动化运维<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#ansible" >Ansible<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#puppet" >puppet<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#chef" >chef<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>测试<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#tdd-%E7%90%86%E8%AE%BA" >TDD 理论<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" >单元测试<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95" >压力测试<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B" >全链路压测<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#a-b-%E3%80%81%E7%81%B0%E5%BA%A6%E3%80%81%E8%93%9D%E7%BB%BF%E6%B5%8B%E8%AF%95" >A&#x2F;B 、灰度、蓝绿测试<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>虚拟化<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#kvm" >KVM<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#xen" >Xen<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#openvz" >OpenVZ<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>容器技术<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#docker" >Docker<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>云技术<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#openstack" >OpenStack<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#devops" >DevOps<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86" >文档管理<i class="fas fa-external-link-alt"></i></a></li><li>Web Server<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#nginx" >Nginx<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#openresty" >OpenResty<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#tengine" >Tengine<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#apache-httpd" >Apache Httpd<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#tomcat" >Tomcat<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#jetty" >Jetty<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>缓存<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98" >本地缓存<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98" >客户端缓存<i class="fas fa-external-link-alt"></i></a></li><li>服务端缓存<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#web%E7%BC%93%E5%AD%98" >Web缓存<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#memcached" >Memcached<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#redis" >Redis<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#tair" >Tair<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>消息队列<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF" >消息总线<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F" >消息的顺序<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#rabbitmq" >RabbitMQ<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#rocketmq" >RocketMQ<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#activemq" >ActiveMQ<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#kafka" >Kafka<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#redis-%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81" >Redis 消息推送<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#zeromq" >ZeroMQ<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>定时调度<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6" >单机定时调度<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6" >分布式定时调度<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>RPC<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#dubbo" >Dubbo<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#thrift" >Thrift<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#grpc" >gRPC<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>数据库中间件<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#sharding-jdbc" >Sharding Jdbc<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>日志系统<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%97%A5%E5%BF%97%E6%90%9C%E9%9B%86" >日志搜集<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83" >配置中心<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#api-%E7%BD%91%E5%85%B3" >API 网关<i class="fas fa-external-link-alt"></i></a></li><li>协议<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#osi-%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE" >OSI 七层协议<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#tcp-ip" >TCP&#x2F;IP<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#http" >HTTP<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#http2-0" >HTTP2.0<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#https" >HTTPS<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>网络模型<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#epoll" >Epoll<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#java-nio" >Java NIO<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#kqueue" >kqueue<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5" >连接和短连接<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%A1%86%E6%9E%B6" >框架<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%88zero-copy%EF%BC%89" >零拷贝（Zero-copy）<i class="fas fa-external-link-alt"></i></a></li><li>序列化(二进制协议)<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#hessian" >Hessian<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#protobuf" >Protobuf<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>基础理论<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F" >关系数据库设计的三大范式<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>MySQL<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%8E%9F%E7%90%86" >原理<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#innodb" >InnoDB<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%BC%98%E5%8C%96" >优化<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%B4%A2%E5%BC%95" >索引<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#explain" >explain<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>NoSQL<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#mongodb" >MongoDB<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#hbase" >Hbase<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86" >搜索引擎原理<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#lucene" >Lucene<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#elasticsearch" >Elasticsearch<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#solr" >Solr<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#sphinx" >sphinx<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%AE%BA" >性能优化方法论<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%AE%B9%E9%87%8F%E8%AF%84%E4%BC%B0" >容量评估<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#cdn-%E7%BD%91%E7%BB%9C" >CDN 网络<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%BF%9E%E6%8E%A5%E6%B1%A0" >连接池<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98" >性能调优<i class="fas fa-external-link-alt"></i></a></li><li>流式计算<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#storm" >Storm<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#flink" >Flink<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#kafka-stream" >Kafka Stream<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" >应用场景<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>Hadoop<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#hdfs" >HDFS<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#mapreduce" >MapReduce<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#yarn" >Yarn<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#spark" >Spark<i class="fas fa-external-link-alt"></i></a></li><li>web 安全<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#xss" >XSS<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#csrf" >CSRF<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#sql-%E6%B3%A8%E5%85%A5" >SQL 注入<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#hash-dos" >Hash Dos<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%84%9A%E6%9C%AC%E6%B3%A8%E5%85%A5" >脚本注入<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7" >漏洞扫描工具<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E9%AA%8C%E8%AF%81%E7%A0%81" >验证码<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#ddos-%E9%98%B2%E8%8C%83" >DDoS 防范<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%94%A8%E6%88%B7%E9%9A%90%E7%A7%81%E4%BF%A1%E6%81%AF%E4%BF%9D%E6%8A%A4" >用户隐私信息保护<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E" >序列化漏洞<i class="fas fa-external-link-alt"></i></a></li><li>加密解密<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" >对称加密<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95" >哈希算法<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" >非对称加密<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8" >服务器安全<i class="fas fa-external-link-alt"></i></a></li><li>数据安全<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD" >数据备份<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>网络隔离<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%86%85%E5%A4%96%E7%BD%91%E5%88%86%E7%A6%BB" >内外网分离<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%99%BB%E5%BD%95%E8%B7%B3%E6%9D%BF%E6%9C%BA" >登录跳板机<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>授权、认证<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#rbac" >RBAC<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#oauth2-0" >OAuth2.0<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#oidc" >OIDC<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#saml" >SAML<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81%EF%BC%882fa%EF%BC%89" >双因素认证（2FA）<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-sso" >单点登录(SSO)<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE" >开源协议<i class="fas fa-external-link-alt"></i></a></li><li>日志框架<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#log4j%E3%80%81log4j2" >Log4j、Log4j2<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#logback" >Logback<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#orm" >ORM<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6" >网络框架<i class="fas fa-external-link-alt"></i></a></li><li>Web 框架<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#spring-%E5%AE%B6%E6%97%8F" >Spring 家族<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%B7%A5%E5%85%B7%E6%A1%86%E6%9E%B6" >工具框架<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%89%A9%E5%B1%95%E6%80%A7%E8%AE%BE%E8%AE%A1" >扩展性设计<i class="fas fa-external-link-alt"></i></a></li><li>稳定性 &amp; 高可用<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%A1%AC%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" >硬件负载均衡<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%BD%AF%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" >软件负载均衡<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E9%99%90%E6%B5%81" >限流<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%BA%94%E7%94%A8%E5%B1%82%E5%AE%B9%E7%81%BE" >应用层容灾<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%B7%A8%E6%9C%BA%E6%88%BF%E5%AE%B9%E7%81%BE" >跨机房容灾<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%AE%B9%E7%81%BE%E6%BC%94%E7%BB%83%E6%B5%81%E7%A8%8B" >容灾演练流程<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%B9%B3%E6%BB%91%E5%90%AF%E5%8A%A8" >平滑启动<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>数据库扩展<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F" >读写分离模式<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%88%86%E7%89%87%E6%A8%A1%E5%BC%8F" >分片模式<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>服务治理<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0" >服务注册与发现<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6" >服务路由控制<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>分布式一致<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#cap-%E4%B8%8E-base-%E7%90%86%E8%AE%BA" >CAP 与 BASE 理论<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" >分布式锁<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95" >分布式一致性算法<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%B9%82%E7%AD%89" >幂等<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%96%B9%E6%A1%88" >分布式一致方案<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%88%86%E5%B8%83%E5%BC%8F-leader-%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE" >分布式 Leader 节点选举<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#tcc-try-confirm-cancel-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1" >TCC(Try&#x2F;Confirm&#x2F;Cancel) 柔性事务<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" >分布式文件系统<i class="fas fa-external-link-alt"></i></a></li><li>唯一ID 生成<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id" >全局唯一ID<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95" >一致性Hash算法<i class="fas fa-external-link-alt"></i></a></li><li>DDD(Domain-driven Design - 领域驱动设计)<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BB-cqrs" >命令查询职责分离(CQRS)<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%B4%AB%E8%A1%80%EF%BC%8C%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B" >贫血，充血模型<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#actor-%E6%A8%A1%E5%BC%8F" >Actor 模式<i class="fas fa-external-link-alt"></i></a></li><li>响应式编程<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#reactor" >Reactor<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#rxjava" >RxJava<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#vert-x" >Vert.x<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#dodaf2-0" >DODAF2.0<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#serverless" >Serverless<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#service-mesh" >Service Mesh<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%9E%B6%E6%9E%84%E8%AF%84%E5%AE%A1" >架构评审<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E9%87%8D%E6%9E%84" >重构<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83" >代码规范<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%BB%A3%E7%A0%81-review" >代码 Review<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#rup" >RUP<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%9C%8B%E6%9D%BF%E7%AE%A1%E7%90%86" >看板管理<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#scrum" >SCRUM<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91" >敏捷开发<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B%EF%BC%88xp%EF%BC%89" >极限编程（XP）<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B" >结对编程<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#pdca-%E5%BE%AA%E7%8E%AF%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86" >PDCA 循环质量管理<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#fmea%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F" >FMEA管理模式<i class="fas fa-external-link-alt"></i></a></li><li>法律<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%B8%A5%E6%A0%BC%E9%81%B5%E5%AE%88%E5%88%91%E6%B3%95253%E6%B3%95%E6%9D%A1" >严格遵守刑法253法条<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E9%81%BF%E9%A3%8E%E6%B8%AF%E5%8E%9F%E5%88%99" >避风港原则<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%8B%9B%E8%81%98" >招聘<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%A1%8C%E4%B8%9A%E8%B5%84%E8%AE%AF" >行业资讯<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%85%AC%E4%BC%97%E5%8F%B7%E5%88%97%E8%A1%A8" >公众号列表<i class="fas fa-external-link-alt"></i></a></li><li>博客<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%9B%A2%E9%98%9F%E5%8D%9A%E5%AE%A2" >团队博客<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2" >个人博客<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%BB%BC%E5%90%88%E9%97%A8%E6%88%B7%E3%80%81%E7%A4%BE%E5%8C%BA" >综合门户、社区<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E9%97%AE%E7%AD%94%E3%80%81%E8%AE%A8%E8%AE%BA%E7%B1%BB%E7%A4%BE%E5%8C%BA" >问答、讨论类社区<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E8%A1%8C%E4%B8%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90" >行业数据分析<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%B8%93%E9%A1%B9%E7%BD%91%E7%AB%99" >专项网站<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%85%B6%E4%BB%96%E7%B1%BB" >其他类<i class="fas fa-external-link-alt"></i></a></li><li>推荐参考书<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%9C%A8%E7%BA%BF%E7%94%B5%E5%AD%90%E4%B9%A6" >在线电子书<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E7%BA%B8%E8%B4%A8%E4%B9%A6" >纸质书<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%BC%80%E6%BA%90%E8%B5%84%E6%BA%90" >开源资源<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%89%8B%E5%86%8C%E3%80%81%E6%96%87%E6%A1%A3%E3%80%81%E6%95%99%E7%A8%8B" >手册、文档、教程<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%9C%A8%E7%BA%BF%E8%AF%BE%E5%A0%82" >在线课堂<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%BC%9A%E8%AE%AE%E3%80%81%E6%B4%BB%E5%8A%A8" >会议、活动<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%B8%B8%E7%94%A8app" >常用APP<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%89%BE%E5%B7%A5%E4%BD%9C" >找工作<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E5%B7%A5%E5%85%B7" >工具<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1" >代码托管<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1" >文件服务<i class="fas fa-external-link-alt"></i></a></li><li>综合云服务商<ul><li><a class="link"   href="https://pchaoo.gitee.io/blog/views/star/awesome-architect.html#vps" >VPS<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul><li><a class="link"   href="https://www.cnblogs.com/lemon-flm/p/7877898.html" >《java队列——queue详细分析》<i class="fas fa-external-link-alt"></i></a><ul><li>非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</li><li>阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/mantu/p/5802393.html" >《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li><a class="link"   href="https://blog.csdn.net/qq_33642117/article/details/52040345" >《Java Set集合的详解》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="链表、数组"><a href="#链表、数组" class="headerlink" title="链表、数组"></a>链表、数组</h2><ul><li><a class="link"   href="https://blog.csdn.net/wz249863091/article/details/52853360" >《Java集合详解–什么是List》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="字典、关联数组"><a href="#字典、关联数组" class="headerlink" title="字典、关联数组"></a>字典、关联数组</h2><ul><li><a class="link"   href="https://baike.xsoftlab.net/view/250.html" >《Java map 详解 - 用法、遍历、排序、常用API等》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li><a class="link"   href="https://blog.csdn.net/javazejian/article/details/53362993" >《java数据结构与算法之栈（Stack）设计与实现》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.runoob.com/java/java-stack-class.html" >《Java Stack 类》<i class="fas fa-external-link-alt"></i></a></li><li>《java stack的详细实现分析》<ul><li>Stack 是线程安全的。</li><li>内部使用数组保存数据，不够时翻倍。</li></ul></li></ul><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个节点最多有两个叶子节点。</p><ul><li><a class="link"   href="https://blog.csdn.net/cai2016/article/details/52589952" >《二叉树》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><ul><li>《完全二叉树》<ul><li>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</li></ul></li></ul><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><ul><li><a class="link"   href="http://www.cnblogs.com/polly333/p/4798944.html" >《浅谈数据结构-平衡二叉树》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html" >《浅谈算法和数据结构: 八 平衡查找树之2-3树》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="二叉查找树（BST）"><a href="#二叉查找树（BST）" class="headerlink" title="二叉查找树（BST）"></a>二叉查找树（BST）</h3><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</p><ul><li><a class="link"   href="http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html" >《浅谈算法和数据结构: 七 二叉查找树》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ul><li>《最容易懂得红黑树》<ul><li>添加阶段后，左旋或者右旋从而再次达到平衡。</li></ul></li><li><a class="link"   href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html" >《浅谈算法和数据结构: 九 平衡查找树之红黑树》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="B，B-，B-树"><a href="#B，B-，B-树" class="headerlink" title="B，B+，B*树"></a>B，B+，B*树</h3><p>MySQL是基于B+树聚集索引组织表</p><ul><li><a class="link"   href="https://blog.csdn.net/aqzwss/article/details/53074186" >《B-树，B+树，B*树详解》<i class="fas fa-external-link-alt"></i></a></li><li>《B-树，B+树与B*树的优缺点比较》<ul><li>B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。</li></ul></li></ul><h3 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h3><p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。 Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</p><ul><li><a class="link"   href="https://blog.csdn.net/dbanote/article/details/8897599" >《LSM树 VS B+树》<i class="fas fa-external-link-alt"></i></a><ul><li>B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。</li><li>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/u014774781/article/details/52105708" >《LSM树（Log-Structured Merge Tree）存储引擎》<i class="fas fa-external-link-alt"></i></a><ul><li>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</li><li>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</li><li>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</li></ul></li></ul><h2 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h2><p>经常用于大规模数据的排重检查。</p><ul><li><a class="link"   href="http://www.runoob.com/java/java-bitset-class.html" >《Java Bitset类》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/caiandyong/article/details/51581160" >《Java BitSet（位集）》<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><ul><li><a class="link"   href="https://blog.csdn.net/gane_cheng/article/details/52652705" >《常见排序算法及对应的时间复杂度和空间复杂度》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="排序、查找算法"><a href="#排序、查找算法" class="headerlink" title="排序、查找算法"></a>排序、查找算法</h2><ul><li><a class="link"   href="https://blog.csdn.net/gane_cheng/article/details/52652705" >《常见排序算法及对应的时间复杂度和空间复杂度》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>《Java中的经典算法之选择排序（SelectionSort）》<ul><li>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</li></ul></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>《冒泡排序的2种写法》<ul><li>相邻元素前后交换、把最大的排到最后。</li><li>时间复杂度 O(n²)</li></ul></li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li><a class="link"   href="https://www.cnblogs.com/hapjin/p/5517667.html" >《排序算法总结之插入排序》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>《坐在马桶上看算法：快速排序》<ul><li>一侧比另外一侧都大或小。</li></ul></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li>《图解排序算法(四)之归并排序》<ul><li>分而治之，分成小份排序，在合并(重建一个新空间进行复制)。</li></ul></li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>TODO</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>《图解排序算法(三)之堆排序》<ul><li>排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。</li></ul></li></ul><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><ul><li>《计数排序和桶排序》<ul><li>和桶排序过程比较像，差别在于桶的数量。</li></ul></li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><ul><li><a class="link"   href="http://blog.51cto.com/ahalei/1362789" >《【啊哈！算法】最快最简单的排序——桶排序》<i class="fas fa-external-link-alt"></i></a></li><li>《排序算法（三）：计数排序与桶排序》<ul><li>桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。</li><li>每个桶单独进行排序，然后再遍历每个桶。</li></ul></li></ul><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>按照个位、十位、百位、…依次来排。</p><ul><li><a class="link"   href="https://blog.csdn.net/lemon_tree12138/article/details/51695211" >《排序算法系列：基数排序》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/skywang12345/p/3603669.html" >《基数排序》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li><a class="link"   href="https://www.cnblogs.com/coderising/p/5708632.html" >《二分查找(java实现)》<i class="fas fa-external-link-alt"></i></a><ul><li>要求待查找的序列有序。</li><li>时间复杂度 O(logN)。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/maoyuanming0806/article/details/78176957" >《java实现二分查找-两种方式》<i class="fas fa-external-link-alt"></i></a><ul><li>while + 递归。</li></ul></li></ul><h3 id="Java-中的排序工具"><a href="#Java-中的排序工具" class="headerlink" title="Java 中的排序工具"></a>Java 中的排序工具</h3><ul><li>《Arrays.sort和Collections.sort实现原理解析》<ul><li>Collections.sort算法调用的是合并排序。</li><li>Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。</li></ul></li></ul><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>常用于大数据的排重，比如email，url 等。 核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。 优点：空间和时间效率都很高。 缺点：随着存入的元素数量增加，误算率随之增加。</p><ul><li><a class="link"   href="https://segmentfault.com/a/1190000002729689" >《布隆过滤器 – 空间效率很高的数据结构》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/zdxiq000/article/details/57626464" >《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》<i class="fas fa-external-link-alt"></i></a></li><li>《基于Redis的布隆过滤器的实现》<ul><li>基于 Redis 的 Bitmap 数据结构。</li></ul></li><li>《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》<ul><li>使用Java中的 BitSet 类 和 加权和hash算法。</li></ul></li></ul><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><p>KMP：Knuth-Morris-Pratt算法（简称KMP） 核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</p><ul><li><a class="link"   href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" >《字符串匹配的KMP算法》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="深度优先、广度优先"><a href="#深度优先、广度优先" class="headerlink" title="深度优先、广度优先"></a>深度优先、广度优先</h2><ul><li>《广度优先搜索BFS和深度优先搜索DFS》</li></ul><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ul><li><a class="link"   href="https://www.cnblogs.com/MrSaver/p/8641971.html" >《算法：贪婪算法基础》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/a345017062/article/details/52443781" >《常见算法及问题场景——贪心算法》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><ul><li><a class="link"   href="https://blog.csdn.net/qfikh/article/details/51960331" >《 五大常用算法之四：回溯法》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="剪枝算法"><a href="#剪枝算法" class="headerlink" title="剪枝算法"></a>剪枝算法</h2><ul><li><a class="link"   href="https://blog.csdn.net/luningcsdn/article/details/50930276" >《α-β剪枝算法》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><a class="link"   href="https://www.cnblogs.com/little-YTMM/p/5372680.html" >《详解动态规划——邹博讲动态规划》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/yao_zi_jie/article/details/54580283" >《动态规划算法的个人理解》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><ul><li><a class="link"   href="https://blog.csdn.net/amds123/article/details/70173402" >《带你搞懂朴素贝叶斯分类算法》<i class="fas fa-external-link-alt"></i></a><ul><li>P(B|A)&#x3D;P(A|B)P(B)&#x2F;P(A)</li></ul></li><li><a class="link"   href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html" >《贝叶斯推断及其互联网应用1》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html" >《贝叶斯推断及其互联网应用2》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h2><ul><li>《推荐算法综述》</li><li>《TOP 10 开源的推荐系统简介》</li></ul><h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><ul><li><a class="link"   href="https://blog.csdn.net/luoshixian099/article/details/51908175" >《算法导论–最小生成树（Kruskal和Prim算法）》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><ul><li><a class="link"   href="https://blog.csdn.net/qq_35644234/article/details/60870719" >《Dijkstra算法详解》<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h2><ul><li><a class="link"   href="https://github.com/CL0610/Java-concurrency" >Java 并发知识合集<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/CL0610/Java-concurrency/blob/master/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.png" >JAVA并发知识图谱<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li><a class="link"   href="https://www.cnblogs.com/xrq730/p/5060921.html" >《40个Java多线程问题总结》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul><li><a class="link"   href="https://www.cnblogs.com/zhanht/p/5450325.html" >《Java并发编程——线程安全及解决机制简介》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="一致性、事务"><a href="#一致性、事务" class="headerlink" title="一致性、事务"></a>一致性、事务</h2><h3 id="事务-ACID-特性"><a href="#事务-ACID-特性" class="headerlink" title="事务 ACID 特性"></a>事务 ACID 特性</h3><ul><li><a class="link"   href="https://blog.csdn.net/u012440687/article/details/52116108" >《数据库事务ACID特性》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</li><li>读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</li><li>可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</li><li>序列化：所有事物串行处理（牺牲了效率）</li><li><a class="link"   href="https://blog.csdn.net/qq_33290787/article/details/51924963" >《理解事务的4种隔离级别》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/z-sm/p/7245981.html" >数据库事务的四大特性及事务隔离级别<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" >《MySQL的InnoDB的幻读问题 》<i class="fas fa-external-link-alt"></i></a><ul><li>幻读的例子非常清楚。</li><li>通过 SELECT … FOR UPDATE 解决。</li></ul></li><li><a class="link"   href="https://draveness.me/mysql-innodb" >《一篇文章带你读懂MySQL和InnoDB》<i class="fas fa-external-link-alt"></i></a><ul><li>图解脏读、不可重复读、幻读问题。</li></ul></li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><ul><li><a class="link"   href="https://www.cnblogs.com/chenpingzhao/p/5065316.html" >《【mysql】关于innodb中MVCC的一些理解》<i class="fas fa-external-link-alt"></i></a><ul><li>innodb 中 MVCC 用在 Repeatable-Read 隔离级别。</li><li>MVCC 会产生幻读问题（更新时异常。）</li></ul></li><li><a class="link"   href="https://blog.csdn.net/whoamiyang/article/details/51901888" >《轻松理解MYSQL MVCC 实现机制》<i class="fas fa-external-link-alt"></i></a><ul><li>通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间</li><li>每次只操作比当前版本小（或等于）的 行。</li></ul></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="Java中的锁和同步类"><a href="#Java中的锁和同步类" class="headerlink" title="Java中的锁和同步类"></a>Java中的锁和同步类</h3><ul><li><a class="link"   href="https://www.cnblogs.com/qifengshi/p/6831055.html" >《Java中的锁分类》<i class="fas fa-external-link-alt"></i></a><ul><li>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/waterystone/p/4920797.html" >《Java并发之AQS详解》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://cuisuqiang.iteye.com/blog/2020146" >《Java中信号量 Semaphore》<i class="fas fa-external-link-alt"></i></a><ul><li>有数量控制</li><li>申请用 acquire，申请不要则阻塞；释放用 release。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/davidwang456/p/6094947.html" >《java开发中的Mutex vs Semaphore》<i class="fas fa-external-link-alt"></i></a><ul><li>简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。</li></ul></li></ul><h3 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁 &amp; 非公平锁"></a>公平锁 &amp; 非公平锁</h3><p>公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。</p><ul><li>《公平锁与非公平锁》<ul><li>默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。</li></ul></li></ul><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。</p><ul><li><a class="link"   href="https://www.cnblogs.com/zhiqian-ali/p/6200874.html" >《【MySQL】悲观锁&amp;乐观锁》<i class="fas fa-external-link-alt"></i></a><ul><li>乐观锁的方式：版本号+重试方式</li><li>悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/Lawson/p/5008741.html" >《Mysql查询语句使用select.. for update导致的数据库死锁分析》<i class="fas fa-external-link-alt"></i></a><ul><li>mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。</li><li>锁相同数据的不同索引条件可能会引起死锁。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/zejin2008/p/5262751.html" >《Mysql并发时经典常见的死锁原因及解决方法》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="乐观锁-amp-CAS"><a href="#乐观锁-amp-CAS" class="headerlink" title="乐观锁 &amp; CAS"></a>乐观锁 &amp; CAS</h3><ul><li>《乐观锁的一种实现方式——CAS》<ul><li>和MySQL乐观锁方式相似，只不过是通过和原值进行比较。</li></ul></li></ul><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。</p><ul><li><a class="link"   href="https://www.cnblogs.com/549294286/p/3766717.html" >《Java CAS 和ABA问题》<i class="fas fa-external-link-alt"></i></a></li><li>《Java 中 ABA问题及避免》<ul><li>AtomicStampedReference 和 AtomicStampedReference。</li></ul></li></ul><h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h3><p>可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p><ul><li><a class="link"   href="https://www.cnblogs.com/hapjin/p/4840107.html" >《JAVA中写时复制(Copy-On-Write)Map实现》<i class="fas fa-external-link-alt"></i></a><ul><li>实现读写分离，读取发生在原始数据上，写入发生在副本上。</li><li>不用加锁，通过最终一致实现一致性。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/a494303877/article/details/53404623" >《聊聊并发-Java中的Copy-On-Write容器》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h3><ul><li><a class="link"   href="http://www.cnblogs.com/l00l/p/4115001.html" >《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="可重入锁-amp-不可重入锁"><a href="#可重入锁-amp-不可重入锁" class="headerlink" title="可重入锁 &amp; 不可重入锁"></a>可重入锁 &amp; 不可重入锁</h3><ul><li><a class="link"   href="https://www.cnblogs.com/dj3839/p/6580765.html" >《可重入锁和不可重入锁》<i class="fas fa-external-link-alt"></i></a><ul><li>通过简单代码举例说明可重入锁和不可重入锁。</li><li>可重入锁指同一个线程可以再次获得之前已经获得的锁。</li><li>可重入锁可以用户避免死锁。</li><li>Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/baizhanshi/p/7211802.html" >《ReenTrantLock可重入锁（和synchronized的区别）总结》<i class="fas fa-external-link-alt"></i></a><ul><li>synchronized 使用方便，编译器来加锁，是非公平锁。</li><li>ReenTrantLock 使用灵活，锁的公平性可以定制。</li><li>相同加锁场景下，推荐使用 synchronized。</li></ul></li></ul><h3 id="互斥锁-amp-共享锁"><a href="#互斥锁-amp-共享锁" class="headerlink" title="互斥锁 &amp; 共享锁"></a>互斥锁 &amp; 共享锁</h3><p>互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。 共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。</p><ul><li><a class="link"   href="https://www.cnblogs.com/liang1101/p/6475555.html" >《ReadWriteLock场景应用》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><a class="link"   href="https://blog.csdn.net/yunfenglw/article/details/45950305" >《“死锁”四个必要条件的合理解释》<i class="fas fa-external-link-alt"></i></a><ul><li>互斥、持有、不可剥夺、环形等待。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/u014039577/article/details/52351626" >Java如何查看死锁？<i class="fas fa-external-link-alt"></i></a><ul><li>JConsole 可以识别死锁。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/bohu83/article/details/51135061" >java多线程系列：死锁及检测<i class="fas fa-external-link-alt"></i></a><ul><li>jstack 可以显示死锁。</li></ul></li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><ul><li><a class="link"   href="https://segmentfault.com/a/1190000003692840" >《操作系统基础知识——操作系统的原理，类型和结构》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。</p><ul><li><a class="link"   href="https://blog.csdn.net/zero__007/article/details/54089730" >《从Java视角理解CPU缓存和伪共享》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>TODO</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li><a class="link"   href="https://blog.csdn.net/asdf_1024/article/details/78978437" >《线程的生命周期及状态转换详解》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul><li>《终结python协程—-从yield到actor模型的实现》<ul><li>线程的调度是由操作系统负责，协程调度是程序自行负责</li><li>与线程相比，协程减少了无谓的操作系统切换.</li><li>实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.</li></ul></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li><a class="link"   href="http://www.runoob.com/linux/linux-command-manual.html" >《Linux 命令大全》<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><ul><li>《设计模式的六大原则》<ul><li>开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li><li>里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li><li>依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li><li>接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li><li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li><li>合成复用原则：尽量使用合成&#x2F;聚合,而不是使用继承。</li></ul></li></ul><h2 id="23种常见设计模式"><a href="#23种常见设计模式" class="headerlink" title="23种常见设计模式"></a>23种常见设计模式</h2><ul><li><a class="link"   href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" >《设计模式》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/susanws/p/5510229.html" >《23种设计模式全解析》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/ToryZhou/design-pattern" >《设计模式类图与示例》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><a class="link"   href="http://blog.jobbole.com/62314/" >《细数JDK里的设计模式》<i class="fas fa-external-link-alt"></i></a><ul><li>结构型模式：<ul><li>适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。</li><li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li><li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。</li><li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li><li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li><li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy</li></ul></li><li>创建模式:<ul><li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。</li><li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li><li>工厂方法：就是 <strong>一个返回</strong>具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li><li>原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。</li><li>单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。</li></ul></li><li>行为模式：<ul><li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。</li><li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。</li><li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。</li><li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。</li><li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。</li><li>空对象模式：如 java.util.Collections#emptyList()。</li><li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。</li><li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。</li></ul></li></ul></li><li><a class="link"   href="https://www.cnblogs.com/hwaggLee/p/4510687.html" >《Spring-涉及到的设计模式汇总》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/u012387062/article/details/54719114" >《Mybatis使用的设计模式》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li><a class="link"   href="https://blog.csdn.net/YECrazy/article/details/79481964" >《单例模式的三种实现 以及各自的优缺点》<i class="fas fa-external-link-alt"></i></a></li><li>《单例模式－－反射－－防止序列化破坏单例模式》<ul><li>使用枚举类型。</li></ul></li></ul><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>TODO</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><ul><li>《MVC 模式》<ul><li>模型(model)－视图(view)－控制器(controller)</li></ul></li></ul><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><ul><li><a class="link"   href="https://www.zhihu.com/question/23277575" >《理解 IOC》<i class="fas fa-external-link-alt"></i></a></li><li>《IOC 的理解与解释》<ul><li>正向控制：传统通过new的方式。反向控制，通过容器注入对象。</li><li>作用：用于模块解耦。</li><li>DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。</li></ul></li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ul><li><a class="link"   href="https://blog.csdn.net/yanquan345/article/details/19760027" >《轻松理解AOP(面向切面编程)》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/hongwz/p/5764917.html" >《Spring AOP详解》<i class="fas fa-external-link-alt"></i></a></li><li>《Spring AOP的实现原理》<ul><li>Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。</li></ul></li><li>《Spring AOP 实现原理与 CGLIB 应用》<ul><li>Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类</li></ul></li></ul><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><ul><li><a class="link"   href="https://www.w3cschool.cn/uml_tutorial/" >《UML教程》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="微服务思想"><a href="#微服务思想" class="headerlink" title="微服务思想"></a>微服务思想</h2><ul><li>《微服务架构设计》</li><li>《微服务架构技术栈选型手册》</li></ul><h3 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h3><ul><li><a class="link"   href="https://yq.aliyun.com/articles/8611" >《微服务架构的理论基础 - 康威定律》<i class="fas fa-external-link-alt"></i></a><ul><li>定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。</li><li>定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。</li><li>定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。</li><li>定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。</li></ul></li><li><a class="link"   href="https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf" >《微服务架构核⼼20讲》<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="运维-amp-统计-amp-技术支持"><a href="#运维-amp-统计-amp-技术支持" class="headerlink" title="运维 &amp; 统计 &amp; 技术支持"></a>运维 &amp; 统计 &amp; 技术支持</h1><h2 id="常规监控"><a href="#常规监控" class="headerlink" title="常规监控"></a>常规监控</h2><ul><li><a class="link"   href="https://blog.csdn.net/enweitech/article/details/77849205" >《腾讯业务系统监控的修炼之路》<i class="fas fa-external-link-alt"></i></a><ul><li>监控的方式：主动、被动、旁路(比如舆情监控)</li><li>监控类型： 基础监控、服务端监控、客户端监控、 监控、用户端监控</li><li>监控的目标：全、块、准</li><li>核心指标：请求量、成功率、耗时</li></ul></li><li><a class="link"   href="https://www.oschina.net/news/67525/monitoring-tools" >《开源还是商用？十大云运维监控工具横评》<i class="fas fa-external-link-alt"></i></a><ul><li>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</li></ul></li><li><a class="link"   href="http://developer.51cto.com/art/201612/525373.htm" >《监控报警系统搭建及二次开发经验》<i class="fas fa-external-link-alt"></i></a></li></ul><p><strong>命令行监控工具</strong></p><ul><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html" >《常用命令行监控工具》<i class="fas fa-external-link-alt"></i></a><ul><li>top、sar、tsar、nload</li></ul></li><li><a class="link"   href="http://blog.jobbole.com/96846/" >《20个命令行工具监控 Linux 系统性能》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://my.oschina.net/feichexia/blog/196575" >《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h2><p>APM — Application Performance Management</p><ul><li><a class="link"   href="http://bigbully.github.io/Dapper-translation/" >《Dapper，大规模分布式系统的跟踪系统》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://opentracing.io/" >CNCF OpenTracing<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://github.com/opentracing-contrib/opentracing-specification-zh" >中文版<i class="fas fa-external-link-alt"></i></a></li><li>主要开源软件，按字母排序<ul><li><a class="link"   href="https://github.com/apache/incubator-skywalking" >Apache SkyWalking<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/dianping/cat" >CAT<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/jaegertracing/jaeger" >CNCF jaeger<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/naver/pinpoint" >Pinpoint<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/openzipkin/zipkin" >Zipkin<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><a class="link"   href="http://www.infoq.com/cn/articles/apm-Pinpoint-practice" >《开源APM技术选型与实战》<i class="fas fa-external-link-alt"></i></a><ul><li>主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。</li></ul></li></ul><h2 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h2><ul><li><a class="link"   href="https://zhuanlan.zhihu.com/p/25195217" >《流量统计的基础：埋点》<i class="fas fa-external-link-alt"></i></a><ul><li>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</li></ul></li><li><a class="link"   href="http://www.25xt.com/company/17066.html" >《APP埋点常用的统计工具、埋点目标和埋点内容》<i class="fas fa-external-link-alt"></i></a><ul><li>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</li></ul></li><li><a class="link"   href="https://tech.meituan.com/mt_mobile_analytics_practice.html" >《美团点评前端无痕埋点实践》<i class="fas fa-external-link-alt"></i></a><ul><li>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。</li></ul></li></ul><h2 id="持续集成-CI-x2F-CD"><a href="#持续集成-CI-x2F-CD" class="headerlink" title="持续集成(CI&#x2F;CD)"></a>持续集成(CI&#x2F;CD)</h2><ul><li><a class="link"   href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" >《持续集成是什么？》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.testwo.com/article/1170" >《8个流行的持续集成工具》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><ul><li><a class="link"   href="https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000" >《使用Jenkins进行持续集成》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="环境分离"><a href="#环境分离" class="headerlink" title="环境分离"></a>环境分离</h3><p>开发、测试、生成环境分离。</p><ul><li><a class="link"   href="https://my.oschina.net/sancuo/blog/214904" >《开发环境、生产环境、测试环境的基本理解和区》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="自动化运维"><a href="#自动化运维" class="headerlink" title="自动化运维"></a>自动化运维</h2><h3 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h3><ul><li><a class="link"   href="http://www.ansible.com.cn/" >《Ansible中文权威指南》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/heiye123/articles/7855890.html" >《Ansible基础配置和企业级项目实用案例》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="puppet"><a href="#puppet" class="headerlink" title="puppet"></a>puppet</h3><ul><li><a class="link"   href="https://www.cnblogs.com/keerya/p/8040071.html" >《自动化运维工具——puppet详解》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="chef"><a href="#chef" class="headerlink" title="chef"></a>chef</h3><ul><li><a class="link"   href="https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/" >《Chef 的安装与使用》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="TDD-理论"><a href="#TDD-理论" class="headerlink" title="TDD 理论"></a>TDD 理论</h3><ul><li>《深度解读 - TDD（测试驱动开发）》<ul><li>基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li><li>好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈；</li></ul></li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li><a class="link"   href="https://www.cnblogs.com/happyzm/p/6482886.html" >《Java单元测试之JUnit篇》<i class="fas fa-external-link-alt"></i></a></li><li>《JUnit 4 与 TestNG 对比》<ul><li>TestNG 覆盖 JUnit 功能，适用于更复杂的场景。</li></ul></li><li>《单元测试主要的测试功能点》<ul><li>模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。</li></ul></li></ul><h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><ul><li><a class="link"   href="https://blog.csdn.net/blueheart20/article/details/52170790" >《Apache ab 测试使用指南》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/binyue/p/6141088.html" >《大型网站压力测试及优化方案》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://news.chinabyte.com/466/14126966.shtml" >《10大主流压力&#x2F;负载&#x2F;性能测试工具推荐》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://quentinxxz.iteye.com/blog/2249799" >《真实流量压测工具 tcpcopy应用浅析》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/jwentest/p/7136727.html" >《nGrinder 简易使用教程》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="全链路压测"><a href="#全链路压测" class="headerlink" title="全链路压测"></a>全链路压测</h3><ul><li><a class="link"   href="http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot" >《京东618：升级全链路压测方案，打造军演机器人ForceBot》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zhuanlan.zhihu.com/p/30306892" >《饿了么全链路压测的探索与实践》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zhuanlan.zhihu.com/p/28355759" >《四大语言，八大框架｜滴滴全链路压测解决之道》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.jianshu.com/p/27060fd61f72" >《全链路压测经验》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="A-x2F-B-、灰度、蓝绿测试"><a href="#A-x2F-B-、灰度、蓝绿测试" class="headerlink" title="A&#x2F;B 、灰度、蓝绿测试"></a>A&#x2F;B 、灰度、蓝绿测试</h3><ul><li><a class="link"   href="https://testerhome.com/topics/11165" >《技术干货 | AB 测试和灰度发布探索及实践》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://blog.51cto.com/purplegrape/1403123" >《nginx 根据IP 进行灰度发布》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.v2ex.com/t/344341" >《蓝绿部署、A&#x2F;B 测试以及灰度发布》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><ul><li><a class="link"   href="https://blog.csdn.net/enweitech/article/details/52910082" >《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><ul><li><a class="link"   href="http://blog.chinaunix.net/uid-20201831-id-5775661.html" >《KVM详解，太详细太深入了，经典》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.coderxing.com/kvm-install.html" >《【图文】KVM 虚拟机安装详解》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a>Xen</h3><ul><li><a class="link"   href="https://www.cnblogs.com/sddai/p/5931201.html" >《Xen虚拟化基本原理详解》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="OpenVZ"><a href="#OpenVZ" class="headerlink" title="OpenVZ"></a>OpenVZ</h3><ul><li><a class="link"   href="https://blog.csdn.net/longerzone/article/details/44829255" >《开源Linux容器 OpenVZ 快速上手指南》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li><a class="link"   href="https://www.cnblogs.com/SzeCheng/p/6822905.html" >《几张图帮你理解 docker 基本原理及快速入门》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://draveness.me/docker" >《Docker 核心技术与实现原理》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.runoob.com/docker/docker-tutorial.html" >《Docker 教程》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="云技术"><a href="#云技术" class="headerlink" title="云技术"></a>云技术</h2><h3 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h3><ul><li><a class="link"   href="https://www.cnblogs.com/klb561/p/8660264.html" >《OpenStack构架知识梳理》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><ul><li><a class="link"   href="https://www.cnblogs.com/jetzhang/p/6068773.html" >《一分钟告诉你究竟DevOps是什么鬼？》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.infoq.com/cn/articles/detail-analysis-of-devops" >《DevOps详解》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h2><ul><li><a class="link"   href="http://www.confluence.cn/" >Confluence-收费文档管理系统<i class="fas fa-external-link-alt"></i></a></li><li>GitLab?</li><li>Wiki</li></ul><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul><li><a class="link"   href="https://blog.csdn.net/qq_25797077/article/details/52200722" >《Ngnix的基本学习-多进程和Apache的比较》<i class="fas fa-external-link-alt"></i></a><ul><li>Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。</li><li>事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/cunkouzh/p/5410154.html" >《nginx与Apache的对比以及优缺点》<i class="fas fa-external-link-alt"></i></a><ul><li>nginx只适合静态和反向代理，不适合处理动态请求。</li></ul></li></ul><h3 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h3><ul><li><a class="link"   href="http://openresty.org/cn/" >官方网站<i class="fas fa-external-link-alt"></i></a></li><li>《浅谈 OpenResty》<ul><li>通过 Lua 模块可以在Nginx上进行开发。</li></ul></li><li><a class="link"   href="https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html" >agentzh 的 Nginx 教程<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Tengine"><a href="#Tengine" class="headerlink" title="Tengine"></a>Tengine</h3><ul><li><a class="link"   href="http://tengine.taobao.org/" >官方网站<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Apache-Httpd"><a href="#Apache-Httpd" class="headerlink" title="Apache Httpd"></a>Apache Httpd</h3><ul><li><a class="link"   href="http://httpd.apache.org/" >官方网站<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><h4 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h4><ul><li><a class="link"   href="https://www.cnblogs.com/hggen/p/6264475.html" >《TOMCAT原理详解及请求过程》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/crazylqy/p/4706223.html" >《Tomcat服务器原理详解》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/" >《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/xlgen157387/article/details/79006434" >《四张图带你了解Tomcat系统架构》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/" >《JBoss vs. Tomcat: Choosing A Java Application Server》<i class="fas fa-external-link-alt"></i></a><ul><li>Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。</li><li>Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li></ul></li></ul><h4 id="调优方案"><a href="#调优方案" class="headerlink" title="调优方案"></a>调优方案</h4><ul><li>《Tomcat 调优方案》<ul><li>启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）；</li></ul></li><li>《tomcat http协议与ajp协议》</li><li>《AJP与HTTP比较和分析》<ul><li>AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li><li>并发高时，AJP协议优于HTTP协议。</li></ul></li></ul><h3 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h3><ul><li><a class="link"   href="https://www.ibm.com/developerworks/cn/java/j-lo-jetty/" >《Jetty 的工作原理以及与 Tomcat 的比较》<i class="fas fa-external-link-alt"></i></a></li><li>《jetty和tomcat优势比较》<ul><li>架构比较:Jetty的架构比Tomcat的更为简单。</li><li>性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I&#x2F;O请求上更占优势，Tomcat默认采用BIO处理I&#x2F;O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。</li><li>其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。</li></ul></li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li><a class="link"   href="https://blog.csdn.net/clementad/article/details/48229243" >《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><ul><li>《HashMap本地缓存》</li><li>《EhCache本地缓存》<ul><li>堆内、堆外、磁盘三级缓存。</li><li>可按照缓存空间容量进行设置。</li><li>按照时间、次数等过期策略。</li></ul></li><li>《Guava Cache》<ul><li>简单轻量、无堆外、磁盘缓存。</li></ul></li><li>《Nginx本地缓存》</li><li>《Pagespeed—懒人工具，服务器端加速》</li></ul><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><ul><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html" >《浏览器端缓存》<i class="fas fa-external-link-alt"></i></a><ul><li>主要是利用 Cache-Control 参数。</li></ul></li><li><a class="link"   href="https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w" >《H5 和移动端 WebView 缓存机制解析与实战》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h2><h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><ul><li><a class="link"   href="https://github.com/jiangwenyuan/nuster" >nuster<i class="fas fa-external-link-alt"></i></a> - nuster cache</li><li><a class="link"   href="https://github.com/varnishcache/varnish-cache" >varnish<i class="fas fa-external-link-alt"></i></a> - varnish cache</li><li><a class="link"   href="https://github.com/squid-cache/squid" >squid<i class="fas fa-external-link-alt"></i></a> - squid cache</li></ul><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><ul><li><a class="link"   href="http://www.runoob.com/Memcached/Memcached-tutorial.html" >《Memcached 教程》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/chenleixing/article/details/47035453" >《深入理解Memcached原理》<i class="fas fa-external-link-alt"></i></a><ul><li>采用多路复用技术提高并发性。</li><li>slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。</li></ul></li><li><a class="link"   href="https://www.jianshu.com/p/36e5cd400580" >《Memcached软件工作原理》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://zhihuzeye.com/archives/2361" >《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/liu251890347/article/details/37690045" >《memcache 中 add 、 set 、replace 的区别》<i class="fas fa-external-link-alt"></i></a><ul><li>区别在于当key存在还是不存在时，返回值是true和false的。</li></ul></li><li>[**《memcached全面剖析》**](<a class="link"   href="https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth" >https://pan.baidu.com/s/1qX00Lti?errno=0&amp;errmsg=Auth<i class="fas fa-external-link-alt"></i></a> Login Sucess&amp;&amp;bduss&#x3D;&amp;ssnerror&#x3D;0&amp;traceid&#x3D;)</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li><a class="link"   href="http://www.runoob.com/redis/redis-tutorial.html" >《Redis 教程》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/wcf373722432/article/details/78678504" >《redis底层原理》<i class="fas fa-external-link-alt"></i></a><ul><li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li><li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li></ul></li><li><a class="link"   href="http://doc.redisfans.com/topic/persistence.html" >《Redis持久化方式》<i class="fas fa-external-link-alt"></i></a><ul><li>RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。</li><li>AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。</li><li>也可以两者结合使用。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/chunlongyu/article/details/53346436" >《分布式缓存–序列3–原子操作与CAS乐观锁》<i class="fas fa-external-link-alt"></i></a></li></ul><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><ul><li><a class="link"   href="https://blog.csdn.net/sunhuiliang85/article/details/73656830" >《Redis单线程架构》<i class="fas fa-external-link-alt"></i></a></li></ul><h4 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h4><ul><li><a class="link"   href="https://blog.csdn.net/qq_29108585/article/details/63251491" >《redis的回收策略》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Tair"><a href="#Tair" class="headerlink" title="Tair"></a>Tair</h3><ul><li><a class="link"   href="https://github.com/alibaba/tair" >官方网站<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://blog.csdn.net/farphone/article/details/53522383" >《Tair和Redis的对比》<i class="fas fa-external-link-alt"></i></a></li><li>特点：可以配置备份节点数目，通过异步同步到备份节点</li><li>一致性Hash算法。</li><li>架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。</li></ul><p>几种存储引擎:</p><ul><li>MDB，完全内存性，可以用来存储Session等数据。</li><li>Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作</li><li>LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。</li><li>Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。</li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li><a class="link"   href="https://www.cnblogs.com/charlesblc/p/6045238.html" >《消息队列-推&#x2F;拉模式学习 &amp; ActiveMQ及JMS学习》<i class="fas fa-external-link-alt"></i></a><ul><li>RabbitMQ 消费者默认是推模式（也支持拉模式）。</li><li>Kafka 默认是拉模式。</li><li>Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。</li><li>Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/yunfeng482/article/details/72856762" >《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h3><p>消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。</p><ul><li><a class="link"   href="https://blog.csdn.net/yanghua_kobe/article/details/43877281" >《消息总线VS消息队列》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="消息的顺序"><a href="#消息的顺序" class="headerlink" title="消息的顺序"></a>消息的顺序</h3><ul><li>《如何保证消费者接收消息的顺序》</li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。</p><ul><li><a class="link"   href="https://blog.csdn.net/whoamiyang/article/details/54954780" >《RabbitMQ的应用场景以及基本原理介绍》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.jianshu.com/p/79ca08116d57" >《消息队列之 RabbitMQ》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/u013256816/article/details/55515234" >《RabbitMQ之消息确认机制（事务+Confirm）》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。</p><ul><li><a class="link"   href="https://www.jianshu.com/p/824066d70da8" >《RocketMQ 实战之快速入门》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome" >《RocketMQ 源码解析》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>纯Java实现，兼容JMS，可以内嵌于Java应用中。</p><ul><li><a class="link"   href="https://www.cnblogs.com/wintersun/p/3962302.html" >《ActiveMQ消息队列介绍》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>高吞吐量、采用拉模式。适合高IO场景，比如日志同步。</p><ul><li><a class="link"   href="http://kafka.apache.org/" >官方网站<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/allthesametome/article/details/47362451" >《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://lxw1234.com/archives/2015/10/538.htm" >《Kafka分区机制介绍与示例》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Redis-消息推送"><a href="#Redis-消息推送" class="headerlink" title="Redis 消息推送"></a>Redis 消息推送</h3><p>生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。</p><ul><li><a class="link"   href="https://blog.csdn.net/qq_34212276/article/details/78455004" >《Redis学习笔记之十：Redis用作消息队列》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h3><p>TODO</p><h2 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h2><h3 id="单机定时调度"><a href="#单机定时调度" class="headerlink" title="单机定时调度"></a>单机定时调度</h3><ul><li><a class="link"   href="https://www.cnblogs.com/shuaiqing/p/7742382.html" >《linux定时任务cron配置》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://my.oschina.net/daquan/blog/483305" >《Linux cron运行原理》<i class="fas fa-external-link-alt"></i></a><ul><li>fork 进程 + sleep 轮询</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/drift-ice/p/3817269.html" >《Quartz使用总结》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/wenniuwuren/article/details/42082981/" >《Quartz源码解析 —- 触发器按时启动原理》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.jianshu.com/p/bab8e4e32952" >《quartz原理揭秘和源码解读》<i class="fas fa-external-link-alt"></i></a><ul><li>定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。</li></ul></li></ul><h3 id="分布式定时调度"><a href="#分布式定时调度" class="headerlink" title="分布式定时调度"></a>分布式定时调度</h3><ul><li><a class="link"   href="https://blog.csdn.net/qq_16216221/article/details/70314337" >《这些优秀的国产分布式任务调度系统，你用过几个？》<i class="fas fa-external-link-alt"></i></a><ul><li>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html" >《Quartz任务调度的基本实现原理》<i class="fas fa-external-link-alt"></i></a><ul><li>Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的</li></ul></li><li><a class="link"   href="http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome" >《Elastic-Job-Lite 源码解析》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome" >《Elastic-Job-Cloud 源码解析》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><ul><li><a class="link"   href="https://blog.csdn.net/top_code/article/details/54615853" >《从零开始实现RPC框架 - RPC原理及实现》<i class="fas fa-external-link-alt"></i></a><ul><li>核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/testcs_dn/article/details/78050590" >《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><ul><li><a class="link"   href="http://dubbo.apache.org/" >官方网站<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/steven520213/p/7606598.html" >dubbo实现原理简单介绍<i class="fas fa-external-link-alt"></i></a></li></ul><p>** SPI ** TODO</p><h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><ul><li><a class="link"   href="http://thrift.apache.org/" >官方网站<i class="fas fa-external-link-alt"></i></a></li><li>《Thrift RPC详解》<ul><li>支持多语言，通过中间语言定义接口。</li></ul></li></ul><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>服务端可以认证加密，在外网环境下，可以保证数据安全。</p><ul><li><a class="link"   href="https://grpc.io/" >官方网站<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/LBSer/p/4853234.html" >《你应该知道的RPC原理》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h2><h3 id="Sharding-Jdbc"><a href="#Sharding-Jdbc" class="headerlink" title="Sharding Jdbc"></a>Sharding Jdbc</h3><ul><li><a class="link"   href="http://shardingjdbc.io/" >官网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.iocoder.cn/categories/Sharding-JDBC/?vip&architect-awesome" >源码解析<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><h3 id="日志搜集"><a href="#日志搜集" class="headerlink" title="日志搜集"></a>日志搜集</h3><ul><li><a class="link"   href="http://cjting.me/misc/build-log-system-with-elkb/" >《从零开始搭建一个ELKB日志收集系统》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/lzw_2006/article/details/51280058" >《用ELK搭建简单的日志收集分析系统》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/beginmind/p/6058194.html" >《日志收集系统-探究》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><ul><li><a class="link"   href="https://github.com/ctripcorp/apollo" >Apollo - 携程开源的配置中心应用<i class="fas fa-external-link-alt"></i></a><ul><li>Spring Boot 和 Spring Cloud</li><li>支持推、拉模式更新配置</li><li>支持多种语言</li></ul></li><li><a class="link"   href="https://blog.csdn.net/u011320740/article/details/78742625" >《基于zookeeper实现统一配置管理》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/shamo89/p/8016908.html" >《 Spring Cloud Config 分布式配置中心使用教程》<i class="fas fa-external-link-alt"></i></a></li></ul><p>servlet 3.0 异步特性可用于配置中心的客户端</p><ul><li><a class="link"   href="https://www.cnblogs.com/dogdogwang/p/7151866.html" >《servlet3.0 新特性——异步处理》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h2><p>主要职责：请求转发、安全认证、协议转换、容灾。</p><ul><li><a class="link"   href="http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/" >《API网关那些儿》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo" >《谈API网关的背景、架构以及落地方案》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/zhanglh046/article/details/78651993" >《使用Zuul构建API Gateway》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome" >《Spring Cloud Gateway 源码解析》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A" >《HTTP API网关选择之一Kong介绍》<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="OSI-七层协议"><a href="#OSI-七层协议" class="headerlink" title="OSI 七层协议"></a>OSI 七层协议</h3><ul><li><a class="link"   href="https://www.cnblogs.com/Robin-YB/p/6668762.html" >《OSI七层协议模型、TCP&#x2F;IP四层模型学习笔记》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h3><ul><li><a class="link"   href="https://www.cnblogs.com/onepixel/p/7092302.html" >《深入浅出 TCP&#x2F;IP 协议》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/whuslei/article/details/6667471/" >《TCP协议中的三次握手和四次挥手》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li><a class="link"   href="https://www.cnblogs.com/wangning528/p/6388464.html" >《http协议详解(超详细)》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul><li><a class="link"   href="https://blog.csdn.net/zhuyiquan/article/details/69257126" >《HTTP 2.0 原理详细分析》<i class="fas fa-external-link-alt"></i></a></li><li>《HTTP2.0的基本单位为二进制帧》<ul><li>利用二进制帧负责传输。</li><li>多路复用。</li></ul></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li><a class="link"   href="https://www.cnblogs.com/zhangshitong/p/6478721.html" >《https原理通俗了解》<i class="fas fa-external-link-alt"></i></a><ul><li>使用非对称加密协商加密算法</li><li>使用对称加密方式传输数据</li><li>使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/enweitech/article/details/53213862" >《八大免费SSL证书-给你的网站免费添加Https安全加密》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><ul><li><a class="link"   href="http://blog.51cto.com/litaotao/1289790" >《web优化必须了解的原理之I&#x2F;o的五种模型和web的三种工作模式》<i class="fas fa-external-link-alt"></i></a><ul><li>五种I&#x2F;O模型：阻塞I&#x2F;O，非阻塞I&#x2F;O，I&#x2F;O复用、事件(信号)驱动I&#x2F;O、异步I&#x2F;O，前四种I&#x2F;O属于同步操作，I&#x2F;O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。</li><li>三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。</li></ul></li><li><a class="link"   href="http://www.cnblogs.com/Anker/p/3265058.html" >《select、poll、epoll之间的区别总结》<i class="fas fa-external-link-alt"></i></a><ul><li>select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li><li>select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。</li><li>select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。</li><li>poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。</li></ul></li><li><a class="link"   href="http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/" >《select，poll，epoll比较 》<i class="fas fa-external-link-alt"></i></a><ul><li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/geason/p/5774096.html" >《深入理解Java NIO》<i class="fas fa-external-link-alt"></i></a><ul><li>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务</li></ul></li><li><a class="link"   href="https://blog.csdn.net/skiof007/article/details/52873421" >《BIO与NIO、AIO的区别》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/u013074465/article/details/46276967" >《两种高效的服务器设计模型：Reactor和Proactor模型》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h3><ul><li><a class="link"   href="https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html" >《epoll使用详解（精髓）》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><ul><li><a class="link"   href="https://www.cnblogs.com/geason/p/5774096.html" >《深入理解Java NIO》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/xidianliuy/article/details/51612676" >《Java NIO编写Socket服务器的一个例子》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h3><ul><li><a class="link"   href="http://www.cnblogs.com/luminocean/p/5631336.html" >《kqueue用法简介》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="连接和短连接"><a href="#连接和短连接" class="headerlink" title="连接和短连接"></a>连接和短连接</h2><ul><li><a class="link"   href="https://www.cnblogs.com/pangguoping/p/5571422.html" >《TCP&#x2F;IP系列——长连接与短连接的区别》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ul><li>《Netty原理剖析》<ul><li>Reactor 模式介绍。</li><li>Netty 是 Reactor 模式的一种实现。</li></ul></li></ul><h2 id="零拷贝（Zero-copy）"><a href="#零拷贝（Zero-copy）" class="headerlink" title="零拷贝（Zero-copy）"></a>零拷贝（Zero-copy）</h2><ul><li>《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》<ul><li>多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。</li></ul></li></ul><h2 id="序列化-二进制协议"><a href="#序列化-二进制协议" class="headerlink" title="序列化(二进制协议)"></a>序列化(二进制协议)</h2><h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h3><ul><li><a class="link"   href="https://www.cnblogs.com/happyday56/p/4268249.html" >《Hessian原理分析》<i class="fas fa-external-link-alt"></i></a> Binary-RPC;不仅仅是序列化</li></ul><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><ul><li><a class="link"   href="https://blog.csdn.net/antgan/article/details/52103966" >《Protobuf协议的Java应用例子》<i class="fas fa-external-link-alt"></i></a> Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写 .proto 文件。</li><li><a class="link"   href="https://worktile.com/tech/share/prototol-buffers" >《Protocol Buffers序列化协议及应用》<i class="fas fa-external-link-alt"></i></a><ul><li>关于协议的解释；缺点：可读性差;</li></ul></li><li><a class="link"   href="https://blog.csdn.net/eric520zenobia/article/details/53766571" >《简单的使用 protobuf 和 protostuff》<i class="fas fa-external-link-alt"></i></a><ul><li>protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。</li></ul></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><h3 id="关系数据库设计的三大范式"><a href="#关系数据库设计的三大范式" class="headerlink" title="关系数据库设计的三大范式"></a>关系数据库设计的三大范式</h3><ul><li>《数据库的三大范式以及五大约束》<ul><li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li><li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li><li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li></ul></li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><a class="link"   href="http://www.admin10000.com/document/5372.html" >《MySQL的InnoDB索引原理详解》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/xifeijian/article/details/20316775" >《MySQL存储引擎－－MyISAM与InnoDB区别》<i class="fas fa-external-link-alt"></i></a><ul><li>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁</li></ul></li><li><a class="link"   href="https://www.2cto.com/database/201211/172380.html" >《myisam和innodb索引实现的不同》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li><a class="link"   href="https://my.oschina.net/kailuncen/blog/1504217" >《一篇文章带你读懂Mysql和InnoDB》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><a class="link"   href="http://vdisk.weibo.com/s/muWOT" >《MySQL36条军规》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/zhouyusheng/p/8038224.html" >《MYSQL性能优化的最佳20+条经验》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/when_less_is_more/article/details/70187459" >《SQL优化之道》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/sivkun/p/7518540.html" >《mysql数据库死锁的产生原因及解决办法》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/monkey_d_feilong/article/details/52291556" >《导致索引失效的可能情况》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.jianshu.com/p/0a7e3055a01f" >《 MYSQL分页limit速度太慢优化方法》<i class="fas fa-external-link-alt"></i></a><ul><li>原则上就是缩小扫描范围。</li></ul></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="聚集索引-非聚集索引"><a href="#聚集索引-非聚集索引" class="headerlink" title="聚集索引, 非聚集索引"></a>聚集索引, 非聚集索引</h4><ul><li><a class="link"   href="https://blog.csdn.net/no_endless/article/details/77073549" >《MySQL 聚集索引&#x2F;非聚集索引简述》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/zlcxbb/p/5757245.html" >《MyISAM和InnoDB的索引实现》<i class="fas fa-external-link-alt"></i></a></li></ul><p>MyISAM 是非聚集，InnoDB 是聚集</p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><ul><li><p><a class="link"   href="https://www.cnblogs.com/summer0space/p/7247778.html" >《复合索引的优点和注意事项》<i class="fas fa-external-link-alt"></i></a></p><ul><li>文中有一处错误：</li></ul><blockquote><p>对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高; select * from table1 where col1&#x3D;A AND col2&#x3D;B AND col3&#x3D;D 如果使用 where col2&#x3D;B AND col1&#x3D;A 或者 where col2&#x3D;B 将不会使用索引</p></blockquote><ul><li>原文中提到索引是按照“col1，col2，col3”的顺序创建的，而mysql在按照最左前缀的索引匹配原则，且会自动优化 where 条件的顺序，当条件中只有 col2&#x3D;B AND col1&#x3D;A 时，会自动转化为 col1&#x3D;A AND col2&#x3D;B，所以依然会使用索引。</li></ul></li><li><p><a class="link"   href="https://www.cnblogs.com/acode/p/7489258.html" >《MySQL查询where条件的顺序对查询效率的影响》<i class="fas fa-external-link-alt"></i></a></p></li></ul><h4 id="自适应哈希索引-AHI"><a href="#自适应哈希索引-AHI" class="headerlink" title="自适应哈希索引(AHI)"></a>自适应哈希索引(AHI)</h4><ul><li><a class="link"   href="https://blog.csdn.net/Linux_ever/article/details/62043708" >《InnoDB存储引擎——自适应哈希索引》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><ul><li><a class="link"   href="https://segmentfault.com/a/1190000008131735" >《MySQL 性能优化神器 Explain 使用分析》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><ul><li><a class="link"   href="http://www.runoob.com/mongodb/mongodb-tutorial.html" >MongoDB 教程<i class="fas fa-external-link-alt"></i></a></li><li>《Mongodb相对于关系型数据库的优缺点》<ul><li>优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；</li><li>缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；</li></ul></li></ul><h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><ul><li><a class="link"   href="http://www.thebigdata.cn/HBase/35831.html" >《简明 HBase 入门教程（开篇）》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/qiaoyihang/p/6246424.html" >《深入学习HBase架构原理》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/youzhouliu/article/details/67632882" >《传统的行存储和（HBase）列存储的区别》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/lifuxiangcaohui/article/details/39891099" >《Hbase与传统数据库的区别》<i class="fas fa-external-link-alt"></i></a><ul><li>空数据不存储，节省空间，且适用于并发。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/u014091123/article/details/73163088" >《HBase Rowkey设计》<i class="fas fa-external-link-alt"></i></a><ul><li>rowkey 按照字典顺序排列，便于批量扫描。</li><li>通过散列可以避免热点。</li></ul></li></ul><h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><h2 id="搜索引擎原理"><a href="#搜索引擎原理" class="headerlink" title="搜索引擎原理"></a>搜索引擎原理</h2><ul><li><a class="link"   href="https://www.jianshu.com/p/0193dc44135b" >《倒排索引–搜索引擎入门》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h2><ul><li>《Lucene入门简介》</li></ul><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul><li><a class="link"   href="https://blog.csdn.net/laoyang360/article/details/52244917" >《Elasticsearch学习，请先看这一篇！》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/cyony/article/details/65437708" >《Elasticsearch索引原理》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><ul><li><a class="link"   href="https://blog.csdn.net/u011936655/article/details/51960005" >《 Apache Solr入门教程》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/convict_eva/article/details/53537837" >《elasticsearch与solr比较》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="sphinx"><a href="#sphinx" class="headerlink" title="sphinx"></a>sphinx</h2><ul><li><a class="link"   href="http://blog.jobbole.com/101672/" >《Sphinx 的介绍和原理探索》<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><h2 id="性能优化方法论"><a href="#性能优化方法论" class="headerlink" title="性能优化方法论"></a>性能优化方法论</h2><ul><li><a class="link"   href="https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread" >《15天的性能优化工作，5方面的调优经验》<i class="fas fa-external-link-alt"></i></a><ul><li>代码层面、业务层面、数据库层面、服务器层面、前端优化。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/tenglizhe/article/details/44563135" >《系统性能优化的几个方面》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="容量评估"><a href="#容量评估" class="headerlink" title="容量评估"></a>容量评估</h2><ul><li><a class="link"   href="https://blog.csdn.net/u012528360/article/details/70054156" >《联网性能与容量评估的方法论和典型案例》<i class="fas fa-external-link-alt"></i></a></li><li>《互联网架构，如何进行容量设计？》<ul><li>评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS</li></ul></li></ul><h2 id="CDN-网络"><a href="#CDN-网络" class="headerlink" title="CDN 网络"></a>CDN 网络</h2><ul><li><a class="link"   href="https://www.cnblogs.com/wxiaona/p/5867685.html" >《CDN加速原理》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.zhihu.com/question/20536932" >《国内有哪些比较好的 CDN？》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><ul><li><a class="link"   href="https://blog.csdn.net/fysuccess/article/details/66972554" >《主流Java数据库连接池比较与开发配置实战》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><ul><li><a class="link"   href="https://blog.csdn.net/yethyeth/article/details/73266455" >《九大Java性能调试工具，必备至少一款》<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="流式计算"><a href="#流式计算" class="headerlink" title="流式计算"></a>流式计算</h2><h3 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h3><ul><li><a class="link"   href="http://storm.apache.org/" >官方网站<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/uisoul/article/details/77989927" >《最详细的Storm入门教程》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><ul><li><a class="link"   href="https://blog.csdn.net/lisi1129/article/details/54844919" >《Flink之一 Flink基本原理介绍》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Kafka-Stream"><a href="#Kafka-Stream" class="headerlink" title="Kafka Stream"></a>Kafka Stream</h3><ul><li><a class="link"   href="https://yq.aliyun.com/articles/58382" >《Kafka Stream调研：一种轻量级流计算模式》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>例如：</p><ul><li>广告相关实时统计；</li><li>推荐系统用户画像标签实时更新；</li><li>线上服务健康状况实时监测；</li><li>实时榜单；</li><li>实时数据统计。</li></ul><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><ul><li><a class="link"   href="https://blog.csdn.net/houbin0912/article/details/72967178" >《用通俗易懂的话说下hadoop是什么,能做什么》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html" >《史上最详细的Hadoop环境搭建》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><ul><li><a class="link"   href="https://segmentfault.com/a/1190000011575458" >《【Hadoop学习】HDFS基本原理》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><ul><li><a class="link"   href="https://blog.csdn.net/oppo62258801/article/details/72884633" >《用通俗易懂的大白话讲解Map&#x2F;Reduce原理》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/foye12/article/details/78358292" >《 简单的map-reduce的java例子》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h3><ul><li><a class="link"   href="http://www.cnblogs.com/codeOfLife/p/5492740.html" >《初步掌握Yarn的架构及原理》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><ul><li><a class="link"   href="http://www.cnblogs.com/tgzhu/p/5818374.html" >《Spark(一): 基本架构及原理》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://dblab.xmu.edu.cn/blog/1709-2/" >《子雨大数据之Spark入门教程(Python版)》<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="web-安全"><a href="#web-安全" class="headerlink" title="web 安全"></a>web 安全</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><ul><li><a class="link"   href="https://blog.csdn.net/qq_21956483/article/details/54377947" >《xss攻击原理与解决方法》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><ul><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html" >《CSRF原理及防范》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><ul><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html" >《SQL注入》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="Hash-Dos"><a href="#Hash-Dos" class="headerlink" title="Hash Dos"></a>Hash Dos</h3><ul><li>《邪恶的JAVA HASH DOS攻击》<ul><li>利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。</li></ul></li><li><a class="link"   href="http://blog.it2048.cn/article_hash-collision.html" >《一种高级的DoS攻击-Hash碰撞攻击》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.iteye.com/news/23939/" >《关于Hash Collision DoS漏洞：解析与解决方案》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="脚本注入"><a href="#脚本注入" class="headerlink" title="脚本注入"></a>脚本注入</h3><ul><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html" >《上传文件漏洞原理及防范》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="漏洞扫描工具"><a href="#漏洞扫描工具" class="headerlink" title="漏洞扫描工具"></a>漏洞扫描工具</h3><ul><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html" >《DVWA》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html" >W3af<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/xygg0801/article/details/53610640" >OpenVAS详解<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><ul><li><a class="link"   href="https://blog.csdn.net/niaonao/article/details/51112686" >《验证码原理分析及实现》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://my.oschina.net/jiangbianwanghai/blog/1031031" >《详解滑动验证码的实现原理》<i class="fas fa-external-link-alt"></i></a><ul><li>滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/xcj26/p/5242758.html" >《淘宝滑动验证码研究》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="DDoS-防范"><a href="#DDoS-防范" class="headerlink" title="DDoS 防范"></a>DDoS 防范</h2><ul><li><a class="link"   href="http://netsecurity.51cto.com/art/201601/503799.htm" >《学习手册：DDoS的攻击方式及防御手段》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://netsecurity.51cto.com/art/201406/442756.htm" >《免费DDoS攻击测试工具大合集》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="用户隐私信息保护"><a href="#用户隐私信息保护" class="headerlink" title="用户隐私信息保护"></a>用户隐私信息保护</h2><ol><li>用户密码非明文保存，加动态salt。</li><li>身份证号，手机号如果要显示，用 “*” 替代部分字符。</li><li>联系方式在的显示与否由用户自己控制。</li><li>TODO</li></ol><ul><li><a class="link"   href="https://zhidao.baidu.com/question/1988017976673661587.html" >《个人隐私包括哪些》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.zhihu.com/question/20137108" >《在互联网上，隐私的范围包括哪些？》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html" >《用户密码保存》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="序列化漏洞"><a href="#序列化漏洞" class="headerlink" title="序列化漏洞"></a>序列化漏洞</h2><ul><li><a class="link"   href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/" >《Lib之过？Java反序列化漏洞通用利用分析》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul><li>《常见对称加密算法》<ul><li>DES、3DES、Blowfish、AES</li><li>DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。</li><li>DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。</li></ul></li></ul><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ul><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html" >《常用的哈希算法》<i class="fas fa-external-link-alt"></i></a><ul><li>MD5 和 SHA-1 已经不再安全，已被弃用。</li><li>目前 SHA-256 是比较安全的。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/zhangruhong168/article/details/78033202" >《基于Hash摘要签名的公网URL签名验证设计方案》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul><li><p>《常见非对称加密算法》</p><ul><li><p>RSA、DSA、ECDSA(螺旋曲线加密算法)</p></li><li><p>和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</p></li><li><p>256位的ECC秘钥的安全性等同于3072位的RSA秘钥。</p><p><a class="link"   href="http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc" >《区块链的加密技术》<i class="fas fa-external-link-alt"></i></a></p></li></ul></li></ul><h2 id="服务器安全"><a href="#服务器安全" class="headerlink" title="服务器安全"></a>服务器安全</h2><ul><li><a class="link"   href="http://www.freebuf.com/articles/system/121540.html" >《Linux强化论：15步打造一个安全的Linux服务器》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p>TODO</p><h2 id="网络隔离"><a href="#网络隔离" class="headerlink" title="网络隔离"></a>网络隔离</h2><h3 id="内外网分离"><a href="#内外网分离" class="headerlink" title="内外网分离"></a>内外网分离</h3><p>TODO</p><h3 id="登录跳板机"><a href="#登录跳板机" class="headerlink" title="登录跳板机"></a>登录跳板机</h3><p>在内外环境中通过跳板机登录到线上主机。</p><ul><li><a class="link"   href="http://blog.51cto.com/zero01/2062618" >《搭建简易堡垒机》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="授权、认证"><a href="#授权、认证" class="headerlink" title="授权、认证"></a>授权、认证</h2><ul><li><a class="link"   href="https://docs.authing.cn/authing/" >授权认证知识库<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><ul><li><a class="link"   href="https://www.cnblogs.com/zq8024/p/5003050.html" >《基于组织角色的权限设计》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/shijiaqi1066/p/3793894.html" >《权限系统与RBAC模型概述》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/he90227/article/details/38663553" >《Spring整合Shiro做权限控制模块详细案例分析》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h3><ul><li><a class="link"   href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" >《理解OAuth 2.0》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/flashsun/p/7424071.html" >《一张图搞定OAuth2.0》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="OIDC"><a href="#OIDC" class="headerlink" title="OIDC"></a>OIDC</h3><ul><li><a class="link"   href="https://docs.authing.cn/authing/advanced/oidc/li-jie-oidc-liu-cheng" >理解 OIDC<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="SAML"><a href="#SAML" class="headerlink" title="SAML"></a>SAML</h3><ul><li><a class="link"   href="https://docs.authing.cn/authing/advanced/use-saml/li-jie-saml-liu-cheng" >理解 SAML<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="双因素认证（2FA）"><a href="#双因素认证（2FA）" class="headerlink" title="双因素认证（2FA）"></a>双因素认证（2FA）</h3><p>2FA - Two-factor authentication，用于加强登录验证</p><p>常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）</p><ul><li>【《双因素认证（2FA）教程》】(<a class="link"   href="http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html" >http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html<i class="fas fa-external-link-alt"></i></a>)</li></ul><h3 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录(SSO)"></a>单点登录(SSO)</h3><ul><li><a class="link"   href="https://www.cnblogs.com/ywlaker/p/6113927.html" >《单点登录原理与简单实现》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://github.com/apereo/cas" >CAS单点登录框架<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://docs.authing.cn/authing/quickstart/implement-sso-with-authing" >使用 Authing 实现单点登录<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="常用开源框架"><a href="#常用开源框架" class="headerlink" title="常用开源框架"></a>常用开源框架</h1><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><ul><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html" >《开源协议的选择》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://choosealicense.online/" >如何选择一个开源软件协议<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><h3 id="Log4j、Log4j2"><a href="#Log4j、Log4j2" class="headerlink" title="Log4j、Log4j2"></a>Log4j、Log4j2</h3><ul><li><a class="link"   href="https://blog.csdn.net/u012422446/article/details/51199724" >《log4j 详细讲解》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/vbirdbest/article/details/71751835" >《log4j2 实际使用详解》<i class="fas fa-external-link-alt"></i></a></li><li>《Log4j1,Logback以及Log4j2性能测试对比》<ul><li>Log4J 异步日志性能优异。</li></ul></li></ul><h3 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h3><ul><li><a class="link"   href="https://blog.csdn.net/rulon147/article/details/52620541" >《最全LogBack 详解、含java案例和配置说明》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><ul><li>《ORM框架使用优缺点》<ul><li>主要目的是为了提高开发效率。</li></ul></li></ul><p><strong>MyBatis：</strong></p><ul><li><a class="link"   href="https://www.cnblogs.com/winclpt/articles/7511672.html" >《mybatis缓存机制详解》<i class="fas fa-external-link-alt"></i></a><ul><li>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效</li><li>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/baidu_32877851/article/details/53959268" >《MyBatis学习之代码生成器Generator》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h2><p>TODO</p><h2 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h2><h3 id="Spring-家族"><a href="#Spring-家族" class="headerlink" title="Spring 家族"></a>Spring 家族</h3><p><strong>Spring</strong></p><ul><li><a class="link"   href="https://www.w3cschool.cn/wkspring/" >Spring 简明教程<i class="fas fa-external-link-alt"></i></a></li></ul><p><strong>Spring Boot</strong></p><ul><li><a class="link"   href="http://projects.spring.io/spring-boot/" >官方网站<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" >《Spring Boot基础教程》<i class="fas fa-external-link-alt"></i></a></li></ul><p><strong>Spring Cloud</strong></p><ul><li><a class="link"   href="http://springboot.fun/" >Spring Boot 中文索引站<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://springcloud.cc/" >Spring Cloud 中文文档<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" >《Spring Cloud基础教程》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="工具框架"><a href="#工具框架" class="headerlink" title="工具框架"></a>工具框架</h2><ul><li><a class="link"   href="https://www.cnblogs.com/crazylqy/p/4872236.html" >《Apache Commons 工具类介绍及简单使用》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://ifeve.com/google-guava/" >《Google guava 中文教程》<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="分布式设计"><a href="#分布式设计" class="headerlink" title="分布式设计"></a>分布式设计</h1><h2 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h2><ul><li><a class="link"   href="https://blog.csdn.net/hemin1003/article/details/53633926" >《架构师不可不知的十大可扩展架构》<i class="fas fa-external-link-alt"></i></a><ul><li>总结下来，通用的套路就是分布、缓存及异步处理。</li></ul></li><li><a class="link"   href="https://yq.aliyun.com/articles/38119" >《可扩展性设计之数据切分》<i class="fas fa-external-link-alt"></i></a><ul><li>水平切分+垂直切分</li><li>利用中间件进行分片如，MySQL Proxy。</li><li>利用分片策略进行切分，如按照ID取模。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/deniro_li/article/details/78458306" >《说说如何实现可扩展性的大型网站架构》<i class="fas fa-external-link-alt"></i></a><ul><li>分布式服务+消息队列。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/chaofanwei/article/details/29191073" >《大型网站技术架构（七）–网站的可扩展性架构》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="稳定性-amp-高可用"><a href="#稳定性-amp-高可用" class="headerlink" title="稳定性 &amp; 高可用"></a>稳定性 &amp; 高可用</h2><ul><li><a class="link"   href="https://blog.csdn.net/hustspy1990/article/details/78008324" >《系统设计：关于高可用系统的一些技术方案》<i class="fas fa-external-link-alt"></i></a><ul><li>可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。</li><li>隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。</li><li>解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。</li><li>限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。</li><li>降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。</li><li>熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。</li><li>自动化测试：通过完善的测试，减少发布引起的故障。</li><li>灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。</li></ul></li><li><a class="link"   href="https://coolshell.cn/articles/17459.html" >《关于高可用的系统》<i class="fas fa-external-link-alt"></i></a><ul><li>设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。</li></ul></li></ul><h3 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h3><ul><li><a class="link"   href="https://www.cnblogs.com/wuyun-blog/p/6186198.html" >《转！！负载均衡器技术Nginx和F5的优缺点对比》<i class="fas fa-external-link-alt"></i></a><ul><li>主要是和F5对比。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/lcword/p/5773296.html" >《软&#x2F;硬件负载均衡产品 你知多少？》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h3><ul><li><a class="link"   href="https://www.cnblogs.com/tianzhiliang/articles/2317808.html" >《几种负载均衡算法》<i class="fas fa-external-link-alt"></i></a> 轮寻、权重、负载、最少连接、QoS</li><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html" >《DNS负载均衡》<i class="fas fa-external-link-alt"></i></a><ul><li>配置简单，更新速度慢。</li></ul></li><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html" >《Nginx负载均衡》<i class="fas fa-external-link-alt"></i></a><ul><li>简单轻量、学习成本低；主要适用于web应用。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/edisonchou/p/4281978.html" >《借助LVS+Keepalived实现负载均衡 》<i class="fas fa-external-link-alt"></i></a><ul><li>配置比较负载、只支持到4层，性能较高。</li></ul></li><li><a class="link"   href="http://www.ttlsa.com/linux/haproxy-study-tutorial/" >《HAProxy用法详解 全网最详细中文文档》<i class="fas fa-external-link-alt"></i></a><ul><li>支持到七层（比如HTTP）、功能比较全面，性能也不错。</li></ul></li><li><a class="link"   href="http://blog.itpub.net/25704976/viewspace-1319781/" >《Haproxy+Keepalived+MySQL实现读均衡负载》<i class="fas fa-external-link-alt"></i></a><ul><li>主要是用户读请求的负载均衡。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/lylife/p/5584019.html" >《rabbitmq+haproxy+keepalived实现高可用集群搭建》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><ul><li>《谈谈高并发系统的限流》<ul><li>计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。</li><li>漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。</li><li>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。</li><li>Nginx 限流：通过 <code>limit_req</code> 等模块限制并发连接数。</li></ul></li></ul><h3 id="应用层容灾"><a href="#应用层容灾" class="headerlink" title="应用层容灾"></a>应用层容灾</h3><ul><li><a class="link"   href="https://segmentfault.com/a/1190000005988895" >《防雪崩利器：熔断器 Hystrix 的原理与使用》<i class="fas fa-external-link-alt"></i></a><ul><li>雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。</li><li>雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。</li><li>Hystrix设计原则：<ul><li>资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。</li><li>熔断开关：服务的健康状况 &#x3D; 请求失败数 &#x2F; 请求总数，通过阈值设定和滑动窗口控制开关。</li><li>命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。</li></ul></li></ul></li><li><a class="link"   href="https://blog.csdn.net/zeb_perfect/article/details/54135506" >《缓存穿透，缓存击穿，缓存雪崩解决方案分析》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/zeb_perfect/article/details/54135506" >《缓存击穿、失效以及热点key问题》<i class="fas fa-external-link-alt"></i></a><ul><li>主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；</li><li>热点数据：热点数据单独存储；使用本地缓存；分成多个子key；</li></ul></li></ul><h3 id="跨机房容灾"><a href="#跨机房容灾" class="headerlink" title="跨机房容灾"></a>跨机房容灾</h3><ul><li><a class="link"   href="http://dc.idcquan.com/ywgl/71559.shtml" >《“异地多活”多机房部署经验谈》<i class="fas fa-external-link-alt"></i></a><ul><li>通过自研中间件进行数据同步。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/jeffreynicole/article/details/48135093" >《异地多活（异地双活）实践经验》<i class="fas fa-external-link-alt"></i></a><ul><li>注意延迟问题，多次跨机房调用会将延时放大数倍。</li><li>建房间专线很大概率会出现问题，做好运维和程序层面的容错。</li><li>不能依赖于程序端数据双写，要有自动同步方案。</li><li>数据永不在高延迟和较差网络质量下，考虑同步质量问题。</li><li>核心业务和次要业务分而治之，甚至只考虑核心业务。</li><li>异地多活监控部署、测试也要跟上。</li><li>业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。</li><li>控制跨机房消息体大小，越小越好。</li><li>考虑使用docker容器虚拟化技术，提高动态调度能力。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/yoara/article/details/38013751" >容灾技术及建设经验介绍<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="容灾演练流程"><a href="#容灾演练流程" class="headerlink" title="容灾演练流程"></a>容灾演练流程</h3><ul><li>《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》<ul><li>常见故障画像</li><li>案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。</li></ul></li></ul><h3 id="平滑启动"><a href="#平滑启动" class="headerlink" title="平滑启动"></a>平滑启动</h3><ul><li>平滑重启应用思路 1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用</li><li><a class="link"   href="https://blog.csdn.net/u011001084/article/details/73480432" >《JVM安全退出（如何优雅的关闭java服务）》<i class="fas fa-external-link-alt"></i></a> 推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。</li><li><a class="link"   href="http://ju.outofmemory.cn/entry/337235" >《常见Java应用如何优雅关闭》<i class="fas fa-external-link-alt"></i></a> Java、Spring、Dubbo 优雅关闭方式。</li></ul><h2 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h2><h3 id="读写分离模式"><a href="#读写分离模式" class="headerlink" title="读写分离模式"></a>读写分离模式</h3><ul><li>《Mysql主从方案的实现》</li><li>《搭建MySQL主从复制经典架构》</li><li>《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》</li><li>《DRBD+Heartbeat+Mysql高可用读写分离架构》<ul><li>DRDB 进行磁盘复制，避免单点问题。</li></ul></li><li>《MySQL Cluster 方式》</li></ul><h3 id="分片模式"><a href="#分片模式" class="headerlink" title="分片模式"></a>分片模式</h3><ul><li><a class="link"   href="https://www.jianshu.com/p/32b3e91aa22c" >《分库分表需要考虑的问题及方案》<i class="fas fa-external-link-alt"></i></a><ul><li>中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。</li><li>问题：事务、Join、迁移、扩容、ID、分页等。</li><li>事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。</li><li>分库策略：数值范围；取模；日期等。</li><li>分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。</li></ul></li><li><a class="link"   href="https://www.2cto.com/database/201503/380348.html" >《MySql分表和表分区详解》<i class="fas fa-external-link-alt"></i></a><ul><li>分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。</li><li>分表：物理上创建不同的表、客户端需要管理分表路由。</li></ul></li></ul><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><ul><li><a class="link"   href="https://blog.csdn.net/jiaolongdy/article/details/51188798" >《永不失联！如何实现微服务架构中的服务发现？》<i class="fas fa-external-link-alt"></i></a><ul><li>客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。</li><li>服务器端服务发现模式：客户端通过负载均衡查询服务实例。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/u010963948/article/details/71730165" >《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》<i class="fas fa-external-link-alt"></i></a><ul><li>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li><li>作者认为目前 Consul 对 Spring cloud 的支持比较好。</li></ul></li><li><a class="link"   href="http://mobile.51cto.com/news-502394.htm" >《基于Zookeeper的服务注册与发现》<i class="fas fa-external-link-alt"></i></a><ul><li>优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。</li></ul></li></ul><h3 id="服务路由控制"><a href="#服务路由控制" class="headerlink" title="服务路由控制"></a>服务路由控制</h3><ul><li>《分布式服务框架学习笔记4 服务路由》<ul><li>原则：透明化路由</li><li>负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接</li><li>本地路由优先策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。</li><li>配置方式：统一注册表；本地配置；动态下发。</li></ul></li></ul><h2 id="分布式一致"><a href="#分布式一致" class="headerlink" title="分布式一致"></a>分布式一致</h2><h3 id="CAP-与-BASE-理论"><a href="#CAP-与-BASE-理论" class="headerlink" title="CAP 与 BASE 理论"></a>CAP 与 BASE 理论</h3><ul><li>《从分布式一致性谈到CAP理论、BASE理论》<ul><li>一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)</li><li>CAP：一致性、可用性、分区容错性(网络故障引起)</li><li>BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</li><li>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</li></ul></li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul><li><a class="link"   href="http://www.hollischuang.com/archives/1716" >《分布式锁的几种实现方式》<i class="fas fa-external-link-alt"></i></a><ul><li>基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；</li><li>基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。</li><li>Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。</li></ul></li><li><a class="link"   href="https://www.tuicool.com/articles/VZJr6fY" >《基于Zookeeper的分布式锁》<i class="fas fa-external-link-alt"></i></a><ul><li>清楚的原理描述 + Java 代码示例。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/0201zcr/p/5942748.html" >《jedisLock—redis分布式锁实现》<i class="fas fa-external-link-alt"></i></a><ul><li>基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/albertfly/article/details/77412333" >《Memcached 和 Redis 分布式锁方案》<i class="fas fa-external-link-alt"></i></a><ul><li>利用 memcached 的 add（有别于set）操作，当key存在时，返回false。</li></ul></li></ul><h3 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h3><h4 id="PAXOS"><a href="#PAXOS" class="headerlink" title="PAXOS"></a>PAXOS</h4><ul><li><a class="link"   href="https://www.cnblogs.com/linbingdong/p/6253479.html" >《分布式系列文章——Paxos算法原理与推导》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/u010039929/article/details/70171672" >《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/leesf456/p/6012777.html" >《【分布式】Zookeeper与Paxos》<i class="fas fa-external-link-alt"></i></a></li></ul><h4 id="Zab"><a href="#Zab" class="headerlink" title="Zab"></a>Zab</h4><ul><li><a class="link"   href="https://www.jianshu.com/p/fb527a64deee" >《Zab：Zookeeper 中的分布式一致性协议介绍》<i class="fas fa-external-link-alt"></i></a></li></ul><h4 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h4><ul><li>《Raft 为什么是更易理解的分布式一致性算法》<ul><li>三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）</li><li>通过随机等待的方式发出投票，得票多的获胜。</li></ul></li></ul><h4 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h4><ul><li><a class="link"   href="http://blog.51cto.com/tianya23/530743" >《Gossip算法》<i class="fas fa-external-link-alt"></i></a></li></ul><h4 id="两阶段提交、多阶段提交"><a href="#两阶段提交、多阶段提交" class="headerlink" title="两阶段提交、多阶段提交"></a>两阶段提交、多阶段提交</h4><ul><li><a class="link"   href="http://blog.jobbole.com/95632/" >《关于分布式事务、两阶段提交协议、三阶提交协议》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><ul><li>《分布式系统—幂等性设计》<ul><li>幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。</li><li>常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。</li></ul></li></ul><h3 id="分布式一致方案"><a href="#分布式一致方案" class="headerlink" title="分布式一致方案"></a>分布式一致方案</h3><ul><li><a class="link"   href="http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency" >《分布式系统事务一致性解决方案》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://weibo.com/ttarticle/p/show?id=2309403965965003062676" >《保证分布式系统数据一致性的6种方案》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="分布式-Leader-节点选举"><a href="#分布式-Leader-节点选举" class="headerlink" title="分布式 Leader 节点选举"></a>分布式 Leader 节点选举</h3><ul><li><a class="link"   href="https://blog.csdn.net/johnson_moon/article/details/78809995" >《利用zookeeper实现分布式leader节点选举》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="TCC-Try-x2F-Confirm-x2F-Cancel-柔性事务"><a href="#TCC-Try-x2F-Confirm-x2F-Cancel-柔性事务" class="headerlink" title="TCC(Try&#x2F;Confirm&#x2F;Cancel) 柔性事务"></a>TCC(Try&#x2F;Confirm&#x2F;Cancel) 柔性事务</h3><ul><li>《传统事务与柔性事务》<ul><li>基于BASE理论：基本可用、柔性状态、最终一致。</li><li>解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。</li></ul></li></ul><h2 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h2><ul><li><p><a class="link"   href="https://zhuanlan.zhihu.com/p/27666295" >说说分布式文件存储系统-基本架构<i class="fas fa-external-link-alt"></i></a> ？</p></li><li><p>《各种分布式文件系统的比较》</p><p>？</p><ul><li>HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。</li><li>FastDFS：轻量级、适合小文件。</li></ul></li></ul><h2 id="唯一ID-生成"><a href="#唯一ID-生成" class="headerlink" title="唯一ID 生成"></a>唯一ID 生成</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><ul><li><a class="link"   href="https://www.cnblogs.com/baiwa/p/5318432.html" >《高并发分布式系统中生成全局唯一Id汇总》<i class="fas fa-external-link-alt"></i></a><ul><li>Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)</li><li>Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();”</li><li>UUID：缺点，无序，字符串过长，占用空间，影响检索性能。</li><li>MongoDB 方案：利用 ObjectId。缺点：不能自增。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/hdu09075340/article/details/79103851" >《TDDL 在分布式下的SEQUENCE原理》<i class="fas fa-external-link-alt"></i></a><ul><li>在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。</li><li>每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。</li><li>客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。</li></ul></li></ul><h2 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h2><ul><li><a class="link"   href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html" >《一致性哈希算法》<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="设计思想-amp-开发模式"><a href="#设计思想-amp-开发模式" class="headerlink" title="设计思想 &amp; 开发模式"></a>设计思想 &amp; 开发模式</h1><h2 id="DDD-Domain-driven-Design-领域驱动设计"><a href="#DDD-Domain-driven-Design-领域驱动设计" class="headerlink" title="DDD(Domain-driven Design - 领域驱动设计)"></a>DDD(Domain-driven Design - 领域驱动设计)</h2><ul><li><a class="link"   href="https://www.cnblogs.com/netfocus/p/5548025.html" >《浅谈我对DDD领域驱动设计的理解》<i class="fas fa-external-link-alt"></i></a><ul><li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。</li><li>过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。</li><li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/butterfly100/p/7827870.html" >《领域驱动设计的基础知识总结》<i class="fas fa-external-link-alt"></i></a><ul><li>领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。</li><li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li><li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li><li>领域通用语言：领域专家、开发设计人员都能立即的语言或工具。</li><li>经典分层架构：用户界面&#x2F;展示层、应用层、领域层、基础设施层，是四层架构模式。</li><li>使用的模式：<ul><li>关联尽量少，尽量单项，尽量降低整体复杂度。</li><li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li><li>值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。</li><li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li><li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li><li>工厂（Factory）：类似于设计模式中的工厂模式。</li><li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li></ul></li></ul></li><li><a class="link"   href="http://www.cnblogs.com/Leo_wl/p/3866629.html" >《领域驱动设计(DDD)实现之路》<i class="fas fa-external-link-alt"></i></a><ul><li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li></ul></li><li><a class="link"   href="http://www.hollischuang.com/archives/553" >《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="命令查询职责分离-CQRS"><a href="#命令查询职责分离-CQRS" class="headerlink" title="命令查询职责分离(CQRS)"></a>命令查询职责分离(CQRS)</h3><p>CQRS — Command Query Responsibility Seperation</p><ul><li><a class="link"   href="https://www.cnblogs.com/cnblogsfans/p/4551990.html" >《领域驱动设计系列 (六)：CQRS》<i class="fas fa-external-link-alt"></i></a><ul><li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li></ul></li><li><a class="link"   href="http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml" >《DDD CQRS架构和传统架构的优缺点比较》<i class="fas fa-external-link-alt"></i></a><ul><li>最终一致的设计理念；依赖于高可用消息中间件。</li></ul></li><li><a class="link"   href="http://www.cnblogs.com/netfocus/p/4055346.html" >《CQRS架构简介》<i class="fas fa-external-link-alt"></i></a><ul><li>一个实现 CQRS 的抽象案例。</li></ul></li><li><a class="link"   href="http://www.uml.org.cn/zjjs/201609221.asp" >《深度长文：我对CQRS&#x2F;EventSourcing架构的思考》<i class="fas fa-external-link-alt"></i></a><ul><li>CQRS 模式分析 + 12306 抢票案例</li></ul></li></ul><h3 id="贫血，充血模型"><a href="#贫血，充血模型" class="headerlink" title="贫血，充血模型"></a>贫血，充血模型</h3><ul><li>《贫血，充血模型的解释以及一些经验》<ul><li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li><li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li><li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li><li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li><li>作者主张使用贫血模式。</li></ul></li></ul><h2 id="Actor-模式"><a href="#Actor-模式" class="headerlink" title="Actor 模式"></a>Actor 模式</h2><p>TODO</p><h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>TODO</p><h3 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h3><p>TODO</p><h3 id="Vert-x"><a href="#Vert-x" class="headerlink" title="Vert.x"></a>Vert.x</h3><p>TODO</p><h2 id="DODAF2-0"><a href="#DODAF2-0" class="headerlink" title="DODAF2.0"></a>DODAF2.0</h2><ul><li><a class="link"   href="http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml" >《DODAF2.0方法论》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://blog.51cto.com/xiaoyong/1553164" >《DODAF2.0之能力视角如何落地》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><p>无需过多关系服务器的服务架构理念。</p><ul><li><a class="link"   href="http://www.jdon.com/soa/serverless.html" >《什么是Serverless无服务器架构？》<i class="fas fa-external-link-alt"></i></a><ul><li>Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。</li><li>Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。</li><li>Serverless 不代表某个具体的框架。</li></ul></li><li><a class="link"   href="http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless" >《如何理解Serverless？》<i class="fas fa-external-link-alt"></i></a><ul><li>依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）</li></ul></li></ul><h2 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h2><ul><li><a class="link"   href="https://time.geekbang.org/article/2355" >《什么是Service Mesh？》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.jianshu.com/p/e23e3e74538e" >《初识 Service Mesh》<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="架构评审"><a href="#架构评审" class="headerlink" title="架构评审"></a>架构评审</h2><ul><li><a class="link"   href="http://developer.51cto.com/art/201506/478486.htm" >《架构设计之如何评审架构设计说明书》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/wireless_com/article/details/45935591" >《人人都是架构师：非功能性需求》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul><li><a class="link"   href="http://www.infoq.com/cn/articles/architect-12-rules-complete/" >《架构之重构的12条军规》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ul><li><a class="link"   href="https://github.com/alibaba/p3c" >《阿里巴巴Java开发手册》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="代码-Review"><a href="#代码-Review" class="headerlink" title="代码 Review"></a>代码 Review</h2><p>制度还是制度! 另外，每个公司需要根据自己的需求和目标制定自己的 check list</p><ul><li><a class="link"   href="http://www.sohu.com/a/229745352_181657" >《为什么你做不好 Code Review？》<i class="fas fa-external-link-alt"></i></a><ul><li>代码 review 做的好，在于制度建设。</li></ul></li><li><a class="link"   href="https://blog.csdn.net/uxyheaven/article/details/49773619" >《从零开始Code Review》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.cnblogs.com/zuoping/p/5477047.html" >《Code Review Checklist》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://dzone.com/articles/java-code-review-checklist" >《Java Code Review Checklist》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/legend0011/article/details/45585575" >《如何用 gitlab 做 code review》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="RUP"><a href="#RUP" class="headerlink" title="RUP"></a>RUP</h2><ul><li><a class="link"   href="https://blog.csdn.net/apanious/article/details/51011946" >《运用RUP 4+1视图方法进行软件架构设计》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="看板管理"><a href="#看板管理" class="headerlink" title="看板管理"></a>看板管理</h2><ul><li><a class="link"   href="https://blog.csdn.net/tkchen/article/details/51637643" >《说说看板在项目中的应用》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="SCRUM"><a href="#SCRUM" class="headerlink" title="SCRUM"></a>SCRUM</h2><p>SCRUM - 争球</p><ul><li>3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。</li><li>3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；</li><li>五个价值观：专注、勇气、公开、承诺、尊重。</li><li><a class="link"   href="https://blog.csdn.net/inny100_100/article/details/54633757" >《敏捷项目管理流程-Scrum框架最全总结！》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/superkunkun/article/details/52951142" >《敏捷其实很简单3—敏捷方法之scrum》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><p>TODO</p><h2 id="极限编程（XP）"><a href="#极限编程（XP）" class="headerlink" title="极限编程（XP）"></a>极限编程（XP）</h2><p>XP - eXtreme Programming</p><ul><li>《主流敏捷开发方法：极限编程XP》<ul><li>是一种指导开发人员的方法论。</li><li>4大价值：<ul><li>沟通：鼓励口头沟通，提高效率。</li><li>简单：够用就好。</li><li>反馈：及时反馈、通知相关人。</li><li>勇气：提倡拥抱变化，敢于重构。</li></ul></li><li>5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。</li><li>5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。</li></ul></li></ul><h2 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h2><p>边写码，边review。能够增强代码质量、减少bug。</p><ul><li><a class="link"   href="http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B" >《结对编程》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="PDCA-循环质量管理"><a href="#PDCA-循环质量管理" class="headerlink" title="PDCA 循环质量管理"></a>PDCA 循环质量管理</h2><p>P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进</p><ul><li><a class="link"   href="http://www.baike.com/wiki/PDCA" >《PDCA》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="FMEA管理模式"><a href="#FMEA管理模式" class="headerlink" title="FMEA管理模式"></a>FMEA管理模式</h2><p>TODO</p><h1 id="通用业务术语"><a href="#通用业务术语" class="headerlink" title="通用业务术语"></a>通用业务术语</h1><p>TODO</p><h1 id="技术趋势"><a href="#技术趋势" class="headerlink" title="技术趋势"></a>技术趋势</h1><p>TODO</p><h1 id="政策、法规"><a href="#政策、法规" class="headerlink" title="政策、法规"></a>政策、法规</h1><h2 id="法律"><a href="#法律" class="headerlink" title="法律"></a>法律</h2><ul><li><p><a class="link"   href="https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95/16843044" >《中华人民共和国网络安全法》<i class="fas fa-external-link-alt"></i></a></p><ul><li>2016年11月7日发布，自2017年6月1日起施行</li></ul></li><li><p><a class="link"   href="https://baike.baidu.com/item/%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E4%BF%9D%E6%8A%A4%E6%B3%95/8343360" >《个人信息保护法》<i class="fas fa-external-link-alt"></i></a></p><ul><li>个人信息保护法是一部保护个人信息的法律条款，现尚在制订中，2019全国两会信息安全相关提案中，有政协委员呼吁关注大数据时代隐私保护，加速立法。</li></ul></li><li><p><a class="link"   href="https://baike.baidu.com/item/%E6%9C%80%E9%AB%98%E4%BA%BA%E6%B0%91%E6%B3%95%E9%99%A2%E3%80%81%E6%9C%80%E9%AB%98%E4%BA%BA%E6%B0%91%E6%A3%80%E5%AF%9F%E9%99%A2%E5%85%B3%E4%BA%8E%E5%8A%9E%E7%90%86%E4%BE%B5%E7%8A%AF%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E5%88%91%E4%BA%8B%E6%A1%88%E4%BB%B6%E9%80%82%E7%94%A8%E6%B3%95%E5%BE%8B%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E9%87%8A/20497481" >《最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》<i class="fas fa-external-link-alt"></i></a></p><ul><li>《解释》共十三条，自2017年6月1日起施行</li></ul><blockquote><ul><li>1、对于行踪轨迹信息、通信内容、征信信息、财产信息，非法获取、出售或者提供50条以上即算“情节严重”；</li><li>2、对于住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息，标准则是 500条以上；</li><li>3、对于其他公民个人信息，标准为 5000条以上。</li></ul></blockquote></li><li><p><a class="link"   href="https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E6%B3%95/16467544" >《中华人民共和国电子商务法》<i class="fas fa-external-link-alt"></i></a></p><ul><li>2018年8月31日，十三届全国人大常委会第五次会议表决通过《电子商务法》，自2019年1月1日起施行</li><li><a class="link"   href="https://v.youku.com/v_show/id_XNDAzNjAyNDM0MA==.html" >解读电子商务法（一）什么是电商<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://v.youku.com/v_show/id_XNDA1OTc0OTQ5Mg==.html" >解读电子商务法（二）电商经营者<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://v.youku.com/v_show/id_XNDA4NzIyNjI4MA==.html" >解读电子商务法（三）电商行为规范<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://v.qq.com/x/page/e08443fc1cr.html" >解读电子商务法（四）电商的法律关系<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://v.youku.com/v_show/id_XNDA4MTQ2Nzk4NA==.html" >解读电子商务法（外传）电商挣钱的秘密<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://v.qq.com/x/page/j0844twjwr5.html" >解读电子商务法（外传）电商模式<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><p><a class="link"   href="https://blog.csdn.net/a331685690/article/details/79917772" >程序员需要知道的法律常识<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://time.geekbang.org/column/132" >白话法律42讲-为程序员打造的专属法律武器<i class="fas fa-external-link-alt"></i></a></p></li></ul><h3 id="严格遵守刑法253法条"><a href="#严格遵守刑法253法条" class="headerlink" title="严格遵守刑法253法条"></a>严格遵守刑法253法条</h3><p>我国刑法第253条之一规定：</p><blockquote><ul><li>国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。</li><li>窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。</li><li>单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。</li></ul></blockquote><p>最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”</p><ul><li><a class="link"   href="https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA" >《非法获取公民个人信息罪》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="避风港原则"><a href="#避风港原则" class="headerlink" title="避风港原则"></a>避风港原则</h3><p>“避风港”原则是指在发生著作权侵权案件时，当ISP（网络服务提供商）只提供空间服务，并不制作网页内容，如果ISP被告知侵权，则有删除的义务，否则就被视为侵权。如果侵权内容既不在ISP的服务器上存储，又没有被告知哪些内容应该删除，则ISP不承担侵权责任。 后来避风港原则也被应用在搜索引擎、网络存储、在线图书馆等方面。</p><ul><li><a class="link"   href="https://baike.baidu.com/item/%E9%81%BF%E9%A3%8E%E6%B8%AF%E5%8E%9F%E5%88%99/588459?fr=aladdin" >《避风港原则》<i class="fas fa-external-link-alt"></i></a></li></ul><h1 id="架构师素质"><a href="#架构师素质" class="headerlink" title="架构师素质"></a>架构师素质</h1><ul><li><a class="link"   href="http://hellojava.info/?p=430" >《架构师画像》<i class="fas fa-external-link-alt"></i></a><ul><li>业务理解和抽象能力</li><li>NB的代码能力</li><li>全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面；</li><li>全局：是否考虑到了对上下游的系统的影响。</li><li>权衡：权衡投入产出比；优先级和节奏控制；</li></ul></li><li><a class="link"   href="http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know" >《关于架构优化和设计，架构师必须知道的事情》<i class="fas fa-external-link-alt"></i></a><ul><li>要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。</li><li>基础设施、配置、测试、开发、运维综合考虑。</li><li>考虑人、团队、和组织的影响。</li></ul></li><li><a class="link"   href="https://www.zhihu.com/question/19841397" >《如何才能真正的提高自己，成为一名出色的架构师？》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129" >《架构师的必备素质和成长途径》<i class="fas fa-external-link-alt"></i></a><ul><li>素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。</li><li>成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。</li></ul></li><li><a class="link"   href="http://blog.51cto.com/frankfan/1248401" >《架构设计师—你在哪层楼？》<i class="fas fa-external-link-alt"></i></a><ul><li>第一层的架构师看到的只是产品本身</li><li>第二层的架构师不仅看到自己的产品，还看到了整体的方案</li><li>第三层的架构师看到的是商业价值</li></ul></li></ul><h1 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h1><p>TODO</p><h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><h2 id="行业资讯"><a href="#行业资讯" class="headerlink" title="行业资讯"></a>行业资讯</h2><ul><li><a class="link"   href="http://36kr.com/" >36kr<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.techweb.com.cn/" >Techweb<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="公众号列表"><a href="#公众号列表" class="headerlink" title="公众号列表"></a>公众号列表</h2><p>TODO</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><h3 id="团队博客"><a href="#团队博客" class="headerlink" title="团队博客"></a>团队博客</h3><ul><li><a class="link"   href="http://jm.taobao.org/" >阿里中间件博客<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://tech.meituan.com/" >美团点评技术团队博客<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h3><ul><li><a class="link"   href="http://www.ruanyifeng.com/" >阮一峰的网络日志<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://coolshell.cn/" >酷壳 - COOLSHELL-陈皓<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://hellojava.info/" >hellojava-阿里毕玄<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://cmsblogs.com/" >Cm’s Blog<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://blog.didispace.com/" >程序猿DD-翟永超-《Spring Cloud微服务实战》作者<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="综合门户、社区"><a href="#综合门户、社区" class="headerlink" title="综合门户、社区"></a>综合门户、社区</h2><p><strong>国内：</strong></p><ul><li><a class="link"   href="http://csdn.net/" >CSDN<i class="fas fa-external-link-alt"></i></a> 老牌技术社区、不必解释。</li><li><a class="link"   href="http://www.51cto.com/" >51cto.com<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.iteye.com/" >ITeye<i class="fas fa-external-link-alt"></i></a><ul><li>偏 Java 方向</li></ul></li><li><a class="link"   href="https://www.cnblogs.com/" >博客园<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.chinaunix.net/" >ChinaUnix<i class="fas fa-external-link-alt"></i></a><ul><li>偏 Linux 方向</li></ul></li><li><a class="link"   href="https://www.oschina.net/" >开源中国社区<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.infoq.cn/" >InfoQ<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.open-open.com/" >深度开源<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.jobbole.com/" >伯乐在线<i class="fas fa-external-link-alt"></i></a><ul><li>涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。</li></ul></li><li><a class="link"   href="http://www.itpub.net/" >ITPUB<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://cloud.tencent.com/developer/column" >腾讯云— 云+社区<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://yq.aliyun.com/" >阿里云— 云栖社区<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.ibm.com/developerworks/cn/" >IBM DeveloperWorks<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://toutiao.io/" >开发者头条<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.linkedkeeper.com/" >LinkedKeeper<i class="fas fa-external-link-alt"></i></a></li></ul><p><strong>国外：</strong></p><ul><li><a class="link"   href="https://dzone.com/" >DZone<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.reddit.com/" >Reddit<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="问答、讨论类社区"><a href="#问答、讨论类社区" class="headerlink" title="问答、讨论类社区"></a>问答、讨论类社区</h2><ul><li>segmentfault<ul><li>问答+专栏</li></ul></li><li><a class="link"   href="https://www.zhihu.com/" >知乎<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://stackoverflow.com/" >stackoverflow<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="行业数据分析"><a href="#行业数据分析" class="headerlink" title="行业数据分析"></a>行业数据分析</h2><ul><li><a class="link"   href="http://report.iresearch.cn/" >艾瑞网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.questmobile.com.cn/" >QUEST MOBILE<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://data.stats.gov.cn/" >国家数据<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.talkingdata.com/" >TalkingData<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="专项网站"><a href="#专项网站" class="headerlink" title="专项网站"></a>专项网站</h2><ul><li>测试:<ul><li><a class="link"   href="http://www.ltesting.net/" >领测国际<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.testwo.com/" >测试窝<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://testerhome.com/" >TesterHome<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>运维:<ul><li><a class="link"   href="http://www.yunweipai.com/" >运维派<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.abcdocker.com/" >Abcdocker<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>Java:<ul><li>ImportNew<ul><li>专注于 Java 技术分享</li></ul></li><li>HowToDoInJava<ul><li>英文博客</li></ul></li></ul></li><li>安全<ul><li><a class="link"   href="https://www.2cto.com/" >红黑联盟<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.freebuf.com/" >FreeBuf<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>大数据<ul><li><a class="link"   href="http://www.thebigdata.cn/" >中国大数据<i class="fas fa-external-link-alt"></i></a></li></ul></li><li>其他专题网站：<ul><li>InfoQ<ul><li>偏重于基础架构、运维方向</li></ul></li><li>DockerInfo<ul><li>专注于 Docker 应用及咨询、教程的网站</li></ul></li><li>Linux公社<ul><li>Linux 主题社区</li></ul></li></ul></li></ul><h2 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h2><ul><li><a class="link"   href="https://github.com/TeamStuQ/skill-map" >程序员技能图谱<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="推荐参考书"><a href="#推荐参考书" class="headerlink" title="推荐参考书"></a>推荐参考书</h2><h3 id="在线电子书"><a href="#在线电子书" class="headerlink" title="在线电子书"></a>在线电子书</h3><ul><li><a class="link"   href="https://github.com/forezp/SpringCloudLearning" >《深入理解Spring Cloud与微服务构建》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf" >《阿里技术参考图册-研发篇》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf" >《阿里技术参考图册-算法篇》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://dpurl.cn/n/1lqcX" >《2018美团点评技术年货（合辑）》70M<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.infoq.com/cn/architect/" >InfoQ《架构师》月刊<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.w3cschool.cn/architectroad/" >《架构师之路》<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="纸质书"><a href="#纸质书" class="headerlink" title="纸质书"></a>纸质书</h3><p><strong>更多架构方面书籍参考:</strong> <a class="link"   href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%9E%B6%E6%9E%84" >awesome-java-books<i class="fas fa-external-link-alt"></i></a></p><h4 id="开发方面"><a href="#开发方面" class="headerlink" title="开发方面"></a>开发方面</h4><ul><li>《阿里巴巴Java开发手册》详情</li></ul><h4 id="架构方面"><a href="#架构方面" class="headerlink" title="架构方面"></a>架构方面</h4><ul><li>《软件架构师的12项修炼：技术技能篇》<a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=rTlo0m" >详情<i class="fas fa-external-link-alt"></i></a></li><li>《架构之美》<a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=1KECBZ" >详情<i class="fas fa-external-link-alt"></i></a></li><li>《分布式服务架构》<a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=hkzqtK" >详情<i class="fas fa-external-link-alt"></i></a></li><li>《聊聊架构》 <a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=A8Nd6Z" >详情<i class="fas fa-external-link-alt"></i></a></li><li>《云原生应用架构实践》<a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=D4WCpd" >详情<i class="fas fa-external-link-alt"></i></a></li><li>《亿级流量网站架构核心技术》<a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Rdmd21" >详情<i class="fas fa-external-link-alt"></i></a></li><li>《淘宝技术这十年》<a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=CoUdGG" >详情<i class="fas fa-external-link-alt"></i></a></li><li>《企业IT架构转型之道-中台战略思想与架构实战》 <a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BxS6eI" >详情<i class="fas fa-external-link-alt"></i></a></li><li>《高可用架构（第1卷）》<a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BcjUwS" >详情<i class="fas fa-external-link-alt"></i></a></li></ul><h4 id="技术管理方面"><a href="#技术管理方面" class="headerlink" title="技术管理方面"></a>技术管理方面</h4><ul><li>《CTO说》<a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Gl3QAo" >详情<i class="fas fa-external-link-alt"></i></a></li><li>《技术管理之巅》<a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=MeloLt" >详情<i class="fas fa-external-link-alt"></i></a></li><li>《网易一千零一夜：互联网产品项目管理实战》<a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=qPuqMg" >详情<i class="fas fa-external-link-alt"></i></a></li></ul><h4 id="基础理论-1"><a href="#基础理论-1" class="headerlink" title="基础理论"></a>基础理论</h4><ul><li>《数学之美》<a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=0seUpO" >详情<i class="fas fa-external-link-alt"></i></a></li><li>《编程珠玑》<a class="link"   href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=I7jj9r" >详情<i class="fas fa-external-link-alt"></i></a></li></ul><h4 id="工具方面"><a href="#工具方面" class="headerlink" title="工具方面"></a>工具方面</h4><p>TODO</p><h4 id="大数据方面"><a href="#大数据方面" class="headerlink" title="大数据方面"></a>大数据方面</h4><h1 id="技术资源"><a href="#技术资源" class="headerlink" title="技术资源"></a>技术资源</h1><h2 id="开源资源"><a href="#开源资源" class="headerlink" title="开源资源"></a>开源资源</h2><ul><li><a class="link"   href="https://github.com/" >github<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.apache.org/index.html" >Apache 软件基金会<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="手册、文档、教程"><a href="#手册、文档、教程" class="headerlink" title="手册、文档、教程"></a>手册、文档、教程</h2><p><strong>国内：</strong></p><ul><li><a class="link"   href="http://w3cschool.cn/" >W3Cschool<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.runoob.com/" >Runoob.com<i class="fas fa-external-link-alt"></i></a><ul><li>HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。</li></ul></li><li><a class="link"   href="https://love2.io/" >Love2.io<i class="fas fa-external-link-alt"></i></a><ul><li>很多很多中文在线电子书，是一个全新的开源技术文档分享平台。</li></ul></li><li><a class="link"   href="http://gitbook.cn/" >gitbook.cn<i class="fas fa-external-link-alt"></i></a><ul><li>付费电子书。</li></ul></li><li><a class="link"   href="http://www.apachecn.org/" >ApacheCN<i class="fas fa-external-link-alt"></i></a><ul><li>AI、大数据方面系列中文文档。</li></ul></li></ul><p><strong>国外：</strong></p><ul><li>Quick Code<ul><li>免费在线技术教程。</li></ul></li><li>gitbook.com<ul><li>有部分中文电子书。</li></ul></li><li>Cheatography<ul><li>Cheat Sheets 大全，单页文档网站。</li></ul></li><li>Tutorialspoint<ul><li>知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。</li></ul></li><li>LeetCode<ul><li>知名题库网站，提供Java、Python、C#、C++、算法、SQL、等高质量各程度题库和解决办法。</li></ul></li></ul><h2 id="在线课堂"><a href="#在线课堂" class="headerlink" title="在线课堂"></a>在线课堂</h2><ul><li><a class="link"   href="http://www.xuetuwuyou.com/" >学徒无忧<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://time.geekbang.org/" >极客时间<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://segmentfault.com/lives" >segmentfault<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://new.stuq.org/course/explore" >斯达克学院<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://nowcoder.com/" >牛客网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.jikexueyuan.com/" >极客学院<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://edu.51cto.com/" >51CTO学院<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="会议、活动"><a href="#会议、活动" class="headerlink" title="会议、活动"></a>会议、活动</h2><ul><li><a class="link"   href="http://www.infoq.com/cn/qcon/" >QCon<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://archsummit.com/" >ArchSummit<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://www.thegitc.com/" >GITC全球互联网技术大会<i class="fas fa-external-link-alt"></i></a></li></ul><p><strong>活动发布平台:</strong></p><ul><li><a class="link"   href="http://www.huodongxing.com/" >活动行<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="常用APP"><a href="#常用APP" class="headerlink" title="常用APP"></a>常用APP</h2><ul><li><a class="link"   href="https://time.geekbang.org/" >极客时间<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.igetget.com/" >得到<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h2><ul><li><a class="link"   href="https://www.zhipin.com/" >Boss直聘<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.lagou.com/" >拉勾网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.liepin.com/" >猎聘<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://cn.100offer.com/" >100Offer<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>极客搜索<ul><li>技术文章搜索引擎。</li></ul></li></ul><h2 id="代码托管"><a href="#代码托管" class="headerlink" title="代码托管"></a>代码托管</h2><ul><li><a class="link"   href="https://coding.net/" >Coding<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://gitee.com/" >码云<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="文件服务"><a href="#文件服务" class="headerlink" title="文件服务"></a>文件服务</h2><ul><li>七牛</li><li>又拍云</li></ul><h2 id="综合云服务商"><a href="#综合云服务商" class="headerlink" title="综合云服务商"></a>综合云服务商</h2><ul><li>阿里云</li><li><a class="link"   href="https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c" >腾讯云<i class="fas fa-external-link-alt"></i></a></li><li>百度云</li><li>新浪云</li><li>金山云</li><li><a class="link"   href="https://amazonaws-china.com/cn/" >亚马逊云(AWS)<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://cloud.google.com/?hl=zh-cn" >谷歌云<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://azure.microsoft.com/zh-cn/" >微软云<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><ul><li><a class="link"   href="http://linode.com/" >Linode<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.digitalocean.com/" >DigitalOcean<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.vultr.com/" >Vultr<i class="fas fa-external-link-alt"></i></a></li></ul><p><img                       lazyload                     alt="image"                     data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAACMCAYAAACksC0pAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALjSURBVHhe7doxbuswFETRSG68pVTZ+y+SJdmVE/GDC0hzBxnynoqpBGhIaoy84/vyBnu9Xv9ut9vH/HN5j8fj836/v88/Mc/n8+uca9RxHPgm2VUkwN2kNux4TiTA65Y+5nIL53m+5hI1nuMJLGeAgKu0xW42AwQEiv1/10bJBLhhC0198z2BBFtoueUC3I0BlkvdOLZQyGiHc4myhXJsoc2CG9YWSkgFeJ6nJYZgCy1nCy23XIC7tVBPYL/YhjVAwGiHc4mK/Uc+daX8FbZQ/YrfQEhqpGIwQEDqkzE2SiTA3X5GJHkCAcuVmN1aqIO95ZIb1gABqQD9GQG5XuxcsRyp4KSuUE8gwRZabrkAd2OA5Wyh5Rzs7WcLbRbcsLZQQipAB3shttByttByywW4Wwv1BPaLbVgDBDjYW84WWs5vYLnkjWOAgFSADvYuwBMISG1YWyhkvNi5RNlCIZaYcqkAx3MMEHC92LliOVLBSV2hnkBCasPGSowtlGELLWeAEFtoOQd7+9lCmwU3rC2UkApwjG54AgGpAG2hEFtoueUC3K2FegL7xTasAQJGO5xLlCMVEFtoOb+B5ZI3jgECUgE62LsATyAgtWFtoRBHKspZYsqlAhzPMUDA9WLniuVIBSd1hXoCCakNGysxtlCGLbScAUJsoeUc7O1nC20W3LC2UEIqwDG64QkEpAK0hUJsoeWWC3C3FuoJ7BfbsAYIGO1wLlGOVEBsoeX8BpZL3jgGCEgF6GDvAjyBgOVKzG4tNDVSEfsZsRtLTLlUgOM5Bgi4XuxcsRyp4KSuUE8gwRZabrkAd2OA5Wyh5Rzs7WcLbRbcsLZQQipAB3shttByttByywW4Wwv1BPaLbVgDBDjYW84Wql/xGwgZ85pziTNAQOqT4WDvAjyBgOVKzG4t1MHecskNa4CAVID+jIBcL3auWI5UcFJXqCeQYAstt1yAuzHAcrbQcg729rOFNstt2LfvHxY+GuRFc4rhAAAAAElFTkSuQmCC"                      alt="img"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;后端架构师技术图谱&quot;&gt;&lt;a href=&quot;#后端架构师技术图谱&quot; class=&quot;headerlink&quot; title=&quot;后端架构师技术图谱&quot;&gt;&lt;/a&gt;后端架构师技术图谱&lt;/h1&gt;&lt;p&gt;👍 👍 👍 推荐一个在线搜课程的神器，“&lt;a class=&quot;link&quot;   h</summary>
      
    
    
    
    <category term="后端架构师技术" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="后端架构师" scheme="http://example.com/tags/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    
  </entry>
  
</feed>
